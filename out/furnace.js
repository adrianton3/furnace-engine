(function () {
  if (localStorage.furnaceDev) { require.config({ baseUrl: "js" }); }
  else (function () {// Generated by CoffeeScript 1.8.0
(function() {
  define('Util',[], function() {
    
    var Util;
    Util = {};
    Util.maptree = function(tree, fun, predicate) {
      var key, newObj;
      if (predicate(tree)) {
        return fun(tree);
      }
      if (tree instanceof Array) {
        return tree.map(function(elem) {
          return Util.maptree(elem, fun, predicate);
        });
      } else if (typeof tree === 'object') {
        newObj = {};
        for (key in tree) {
          newObj[key] = Util.maptree(tree[key], fun, predicate);
        }
        return newObj;
      }
    };
    Util.findFirst = function(array, predicate) {
      var i;
      i = 0;
      while (i < array.length) {
        if (predicate(array[i], i)) {
          return {
            element: array[i],
            index: i
          };
        }
        i++;
      }
    };
    Util.removeFirst = function(array, predicate) {
      var firstMatch;
      firstMatch = Util.findFirst(array, predicate);
      if (firstMatch) {
        array.splice(firstMatch.index, 1);
      }
    };
    Util.remove = function(array, element) {
      Util.removeFirst(array, function(entry) {
        return entry === element;
      });
    };
    Util.objectToArray = function(object, nameProperty, dataProperty) {
      var array, entry, key;
      array = [];
      for (key in object) {
        entry = {};
        entry[nameProperty] = key;
        entry[dataProperty] = object[key];
        array.push(entry);
      }
      return array;
    };
    Util.arrayToObject = function(array, nameProperty, dataProperty) {
      var object;
      object = {};
      array.forEach(function(element) {
        object[element[nameProperty]] = element[dataProperty];
      });
      return object;
    };
    Util.indexBy = function(array, nameProperty) {
      var map;
      map = {};
      if (typeof nameProperty === 'string') {
        array.forEach(function(element) {
          map[element[nameProperty]] = element;
        });
      } else {
        array.forEach(function(element) {
          map[nameProperty(element)] = element;
        });
      }
      return map;
    };
    Util.pluck = function(array, propertyName) {
      return array.map(function(element) {
        return element[propertyName];
      });
    };
    Util.getSet = function(array, nameProperty) {
      var set;
      set = {};
      if (nameProperty != null) {
        array.forEach(function(element) {
          set[element[nameProperty]] = true;
        });
      } else {
        array.forEach(function(element) {
          set[element] = true;
        });
      }
      return set;
    };
    Util.mapOnKeys = function(object, fun) {
      var key, ret;
      ret = {};
      for (key in object) {
        ret[key] = fun(object[key]);
      }
      return ret;
    };
    Util.groupBy = function(array, fun) {
      var groups;
      groups = {};
      array.forEach(function(element) {
        var ret;
        ret = fun(element);
        if (!groups[ret]) {
          groups[ret] = [];
        }
        groups[ret].push(element);
      });
      return groups;
    };
    Util.getDuplicate = function(array) {
      var duplicate, elementsByName, index;
      elementsByName = {};
      duplicate = null;
      index = -1;
      array.every(function(element, i) {
        if (elementsByName[element] != null) {
          duplicate = element;
          index = i;
          return false;
        } else {
          elementsByName[element] = true;
          return true;
        }
      });
      return {
        value: duplicate,
        index: index
      };
    };
    Util.capitalize = function(string) {
      return string.substring(0, 1).toUpperCase() + string.substring(1);
    };
    Util.isCapitalized = function(string) {
      var _ref;
      return ('A' <= (_ref = string[0]) && _ref <= 'Z');
    };
    return Util;
  });

}).call(this);

define('Bus',['Util'], function (Util) {
	

	function Bus() {
		this.channels = {};
	}

	Bus.prototype.addListener = function (channel, id, callback) {
		if (!this.channels[channel]) {
			this.channels[channel] = [];
		}
		this.channels[channel].push({ id: id, callback: callback });
	};

	Bus.prototype.emit = function (channel, data) {
		if (this.channels[channel]) {
			this.channels[channel].forEach(function(listener) {
				listener.callback(data);
			});
		}
	};

	Bus.prototype.removeListener = function (channel, id) {
		Util.removeFirst(this.channels[channel], function(listener) { return listener.id === id; });
	};

	Bus.prototype.removeChannel = function (channel) {
		delete this.channels[channel];
	};

	Bus.prototype.reset = function () {
		this.channels = {};
	};

	return Bus;
});

define('SystemBus',['Bus'], function (Bus) {
	

	var SystemBus = new Bus();

	return SystemBus;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('Font',[], function() {
    var colorBindings, convert, namedSprites;
    colorBindings = [
      {
        name: '1',
        red: '255',
        green: '255',
        blue: '255'
      }, {
        name: '2',
        red: '0',
        green: '0',
        blue: '0'
      }, {
        name: '.',
        red: '0',
        green: '0',
        blue: '0',
        alpha: '0'
      }
    ];
    namedSprites = [
      {
        name: '0',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112....11112..\n..112.1112.112..\n..11112....112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'A',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: 'N',
        data: '.112.........112\n.112.........112\n.11112.......112\n.112.112.....112\n.112...112...112\n.112.....112.112\n.112.......11112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112'
      }, {
        name: '1',
        data: '.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......'
      }, {
        name: 'B',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....'
      }, {
        name: 'O',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '2',
        data: '....11111112....\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n...........112..\n....11111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..'
      }, {
        name: 'C',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'P',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........'
      }, {
        name: '3',
        data: '....11111112....\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n...........112..\n.......11112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'D',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....'
      }, {
        name: 'Q',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112..112.112..\n..112....11112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '4',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..'
      }, {
        name: 'E',
        data: '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..'
      }, {
        name: 'R',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: '5',
        data: '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'F',
        data: '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........'
      }, {
        name: 'S',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n....11111112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '6',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111.....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'G',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'T',
        data: '..1111111111112.\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......'
      }, {
        name: '7',
        data: '..111111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..'
      }, {
        name: 'H',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: 'U',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '8',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'I',
        data: '.....1111112....\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.....1111112....'
      }, {
        name: 'V',
        data: '.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.......112......'
      }, {
        name: '9',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....1111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'J',
        data: '..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n....112...112...\n....112...112...\n......11112.....'
      }, {
        name: 'W',
        data: '.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112...112...112\n.112.112.112.112\n.11112.....11112\n.112.........112\n.112.........112'
      }, {
        name: '.',
        data: '................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n.......112......\n.......112......'
      }, {
        name: 'K',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112....112....\n..11111112......\n..112....112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: 'X',
        data: '.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.....112.112....\n.....112.112....\n...112.....112..\n...112.....112..\n.112.........112\n.112.........112\n.112.........112'
      }, {
        name: '!',
        data: '.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n................\n................\n.......112......\n.......112......'
      }, {
        name: 'L',
        data: '..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..'
      }, {
        name: 'Y',
        data: '.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......'
      }, {
        name: '?',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n.........112....\n.......112......\n.......112......\n.......112......\n.......112......\n................\n................\n.......112......\n.......112......'
      }, {
        name: 'M',
        data: '.112.........112\n.112.........112\n.11112.....11112\n.112.112.112.112\n.112...112...112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112'
      }, {
        name: 'Z',
        data: '...11111111112..\n...........112..\n...........112..\n...........112..\n.........112....\n.........112....\n.........112....\n.......112......\n.......112......\n.......112......\n.....112........\n.....112........\n.....112........\n...112..........\n...112..........\n...11111111112..'
      }
    ];
    convert = function(namedSprites) {
      return namedSprites.map(function(namedSprite) {
        return {
          name: namedSprite.name,
          data: namedSprite.data.split('\n')
        };
      });
    };
    return {
      colorBindings: colorBindings,
      namedSprites: convert(namedSprites)
    };
  });

}).call(this);

define('con2d',[], function () {
	

	var canvas = document.getElementById('can');

	var con2d = canvas.getContext('2d');

	return con2d;
});

define('Sprite',[
	'con2d'
	], function (
		con2d
	) {
	

	function Sprite(spriteSheet, start, end) {
		this.spriteSheet = spriteSheet;
		this.start = start;
		this.end = end;
	}

	Sprite.prototype.drawAt = function(x, y) {
		con2d.drawImage(
			this.spriteSheet,
			this.start.x, this.start.y, this.end.x - this.start.x, this.end.y - this.start.y,
			x, y, this.end.x - this.start.x, this.end.y - this.start.y
		);
	};

	return Sprite;
});

define('Vec2',[], function () {
	

	function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
            return new Vec2(x, y);
        }
		this.x = x;
		this.y = y;
	}

	Vec2.prototype.copy = function () {
		return new Vec2(this.x, this.y);
	};

	Vec2.prototype.add = function (that) {
		return new Vec2(this.x + that.x, this.y + that.y);
	};

	Vec2.prototype.addOn = function (that) {
		this.x += that.x;
		this.y += that.y;
	};

	Vec2.prototype.sub = function (that) {
		return new Vec2(this.x - that.x, this.y - that.y);
	};

	Vec2.prototype.subOn = function (that) {
		this.x -= that.x;
		this.y -= that.y;
	};

	Vec2.prototype.scale = function (scale) {
		return new Vec2(this.x * scale, this.y * scale);
	};

	Vec2.prototype.scaleOn = function (scale) {
		this.x *= scale;
		this.y *= scale;
	};

	Vec2.prototype.mul = function (that) {
		return new Vec2(this.x * that.x, this.y * that.y);
	};

	Vec2.prototype.mulOn = function (that) {
		this.x *= that.x;
		this.y *= that.y;
	};

	return Vec2;
});

define('SpriteSheet',[
	'Sprite',
	'Vec2'
	], function (
		Sprite,
		Vec2
	) {
	

	function SpriteSheet(image, width, height) {
		this.image = image;
		this.width = width;
		this.height = height;
		this.spriteWidth = Math.floor(this.image.width / this.width);
		this.spriteHeight = Math.floor(this.image.height / this.height);
	}

	SpriteSheet.prototype.getSprite = function(x, y) {
		return new Sprite(
			this.image,
			new Vec2(this.spriteWidth * x, this.spriteHeight * y),
			new Vec2((x + 1) * this.spriteWidth, (y + 1) * this.spriteHeight)
		);
	};

	return SpriteSheet;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('generator/SpriteSheetGenerator',['Util', 'SpriteSheet'], function(Util, SpriteSheet) {
    var SpriteSheetGenerator;
    SpriteSheetGenerator = {};
    SpriteSheetGenerator.generate = function(stringedSprites, colorBindings, scale) {
      var canvas, colorsByBinding, con2d, dataURL, image, namedSprites, paint, pixel, spriteSheet, width;
      pixel = function(x, y, color) {
        con2d.fillStyle = color;
        con2d.fillRect(x * scale, y * scale, scale, scale);
      };
      paint = function(x, y, data) {
        var baseOffsetX, baseOffsetY;
        baseOffsetX = x * data.length;
        baseOffsetY = y * data.length;
        data.forEach(function(line, i) {
          line.split('').forEach(function(char, j) {
            var color;
            color = colorsByBinding[char];
            pixel(baseOffsetX + j, baseOffsetY + i, color);
          });
        });
      };
      colorsByBinding = Util.arrayToObject(colorBindings.map(function(binding) {
        var stringedColor;
        stringedColor = binding.alpha != null ? "rgba(" + binding.red + "," + binding.green + "," + binding.blue + "," + binding.alpha + ")" : "rgb(" + binding.red + "," + binding.green + "," + binding.blue + ")";
        return {
          name: binding.name,
          stringedColor: stringedColor
        };
      }), 'name', 'stringedColor');
      width = Math.ceil(Math.sqrt(stringedSprites.length));
      canvas = document.createElement('canvas');
      canvas.width = stringedSprites[0].data.length * width * scale;
      canvas.height = stringedSprites[0].data.length * width * scale;
      con2d = canvas.getContext('2d');
      stringedSprites.forEach(function(stringedSprite, index) {
        var x, y;
        x = index % width;
        y = Math.floor(index / width);
        paint(x, y, stringedSprite.data);
      });
      dataURL = canvas.toDataURL('image/png');
      image = new Image();
      image.src = dataURL;
      spriteSheet = new SpriteSheet(image, width, width);
      namedSprites = stringedSprites.map(function(stringedSprite, index) {
        var x, y;
        x = index % width;
        y = Math.floor(index / width);
        return {
          name: stringedSprite.name,
          sprite: spriteSheet.getSprite(x, y)
        };
      });
      return namedSprites;
    };
    return SpriteSheetGenerator;
  });

}).call(this);

define('Text',[
    'Font',
    'generator/SpriteSheetGenerator',
    'Util'
], function (
    Font,
    SpriteSheetGenerator,
    Util
    ) {

	

	var Text = {};

	Text.sprites = [];

	Text.init = function() {
        var namedSprites = SpriteSheetGenerator.generate(Font.namedSprites, Font.colorBindings, 1);

        namedSprites.forEach(function (namedSprite) {
            Text.sprites[namedSprite.name.charCodeAt(0)] = namedSprite.sprite;
        });
	};

	Text.drawAt = function(string, x, y) {
		string += '';

		var chars = string.split('').map(function(char) { return char.charCodeAt(0); });

		for (var i = 0; i < chars.length; i++) {
			var sprite = Text.sprites[chars[i]];
			if (sprite) {
                sprite.drawAt(x + i * 16, y);
            }
		}
	};

	return Text;
});

define('Items',[], function () {
	

	var Items = {};

	Items.collection = {};

	return Items;
});

define('Player',[
	'SystemBus',
	'Vec2',
	'Items',
    'con2d'
	], function (
		SystemBus,
		Vec2,
		Items,
        con2d
	) {
	

	function Player(world, healthMax, spritesByName, tileDimensions, uiOffset) {
		this.world = world;
        this.healthMax = healthMax;
        this.health = this.healthMax;
		this.blockWidth = tileDimensions.x;
		this.blockHeight = tileDimensions.y;
		this.uiOffset = uiOffset || new Vec2(0, 0);
		this.position = new Vec2(0, 0);
		this.spritesByName = spritesByName;
        this.sprite = null;
        this.healthSprite = spritesByName['health'];
		this.direction = 'down';
        this.alive = true;
	}

	var keyMapping = {
		65: 'use',
		83: 'invleft',
		68: 'invright',
		70: 'invmark',
		38: 'up',
		37: 'left',
		40: 'down',
		39: 'right'
	};

	var deltas = {
		up: new Vec2(0, -1),
		left: new Vec2(-1, 0),
		down: new Vec2(0, 1),
		right: new Vec2(1, 0)
	};

	var invDeltas = {
		invleft: -1,
		invright: 1
	};

	/**
	 * Initializes the player
	 */
	Player.prototype.init = function () {
		this.direction = 'down';
		this.sprite = this.spritesByName[this.direction];

		SystemBus.addListener('keydown', '', function (data) {
            if (data.key === 75) {
                delete localStorage['furnace-save'];
            }

            if (this.alive) {
                if (this.world.textBubble.visible) {
                    if (data.key === 65) {
                        this.world.textBubble.hide();
                    }
                } else {
                    if (data.key === 85) {
                        this.restore();
                    } else if (data.key === 65) {
                        this.use();
                    } else if (data.key === 83 || data.key === 68) {
                        this.world.inventory.move(invDeltas[keyMapping[data.key]]);
                    } else {
                        if (keyMapping[data.key]) {
                            this.move(deltas[keyMapping[data.key]]);
                            this.direction = keyMapping[data.key];
                            this.sprite = this.spritesByName[this.direction];
                        }
                    }
                }
            } else {
                if (data.key === 82) {
                    this.alive = true;
                    this.world.textBubble.hide();
                    this.restore();
                }
            }
		}.bind(this));
	};

    Player.prototype.healOrHurt = function (delta) {
        if (this.healthMax > 0) {
            this.health += delta;

            if (this.health <= 0) {
                this.alive = false;
                this.world.textBubble.show().setText('Press R to restart');
            } else if (this.health > this.healthMax) {
                this.health = this.healthMax;
            }
        }
    };

	/**
	 * Sets the position of the player
	 */
	Player.prototype.setPosition = function (x, y) {
		this.position.x = x;
		this.position.y = y;
		this.world.camera.centerOn(this.position.x, this.position.y, this.world.level.width, this.world.level.height);
	};

	/**
	 * Moves delta units
	 */
	Player.prototype.move = function (delta) {
		var candidatePosition = this.position.add(delta);
		if (this.world.level.withinBounds(candidatePosition.x, candidatePosition.y)) {
			var futureBlock = this.world.level.get(candidatePosition.x, candidatePosition.y);
			if (!futureBlock.blocking) {
				this.leave();

				this.position = candidatePosition;
				this.world.camera.centerOn(this.position.x, this.position.y, this.world.level.width, this.world.level.height);

				this.enter();

                this.near();
			}
		}
	};

	/**
	 * Teleports the player in the given level at the given coordinates
	 * @param {string} levelName
	 * @param {number} x
	 * @param {number} y
	 */
	Player.prototype.teleport = function (levelName, x, y) {
		this.world.setLevel(levelName);
		this.setPosition(x, y);
	};

	/**
	 * Returns the facing position
	 */
	Player.prototype.getFacing = function () {
		return this.position.add(deltas[this.direction]);
	};

	function resolveItem(inTerrainItem, inInventoryItem, outItem) {
		if (outItem === '_terrain') {
			return inTerrainItem;
		} else if (outItem === '_inventory') {
			return inInventoryItem;
		} else {
			return outItem;
		}
	}

    /**
     * Standard 8 neighbouring locations on a tiled map
     * @type {Vec2[]}
     */
    Player.neighbourhood = [
        new Vec2( 0, -1),
        new Vec2(-1, -1),
        new Vec2(-1,  0),
        new Vec2(-1,  1),
        new Vec2( 0,  1),
        new Vec2( 1,  1),
        new Vec2( 1,  0),
        new Vec2( 1, -1)
    ];

    /**
     * Returns a list of neighbouring locations which are within the bound of the level
     * @returns {Vec2[]}
     */
    Player.prototype.getNearLocations = function () {
        return Player.neighbourhood.map(function (location) {
            return this.position.add(location);
        }.bind(this)).filter(function (location) {
            return this.world.level.withinBounds(location.x, location.y);
        }.bind(this));
    };

    /**
     * Nears neighbouring locations
     */
    Player.prototype.near = function () {
        var level = this.world.level;
        var ruleSet = this.world.nearRuleSet;

        this.getNearLocations().forEach(function (location) {
            var currentTerrainItem = level.get(location.x, location.y);

            var rule = ruleSet.getRuleFor(currentTerrainItem.id);
            if (rule) {
                level.set(
                    location.x,
                    location.y,
                    Items.collection[
                        resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);

                this.healOrHurt(rule.healthDelta);
            }
        }.bind(this));
    };

	/**
	 * Leaves a location
	 */
	Player.prototype.leave = function () {
		var level = this.world.level;
		var ruleSet = this.world.leaveRuleSet;

		var currentTerrainItem = level.get(this.position.x, this.position.y);

		var rule = ruleSet.getRuleFor(currentTerrainItem.id);
		if (rule) {
			level.set(
				this.position.x,
				this.position.y,
				Items.collection[
					resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);
		}
	};

	/**
	 * Enters a new location
	 */
	Player.prototype.enter = function () {
		var inventory = this.world.inventory;
		var level = this.world.level;
		var ruleSet = this.world.enterRuleSet;

		var currentTerrainItem = level.get(this.position.x, this.position.y);

		var rule = ruleSet.getRuleFor(currentTerrainItem.id);
		if (rule) {
			level.set(
				this.position.x,
				this.position.y,
				Items.collection[
					resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);

			rule.outInventoryItems.forEach(function (item) {
				inventory.addItem(
					Items.collection[
						resolveItem(currentTerrainItem.id, -1, item.itemName)],
					item.quantity);
			});

            this.healOrHurt(rule.healthDelta);

			if (rule.teleport) {
				this.teleport(rule.teleport.levelName, rule.teleport.x, rule.teleport.y);
			}

            if (rule.message) {
                this.world.textBubble.show().setText(rule.message);
            }

            if (rule.checkpoint) {
                this.save();
            }
		}
	};

    /**
     * Restores the game to a previously saved state
     */
    Player.prototype.restore = function () {
        if (localStorage['furnace-save']) {
            var serializedGameState = JSON.parse(localStorage['furnace-save']);
            if (serializedGameState) {
                this.world.deserialize(serializedGameState);
            }
        } else {
            this.world.deserialize(this.world.initialState);
        }
    };

    /**
     * Saves the current game state
     */
    Player.prototype.save = function () {
        var serializedGameState = JSON.stringify(this.world.serialize());
        localStorage['furnace-save'] = serializedGameState;
    };

	/**
	 * Uses the current inventory item on the terrain unit that it's facing
	 */
	Player.prototype.use = function () {
		var inventory = this.world.inventory;
		var level = this.world.level;
		var ruleSet = this.world.useRuleSet;

		var currentInventoryItem = inventory.getCurrent();
        if (!currentInventoryItem) { return; }

		var facingPosition = this.getFacing();
		if (level.withinBounds(facingPosition.x, facingPosition.y)) {
			var currentTerrainItem = level.get(facingPosition.x, facingPosition.y);

			var rule = ruleSet.getRuleFor(currentTerrainItem.id, currentInventoryItem.id);
			if (rule) {
				if (!rule.consume ||
					(rule.consume &&
						inventory.has(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, currentInventoryItem.id)]))) {

					if (rule.consume) {
						inventory.consume(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, currentInventoryItem.id)]);
					}

					level.set(
						facingPosition.x,
						facingPosition.y,
						Items.collection[
							resolveItem(currentTerrainItem.id, currentInventoryItem.id, rule.outTerrainItem)]);

					rule.outInventoryItems.forEach(function (item) {
						inventory.addItem(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, item.itemName)],
							item.quantity);
					});

                    this.healOrHurt(rule.healthDelta);

					if (rule.teleport) {
						this.teleport(rule.teleport.levelName, rule.teleport.x, rule.teleport.y);
					}

                    if (rule.message) {
                        this.world.textBubble.show().setText(rule.message);
                    }

					if (rule.sound) {
						this.world.playSound(rule.sound);
					}
				}
			}
		}
	};

	/**
	 * Draws the player
	 */
	Player.prototype.draw = function (camera, tick) {
		this.sprite.drawAt(
			this.uiOffset.x +
			(this.position.x - camera.position.x /*+ Math.floor(camera.dimensions.x / 2)*/) * this.blockWidth,
			this.uiOffset.y +
			(this.position.y - camera.position.y /*+ Math.floor(camera.dimensions.y / 2)*/) * this.blockHeight
		);

        // health
        var offsetX = this.world.tileDimensions.x * (this.world.camera.dimensions.x - 1);
        var offsetY = this.world.tileDimensions.y * this.world.camera.dimensions.y + 8;

        con2d.fillStyle = '#000000';
        con2d.fillRect(
            offsetX - this.healthMax * this.world.tileDimensions.x, offsetY,
            this.healthMax * this.world.tileDimensions.x, this.world.tileDimensions.y
        );

        for (var i = 0; i < this.health; i++) {
            this.healthSprite.drawAt(
                offsetX - i * this.world.tileDimensions.x,
                offsetY
            );
        }
	};

    Player.prototype.serialize = function () {
        return {
            position: {
                x: this.position.x,
                y: this.position.y
            },
            direction: this.direction,
            health: this.health
        };
    };

    Player.prototype.deserialize = function (config) {
        this.setPosition(config.position.x, config.position.y);

        this.direction = config.direction;
        this.sprite = this.spritesByName[this.direction];

        this.health = config.health;
    };

	return Player;
});

define('Inventory',[
		'Items',
		'Text',
		'con2d',
		'Util',
        'underscore'
	], function (
		Items,
		Text,
		con2d,
		Util,
        _
	) {
	

	function Inventory(sizeMax, tileDimensions, uiOffset) {
		this.sizeMax = sizeMax;
        this.sizeCurrent = 0;
		this.tileDimensions = tileDimensions;
		this.uiOffset = uiOffset;
		this.inventory = {};
		this.arrangement = [];
		this.current = 0;
        this.offset = 0;
	}

	/**
	 * Draw the inventory
	 */
	Inventory.prototype.draw = function () {
        // wrap this in a procedure
		con2d.fillStyle = '#000000';
		con2d.fillRect(
			this.uiOffset.x, this.uiOffset.y,
			this.sizeMax * this.tileDimensions.x, this.tileDimensions.y
        );

		for (var i = 0; i < this.sizeCurrent; i++) {
			// if null then skip
			var itemName = this.arrangement[(i + this.offset) % this.arrangement.length];
			var sprite = Items.collection[itemName];
			sprite.drawAt(
				this.uiOffset.x + i * this.tileDimensions.x,
				this.uiOffset.y
			);

			var text = '' + this.inventory[itemName];
			var offsetX = this.uiOffset.x + i * this.tileDimensions.x + this.tileDimensions.x - 4 - 16 * text.length;
			var offsetY = this.uiOffset.y + this.tileDimensions.y - 20;

			Text.drawAt(text, offsetX, offsetY);
		}

        if (this.empty()) { return; }
        // wrap this in a procedure
		con2d.lineWidth = 2;
		con2d.strokeStyle = '#FFF';
		con2d.strokeRect(
			this.uiOffset.x + (this.current - this.offset) * this.tileDimensions.x + 1, this.uiOffset.y + 1,
			this.tileDimensions.x - 2, this.tileDimensions.y - 2
		);
		con2d.strokeStyle = '#000';
		con2d.strokeRect(
			this.uiOffset.x + (this.current - this.offset) * this.tileDimensions.x + 2, this.uiOffset.y + 2,
			this.tileDimensions.x - 4, this.tileDimensions.y - 4
		);
	};

	/**
	 * Move the cursor left and right, changing the current inventory item
	 */
	Inventory.prototype.move = function (delta) {
        if (this.empty()) {
            this.current = 0;
            this.offset = 0;
            return;
        }

        this.current += delta;

        if (this.current < 0) {
            this.current = 0;
            this.offset = 0;
        } else if (this.current < this.offset) {
            this.offset = this.current;
        } else if (this.current >= this.arrangement.length) {
            this.current = this.arrangement.length - 1;
            this.offset = this.current - this.sizeCurrent + 1;
        } else if (this.current >= this.offset + this.sizeMax) {
            this.offset = this.current - this.sizeCurrent + 1;
        }
	};

    /**
     * Checks if the inventory is empty or not
     */
    Inventory.prototype.empty = function () {
        return this.arrangement.length === 0;
    };

    /**
	 * Checks if an item is present in the inventory
	 * @param {Item} item
	 */
	Inventory.prototype.has = function (item) {
		return !!this.inventory[item.id];
	};

	/**
	 * Consumes a specified item from the inventory
	 * @param {Item} item
	 */
	Inventory.prototype.consume = function (item) {
		this.inventory[item.id]--;
		if (!this.inventory[item.id]) {
			Util.remove(this.arrangement, item.id);
			if (this.current >= this.arrangement.length - this.offset - 1) {
				this.current--;
                this.offset = Math.max(this.offset - 1, 0);
			}
            this.sizeCurrent = Math.min(this.sizeMax, this.arrangement.length);
		}
	};

	/**
	 * Adds an item to the inventory
	 * @param {Item} item
 	 * @param {number} quantity
	 */
	Inventory.prototype.addItem = function (item, quantity) {
		if (typeof this.inventory[item.id] === 'number') {
			if (this.inventory[item.id] === 0) {
				this.arrangement.push(item.id);
			}
			this.inventory[item.id] += quantity;
		} else {
			this.inventory[item.id] = quantity;
			this.arrangement.push(item.id);
		}

        this.sizeCurrent = Math.min(this.sizeMax, this.arrangement.length);
	};

	/**
	 * Gets the current selected inventory item
	 */
	Inventory.prototype.getCurrent = function () {
		var itemName = this.arrangement[this.current];
		return Items.collection[itemName];
	};

    Inventory.prototype.serialize = function () {
        var inventory = _.clone(this.inventory);
        var arrangement = _.clone(this.arrangement);

        return {
            inventory: inventory,
            arrangement: arrangement,
            current: this.current,
            sizeCurrent: this.sizeCurrent,
            offset: this.offset
        };
    };

    Inventory.prototype.deserialize = function (config) {
        this.inventory = _.clone(config.inventory);
        this.arrangement = _.clone(config.arrangement);
        this.current = config.current;
        this.sizeCurrent = config.sizeCurrent;
        this.offset = config.offset;
    };

	return Inventory;
});

define('Set',[], function () {
	

	function Set() {
		this.elements = {};
	}

	Set.prototype.add = function(element) {
		this.elements[element] = true;
		return this;
	};

	Set.prototype.remove = function(element) {
		delete this.elements[element];
		return this;
	};

	Set.prototype.has = function(element) {
		return !!this.elements[element];
	};

	Set.prototype.keys = function() {
		return Object.keys(this.elements);
	};

	Set.prototype.copy = function() {
		var newSet = new Set();

		for (var key in this.elements) {
			newSet.add(key);
		}

		return newSet;
	};

	Set.prototype.union = function(that) {
		var newSet = this.copy();

		for (var key in that.elements) {
			newSet.add(key);
		}

		return newSet;
	};

	Set.prototype.intersection = function(that) {
		var newSet = new Set();

		for (var key in this.elements) {
			if (that.has(key)) {
				newSet.add(key);
			}
		}

		return newSet;
	};

	Set.prototype.difference = function(that) {
		var newSet = new Set();

		for (var key in this.elements) {
			if (!that.has(key)) {
				newSet.add(key);
			}
		}

		return newSet;
	};

	return Set;
});

define('rule/RuleSet',[
	'Set',
	'Util'
	], function (
		Set,
		Util
	) {
	

	function RuleSet(rules, setsByName) {
		this.rules = rules || [];
		this.setsByName = setsByName || {};
	}

	RuleSet.prototype.getRuleFor = function(inTerrainItem, inInventoryItem) {
		var firstMatchingRule = Util.findFirst(this.rules, function(rule) {

			var terrainMatch;
			if (Util.isCapitalized(rule.inTerrainItem)) {
				terrainMatch = this.setsByName[rule.inTerrainItem].has(inTerrainItem);
			} else {
				terrainMatch = rule.inTerrainItem === inTerrainItem;
			}

			if (!terrainMatch) {
				return false;
			}

			if (!inInventoryItem) {
				return terrainMatch;
			}

			var inventoryMatch;
			if (Util.isCapitalized(rule.inInventoryItem)) {
				inventoryMatch = this.setsByName[rule.inInventoryItem].has(inInventoryItem);
			} else {
				inventoryMatch = rule.inInventoryItem === inInventoryItem;
			}

			return terrainMatch && inventoryMatch;
		}.bind(this));

		if (firstMatchingRule) {
			return firstMatchingRule.element;
		}
	};

	return RuleSet;
});

define('Camera',[], function () {
	

	function Camera(position, dimensions) {
		this.position = position;
		this.dimensions = dimensions;
	}

	Camera.prototype.centerOn = function (x, y, levelWidth, levelHeight) {
		this.position.x = x - Math.floor(this.dimensions.x / 2);
		this.position.y = y - Math.floor(this.dimensions.y / 2);

		if (this.position.x < 0) {
			this.position.x = 0;
		} else if (this.position.x >= levelWidth - this.dimensions.x) {
			this.position.x = levelWidth - this.dimensions.x;
		}

		if (this.position.y < 0) {
			this.position.y = 0;
		} else if (this.position.y >= levelHeight - this.dimensions.y) {
			this.position.y = levelHeight - this.dimensions.y;
		}
	};

	return Camera;
});

define('TextBubble',[
    'Text',
    'Vec2',
    'con2d',
    'Util'
], function (
    Text,
    Vec2,
    con2d,
    Util
    ) {

	

	function TextBubble() {
        this.position = new Vec2(8, 8);
        this.visible = true;
        this.text = '';
        this.length = -Infinity;
        this.maxLength = 20;
        this.lines = [];
    }

    TextBubble.prototype.hide = function () {
        this.visible = false;
        return this;
	};

    TextBubble.prototype.show = function () {
        this.visible = true;
        return this;
    };

    TextBubble.prototype.draw = function () {
        if (!this.visible) { return; }
        // clear bubble
        con2d.fillStyle = '#007B90';
        con2d.fillRect(this.position.x, this.position.y, this.length * 16 + 8, this.lines.length * 18 + 8);

        // draw the text, line by line
        for (var i = 0; i < this.lines.length; i++) {
            Text.drawAt(this.lines[i], this.position.x + 4, this.position.y + i * 18 + 4);
        }
    };

    TextBubble.prototype.setText = function (text) {
        this.text = text.toUpperCase();

        this.lines = [];
        this.length = -Infinity;

        // chop text on multiple lines
        for (var i = 0; i < this.text.length; i += this.maxLength) {
            var line = this.text.substr(i, this.maxLength).trim();
            this.lines.push(line);

            if (line.length > this.length) {
                this.length = line.length;
            }
        }

        var boxWidth = this.length * 16 + 8;
        this.position.x = Math.floor((con2d.canvas.width - boxWidth) / 2);

        return this;
    };

	return TextBubble;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/SoundUtil',[], function() {
    
    var BASE, GENERATION, INVERSE, SYMBOLS, applyRamp, decode, encode, getEnvelope, options, randomParameters, range;
    GENERATION = '0';
    SYMBOLS = '0123456789ABCDEF'.split('');
    BASE = SYMBOLS.length;
    INVERSE = new Map();
    SYMBOLS.forEach(function(char, index) {
      return INVERSE.set(char, index);
    });
    range = function(min, max) {
      var delta;
      delta = max - min;
      return {
        random: function() {
          var num;
          num = Math.floor(Math.random() * BASE);
          return num * delta / BASE + min;
        },
        encode: function(value) {
          var index;
          index = Math.floor((value - min) / delta * BASE);
          return SYMBOLS[index];
        },
        decode: function(string) {
          var num;
          num = INVERSE.get(string);
          return num * delta / BASE + min;
        }
      };
    };
    options = function(options) {
      return {
        random: function() {
          var index;
          index = Math.floor(Math.random() * options.length);
          return options[index];
        },
        encode: function(value) {
          var index;
          index = options.indexOf(value);
          return SYMBOLS[index];
        },
        decode: function(string) {
          var num;
          num = INVERSE.get(string);
          return options[num];
        }
      };
    };
    randomParameters = function(spec) {
      var keys, parameters;
      parameters = {};
      keys = Object.keys(spec);
      keys.forEach(function(key) {
        return parameters[key] = spec[key].random();
      });
      return parameters;
    };
    encode = function(generation, type, parameters, spec) {
      var keys, string;
      string = GENERATION;
      string += type;
      keys = Object.keys(spec);
      keys.sort();
      keys.forEach(function(key) {
        var encodedParameter;
        encodedParameter = spec[key].encode(parameters[key]);
        return string += encodedParameter;
      });
      return string;
    };
    decode = function(string, spec) {
      var keys, parameters;
      if (string[0] !== GENERATION) {
        throw 'Generation mismatch';
      }
      parameters = {};
      keys = Object.keys(spec);
      keys.sort();
      keys.forEach(function(key, index) {
        var decodedParameter;
        decodedParameter = spec[key].decode(string[index + 2]);
        return parameters[key] = decodedParameter;
      });
      return parameters;
    };
    applyRamp = function(parameter, values, duration) {
      var i, step, _i, _ref;
      parameter.setValueAtTime(values[0], 0.0);
      step = duration / (values.length - 1);
      for (i = _i = 1, _ref = values.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        parameter.linearRampToValueAtTime(values[i], step * i);
      }
    };
    getEnvelope = function(context, values, duration) {
      var envelope, i, step, _i, _ref;
      envelope = context.createGain();
      envelope.gain.setValueAtTime(values[0], 0.0);
      step = duration / (values.length - 1);
      for (i = _i = 1, _ref = values.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        envelope.gain.linearRampToValueAtTime(values[i], step * i);
      }
      return envelope;
    };
    return {
      range: range,
      options: options,
      randomParameters: randomParameters,
      encode: encode,
      decode: decode,
      applyRamp: applyRamp,
      getEnvelope: getEnvelope
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/generations/g0/s0',['sound/SoundUtil'], function(SoundUtil) {
    
    var build, generation, options, range, spec, type;
    range = SoundUtil.range, options = SoundUtil.options;
    generation = 0;
    type = 0;
    spec = {
      duration: range(0.4, 1.0),
      oscType: options(['square', 'sawtooth']),
      oscFreq: range(200, 3000),
      freqEnvelope0: range(300, 400),
      freqEnvelope1: range(500, 600),
      freqEnvelope2: range(300, 400),
      freqEnvelope3: range(100, 200),
      gainEnvelope0: range(0.6, 0.8),
      gainEnvelope1: range(0.4, 0.8),
      gainEnvelope2: range(0.1, 0.4),
      gainEnvelope3: range(0.0, 0.2)
    };
    build = function(context, parameters) {
      var gain, osc, start;
      osc = context.createOscillator();
      osc.type = parameters.oscType;
      osc.frequency.value = parameters.oscFreq;
      SoundUtil.applyRamp(osc.frequency, [parameters.freqEnvelope0, parameters.freqEnvelope1, parameters.freqEnvelope2, parameters.freqEnvelope3], parameters.duration);
      gain = context.createGain();
      SoundUtil.applyRamp(gain.gain, [parameters.gainEnvelope0, parameters.gainEnvelope1, parameters.gainEnvelope2, parameters.gainEnvelope3], parameters.duration);
      osc.connect(gain);
      start = function() {
        return osc.start();
      };
      return {
        start: start,
        destination: gain
      };
    };
    return {
      generation: generation,
      type: type,
      spec: spec,
      build: build
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/generations/g0/s1',['sound/SoundUtil'], function(SoundUtil) {
    
    var build, generation, options, range, spec, type;
    range = SoundUtil.range, options = SoundUtil.options;
    generation = 0;
    type = 1;
    spec = {
      duration: range(0.4, 0.8),
      oscType: options(['square']),
      oscFreq: range(100, 3000),
      gainEnvelope0: range(0.6, 0.8),
      gainEnvelope1: range(0.5, 0.6),
      gainEnvelope2: range(0.1, 0.4),
      gainEnvelope3: range(0.0, 0.2),
      lfoType: options(['square', 'sawtooth']),
      lfoFreq: range(1.0, 8.0),
      lfoEnvelope0: range(0.0, 20.0),
      lfoEnvelope1: range(0.0, 20.0)
    };
    build = function(context, parameters) {
      var envelope, gain, lfo, lfoEnvelope, osc, start;
      osc = context.createOscillator();
      osc.type = parameters.oscType;
      osc.frequency.value = parameters.ofcFreq;
      lfo = context.createOscillator();
      lfo.type = parameters.lfoType;
      lfo.frequency.value = parameters.lfoFreq;
      envelope = [parameters.lfoEnvelope0, parameters.lfoEnvelope1];
      lfoEnvelope = SoundUtil.getEnvelope(context, envelope, parameters.duration);
      lfo.connect(lfoEnvelope);
      lfoEnvelope.connect(osc.frequency);
      envelope = [parameters.gainEnvelope0, parameters.gainEnvelope1, parameters.gainEnvelope2, parameters.gainEnvelope3];
      gain = context.createGain();
      SoundUtil.applyRamp(gain.gain, envelope, parameters.duration);
      osc.connect(gain);
      start = function() {
        osc.start();
        return lfo.start();
      };
      return {
        start: start,
        destination: gain
      };
    };
    return {
      generation: generation,
      type: type,
      spec: spec,
      build: build
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/generations/g0/s2',['sound/SoundUtil'], function(SoundUtil) {
    
    var build, generation, options, range, spec, type;
    range = SoundUtil.range, options = SoundUtil.options;
    generation = 0;
    type = 2;
    spec = {
      duration: range(0.05, 0.3),
      oscType: options(['square', 'sawtooth']),
      oscFreq: range(500, 2000),
      gainEnvelope0: range(0.1, 0.9),
      gainEnvelope1: range(0.1, 0.9),
      lfoType: options(['square', 'sawtooth', 'triangle'])
    };
    build = function(context, parameters) {
      var envelope, gain, lfo, lfoEnvelope, osc, start;
      osc = context.createOscillator();
      osc.type = parameters.oscType;
      osc.frequency.value = parameters.oscFreq;
      lfo = context.createOscillator();
      lfo.type = parameters.lfoType;
      lfo.frequency.value = 1;
      lfoEnvelope = SoundUtil.getEnvelope(context, [10, 4], parameters.duration);
      lfo.connect(lfoEnvelope);
      lfoEnvelope.connect(osc.frequency);
      envelope = [parameters.gainEnvelope0, parameters.gainEnvelope1, 0];
      gain = context.createGain();
      SoundUtil.applyRamp(gain.gain, envelope, parameters.duration);
      osc.connect(gain);
      start = function() {
        osc.start();
        return lfo.start();
      };
      return {
        start: start,
        destination: gain
      };
    };
    return {
      generation: generation,
      type: type,
      spec: spec,
      build: build
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/generations/g0/s3',['sound/SoundUtil'], function(SoundUtil) {
    
    var build, generation, options, range, spec, type;
    range = SoundUtil.range, options = SoundUtil.options;
    generation = 0;
    type = 3;
    spec = {
      duration: range(0.2, 0.8),
      oscType: options(['square', 'sawtooth']),
      freqEnvelope0: range(500, 1000),
      freqEnvelope1: range(100, 1000),
      freqEnvelope2: range(100, 1000),
      freqEnvelope3: range(100, 200),
      gainEnvelope0: range(0.0, 0.2),
      gainEnvelope1: range(0.1, 0.7),
      gainEnvelope2: range(0.8, 0.9),
      gainEnvelope3: range(0.0, 0.2)
    };
    build = function(context, parameters) {
      var envelope, gain, osc, start;
      osc = context.createOscillator();
      osc.type = parameters.oscType;
      envelope = [parameters.freqEnvelope0, parameters.freqEnvelope1, parameters.freqEnvelope2, parameters.freqEnvelope3];
      SoundUtil.applyRamp(osc.frequency, envelope, parameters.duration);
      envelope = [parameters.gainEnvelope0, parameters.gainEnvelope1, parameters.gainEnvelope2, parameters.gainEnvelope3];
      gain = context.createGain();
      SoundUtil.applyRamp(gain.gain, envelope, parameters.duration);
      osc.connect(gain);
      start = function() {
        return osc.start();
      };
      return {
        start: start,
        destination: gain
      };
    };
    return {
      generation: generation,
      type: type,
      spec: spec,
      build: build
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/generations/g0/s4',['sound/SoundUtil'], function(SoundUtil) {
    
    var build, generation, options, range, spec, type;
    range = SoundUtil.range, options = SoundUtil.options;
    generation = 0;
    type = 4;
    spec = {
      duration: range(0.2, 0.6),
      gainEnvelope0: range(0.7, 1.0),
      gainEnvelope1: range(0.4, 0.8),
      gainEnvelope2: range(0.1, 0.4),
      gainEnvelope3: range(0.0, 0.2)
    };
    build = function(context, parameters) {
      var b0, b1, b2, b3, b4, b5, b6, bufferSize, gain, i, noiseBuffer, output, start, white, whiteNoise, _i;
      bufferSize = parameters.duration * context.sampleRate;
      noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);
      output = noiseBuffer.getChannelData(0);
      b0 = 0;
      b1 = 0;
      b2 = 0;
      b3 = 0;
      b4 = 0;
      b5 = 0;
      b6 = 0;
      for (i = _i = 0; 0 <= bufferSize ? _i < bufferSize : _i > bufferSize; i = 0 <= bufferSize ? ++_i : --_i) {
        white = Math.random() * 2 - 1;
        b0 = 0.99886 * b0 + white * 0.0555179;
        b1 = 0.99332 * b1 + white * 0.0750759;
        b2 = 0.96900 * b2 + white * 0.1538520;
        b3 = 0.86650 * b3 + white * 0.3104856;
        b4 = 0.55000 * b4 + white * 0.5329522;
        b5 = -0.7616 * b5 - white * 0.0168980;
        output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
        output[i] *= 0.11;
        b6 = white * 0.115926;
      }
      whiteNoise = context.createBufferSource();
      whiteNoise.buffer = noiseBuffer;
      whiteNoise.loop = true;
      gain = context.createGain();
      SoundUtil.applyRamp(gain.gain, [1.0, parameters.gainEnvelope0, parameters.gainEnvelope1, parameters.gainEnvelope2, parameters.gainEnvelope3], parameters.duration);
      whiteNoise.connect(gain);
      start = function() {
        return whiteNoise.start();
      };
      return {
        start: start,
        destination: gain
      };
    };
    return {
      generation: generation,
      type: type,
      spec: spec,
      build: build
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('sound/Sound',['sound/SoundUtil', 'sound/generations/g0/s0', 'sound/generations/g0/s1', 'sound/generations/g0/s2', 'sound/generations/g0/s3', 'sound/generations/g0/s4'], function(SoundUtil) {
    
    var CURRENT_GENERATION, audioContext, generate, getRandomParameters, getRecorder, getSpec, i, key, play, synth, synthForKey, synthKey, synths, _i, _ref;
    audioContext = new AudioContext;
    synthKey = function(generation, type) {
      return "g" + generation + "s" + type;
    };
    synthForKey = function(generation, type) {
      var key;
      key = synthKey(CURRENT_GENERATION, type);
      return synths[key];
    };
    synths = {};
    for (i = _i = 1, _ref = arguments.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
      synth = arguments[i];
      key = synthKey(synth.generation, synth.type);
      synths[key] = synth;
    }
    getSpec = function(generation, type) {
      synth = synthForKey(generation, type);
      return synth.spec;
    };
    CURRENT_GENERATION = 0;
    getRandomParameters = function(type) {
      synth = synthForKey(CURRENT_GENERATION, type);
      return SoundUtil.randomParameters(synth.spec);
    };
    getRecorder = function(duration, callback) {
      var context, sampleRate;
      sampleRate = 44100;
      context = new OfflineAudioContext(1, sampleRate * duration, sampleRate);
      context.oncomplete = function(e) {
        return callback(e.renderedBuffer);
      };
      return context;
    };
    generate = function(generation, type, parameters) {
      synth = synthForKey(generation, type);
      return new Promise(function(resolve, reject) {
        var box, recorder;
        recorder = getRecorder(parameters.duration, function(buffer) {
          return resolve(buffer);
        });
        box = synth.build(recorder, parameters);
        box.destination.connect(recorder.destination);
        box.start(0);
        recorder.startRendering();
      });
    };
    play = function(buffer, onEnded) {
      var bufferSource;
      bufferSource = audioContext.createBufferSource();
      bufferSource.buffer = buffer;
      bufferSource.connect(audioContext.destination);
      bufferSource.start();
      return bufferSource.onended = function() {
        bufferSource.disconnect();
        return typeof onEnded === "function" ? onEnded() : void 0;
      };
    };
    return {
      CURRENT_GENERATION: CURRENT_GENERATION,
      getSpec: getSpec,
      getRandomParameters: getRandomParameters,
      generate: generate,
      play: play
    };
  });

}).call(this);

define('World',[
	'Player',
	'Inventory',
	'Items',
	'Vec2',
    'rule/RuleSet',
	'con2d',
	'Camera',
    'TextBubble',
	'sound/Sound',
    'Util',
    'underscore'
	], function (
		Player,
		Inventory,
		Items,
		Vec2,
		RuleSet,
		con2d,
		Camera,
		TextBubble,
		Sound,
		Util,
		_
	) {
	

	function World(
		playerSpritesByName,
		levelsByName,
		startLocation,
		nearRuleSet,
		leaveRuleSet,
		enterRuleSet,
		useRuleSet,
		tileDimensions,
		cameraDimensions,
		inventorySizeMax,
		playerMaxHealth,
		sounds
		) {
		this.player = new Player(this, playerMaxHealth, playerSpritesByName, tileDimensions);
		this.startLocation = startLocation;
		this.levelsByName = levelsByName;
		this.level = null;
        this.nearRuleSet = nearRuleSet;
		this.leaveRuleSet = leaveRuleSet;
		this.enterRuleSet = enterRuleSet;
		this.useRuleSet = useRuleSet;
		this.tileDimensions = tileDimensions;
		this.sounds = sounds;

		this.camera = new Camera(new Vec2(0, 0), new Vec2(cameraDimensions.x, cameraDimensions.y));

		this.inventory = new Inventory(
			inventorySizeMax,
			tileDimensions,
			new Vec2(0, this.tileDimensions.y * this.camera.dimensions.y + 8)
		);

        this.textBubble = new TextBubble().hide();

        // animation related
		this.tick = 0;
		this.z = 0;
	}

	World.prototype.init = function () {
		con2d.canvas.width = this.tileDimensions.x * this.camera.dimensions.x; //this.levelsByName.entry.width;
		con2d.canvas.height = this.tileDimensions.y * (this.camera.dimensions.y + 1) + 8; //(this.levelsByName.entry.height + 1) + 8;

		this.player.init();
		this.initStartingLocation();

		con2d.fillStyle = '#000';
		con2d.fillRect(0, 0, con2d.canvas.width, con2d.canvas.height);

		this.camera.centerOn(this.player.position.x, this.player.position.y, this.level.width, this.level.height);

        this.initialState = this.serialize();
	};

	World.prototype.setLevel = function (levelName) {
		this.level = this.levelsByName[levelName];
	};

	World.prototype.initStartingLocation = function () {
		this.level = this.levelsByName[this.startLocation.levelName];
		this.player.setPosition(this.startLocation.x, this.startLocation.y);
	};

	World.prototype.playSound = function (id) {
		var sound = this.sounds[id];
		Sound.play(sound);
	};

	World.prototype.draw = function () {
        if (this.player.alive) {
            this.level.draw(this.camera, this.tick);
            this.inventory.draw();
            this.player.draw(this.camera, this.tick);
        } else {
            con2d.fillStyle = '#000';
            con2d.fillRect(0, 0, con2d.canvas.width, con2d.canvas.height);
        }
        this.textBubble.draw();
	};

	World.prototype.update = function () {
		this.z++; // should count deltaTime
		if (this.z >= 20) {
			this.z = 0;
			this.tick = 1 - this.tick;
		}
	};

    World.prototype.serialize = function () {
        var levels = Util.mapOnKeys(this.levelsByName, function (level) {
            return level.serialize();
        });

        var currentLevel = this.level.id;

        return {
            player: this.player.serialize(),
            inventory: this.inventory.serialize(),
            levels: levels,
            currentLevel: currentLevel
        };
    };

    World.prototype.deserialize = function (config) {
        _.each(config.levels, function (levelConfig, key) {
            this.levelsByName[key].deserialize(levelConfig);
        }.bind(this));

        this.setLevel(config.currentLevel);

        this.player.deserialize(config.player);

        this.inventory.deserialize(config.inventory);
    };

	return World;
});

define('Item',[], function() {
	

	function Item(id, name, sprites, blocking) {
		this.id = id;
		this.name = name;
		this.sprites = sprites;
		this.blocking = blocking;
	}

	Item.prototype.drawAt = function(x, y, tick) {
		if (tick !== undefined) {
			tick = Math.min(tick, this.sprites.length - 1);
		} else {
			tick = 0;
		}
		//tick = tick || (this.sprites.length - 1);
		this.sprites[tick].drawAt(x, y);
	};

	return Item;
});

define('rule/NearRule',[], function() {
	

	function NearRule(
		inTerrainItem,
		outTerrainItem,
		healthDelta
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
		this.healthDelta = healthDelta;
	}

	return NearRule;
});

define('rule/LeaveRule',[], function() {
	

	function LeaveRule(
		inTerrainItem,
		outTerrainItem
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
	}

	return LeaveRule;
});

define('rule/EnterRule',[], function() {
	

	function EnterRule(
		inTerrainItem,
		outTerrainItem,
		outInventoryItems,
		healthDelta,
		teleport,
		message,
        checkpoint
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
		this.outInventoryItems = outInventoryItems;
		this.healthDelta = healthDelta;
		this.teleport = teleport;
		this.message = message;
        this.checkpoint = checkpoint;
	}

	return EnterRule;
});

define('rule/UseRule',[], function() {
	

	function UseRule(
		inTerrainItem,
		inInventoryItem,
		outTerrainItem,
		outInventoryItems,
		consume,
		healthDelta,
		teleport,
		message,
		sound
	) {
		this.inTerrainItem = inTerrainItem;
		this.inInventoryItem = inInventoryItem;
		this.outTerrainItem = outTerrainItem;
		this.outInventoryItems = outInventoryItems;
		this.consume = consume;
		this.healthDelta = healthDelta;
		this.teleport = teleport;
		this.message = message;
		this.sound = sound;
	}

	return UseRule;
});

define('Level',[
	'Items',
	'Vec2'
	], function(
		Items,
		Vec2
	) {
	

	function Level(id, data, levelDimensions, tileDimensions, uiOffset) {
        this.id = id;
		this.data = data;
		this.width = levelDimensions.x;
		this.height = levelDimensions.y;
		this.blockWidth = tileDimensions.x;
		this.blockHeight = tileDimensions.y;
		this.uiOffset = uiOffset || new Vec2(0, 0);
	}

	Level.prototype.get = function(x, y) {
		return this.data[y][x];
	};

	Level.prototype.set = function(x, y, item) {
		this.data[y][x] = item;
		return this;
	};

	Level.prototype.draw = function(camera, tick) {
		for (var i = 0; i < camera.dimensions.y; i++) {
			for (var j = 0; j < camera.dimensions.x; j++) {
				this.data[i + camera.position.y][j + camera.position.x].drawAt(
					this.uiOffset.x + j * this.blockWidth,
					this.uiOffset.y + i * this.blockHeight,
					tick
				);
			}
		}
	};

	Level.prototype.withinBounds = function(x, y) {
		return x >= 0 && x < this.width && y >= 0 && y < this.height;
	};

    Level.prototype.serialize = function () {
        return this.data.map(function (line) {
            return line.map(function (element) {
                return element.id;
            });
        });
    };

    Level.prototype.deserialize = function (config) {
        this.data = config.map(function (line) {
            return line.map(function (element) {
                return Items.collection[element];
            });
        });
    };

	return Level;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('generator/Generator',['generator/SpriteSheetGenerator', 'Util', 'World', 'Item', 'Items', 'Set', 'rule/NearRule', 'rule/LeaveRule', 'rule/EnterRule', 'rule/UseRule', 'rule/RuleSet', 'Vec2', 'Level', 'sound/Sound', 'sound/SoundUtil'], function(SpriteSheetGenerator, Util, World, Item, Items, Set, NearRule, LeaveRule, EnterRule, UseRule, RuleSet, Vec2, Level, Sound, SoundUtil) {
    var Generator, generateEnterRules, generateLeaveRules, generateLevels, generateNearRules, generateObjects, generateParams, generatePlayer, generateSets, generateSounds, generateUseRules;
    Generator = {};
    Generator.generate = function(spec) {
      var createWorld, enterRuleSet, leaveRuleSet, levelsByName, nearRuleSet, params, playerSpritesByName, setsByName, tileDimensions, useRuleSet;
      params = generateParams(spec.params, spec.levels);
      playerSpritesByName = generatePlayer(spec.player, spec.colors, params.scale);
      Items.collection = generateObjects(spec.objects, spec.colors, params.scale);
      setsByName = generateSets(spec.sets);
      nearRuleSet = generateNearRules(spec.nearRules, setsByName);
      leaveRuleSet = generateLeaveRules(spec.leaveRules, setsByName);
      enterRuleSet = generateEnterRules(spec.enterRules, setsByName);
      useRuleSet = generateUseRules(spec.useRules, setsByName);
      tileDimensions = playerSpritesByName.left.end.sub(playerSpritesByName.left.start);
      levelsByName = generateLevels(spec.levels, spec.legend, tileDimensions);
      createWorld = function(sounds) {
        return new World(playerSpritesByName, levelsByName, params.startLocation, nearRuleSet, leaveRuleSet, enterRuleSet, useRuleSet, tileDimensions, params.camera, params.inventorySizeMax, params.healthMax, sounds);
      };
      return (spec.sounds ? generateSounds(spec.sounds) : Promise.resolve({})).then(createWorld);
    };
    generateParams = function(params, levelsSpec) {
      var paramSpec;
      paramSpec = Util.arrayToObject(params, 'name', 'parts');
      return {
        camera: {
          x: +paramSpec.camera[0] || 7,
          y: +paramSpec.camera[1] || 7
        },
        scale: +paramSpec.scale[0] || 8,
        startLocation: {
          x: +paramSpec.start_location[0] || 2,
          y: +paramSpec.start_location[1] || 2,
          levelName: paramSpec.start_location[2] || levelsSpec[0].name
        },
        inventorySizeMax: +paramSpec.inventory_size_max[0] || 5,
        healthMax: +paramSpec.health_max[0]
      };
    };
    Generator.generateParams = generateParams;
    generatePlayer = function(playerSpec, colorSpec, scale) {
      var namedPlayerSprites;
      namedPlayerSprites = SpriteSheetGenerator.generate(playerSpec, colorSpec, scale);
      return Util.arrayToObject(namedPlayerSprites, 'name', 'sprite');
    };
    Generator.generatePlayer = generatePlayer;
    generateObjects = function(objectsSpec, colorSpec, scale) {
      var blockingObjects, groupedSprites, itemsByName, namedSpriteGroups, namedSprites, processSpriteName;
      processSpriteName = function(nam) {
        var separator;
        separator = nam.lastIndexOf(':');
        if (separator === -1) {
          return {
            name: nam,
            frame: 0
          };
        } else {
          return {
            name: nam.substr(0, separator),
            frame: +nam.substr(separator + 1)
          };
        }
      };
      namedSprites = SpriteSheetGenerator.generate(objectsSpec, colorSpec, scale);
      blockingObjects = {};
      objectsSpec.forEach(function(objectSpec) {
        if (objectSpec.blocking) {
          blockingObjects[objectSpec.name] = true;
        }
      });
      groupedSprites = Util.groupBy(namedSprites, function(namedSprite) {
        var frameAndName;
        frameAndName = processSpriteName(namedSprite.name);
        return frameAndName.name;
      });
      namedSpriteGroups = Util.objectToArray(groupedSprites, 'groupName', 'namedSprites');
      itemsByName = {};
      namedSpriteGroups.forEach(function(namedSpriteGroup) {
        var sortedSprites, sprites;
        sortedSprites = namedSpriteGroup.namedSprites.map(function(namedSprite) {
          var nameAndFrame;
          nameAndFrame = processSpriteName(namedSprite.name);
          return {
            sprite: namedSprite.sprite,
            name: nameAndFrame.name,
            frame: nameAndFrame.frame
          };
        }).sort(function(a, b) {
          return a.frame - b.frame;
        });
        sprites = sortedSprites.map(function(namedSprite) {
          return namedSprite.sprite;
        });
        itemsByName[namedSpriteGroup.groupName] = new Item(namedSpriteGroup.groupName, Util.capitalize(namedSpriteGroup.groupName), sprites, !!blockingObjects[namedSpriteGroup.groupName]);
      });
      return itemsByName;
    };
    Generator.generateObjects = generateObjects;
    generateSets = function(spec) {
      var operators, setsByName;
      operators = {
        or: Set.prototype.union,
        and: Set.prototype.intersection,
        minus: Set.prototype.difference
      };
      setsByName = {};
      spec.forEach(function(setDefinition) {
        var operand1, operand2, operator, set;
        set = void 0;
        if (setDefinition.elements) {
          set = new Set();
          setDefinition.elements.forEach(function(element) {
            set.add(element);
          });
        } else {
          operand1 = setsByName[setDefinition.operand1];
          operand2 = setsByName[setDefinition.operand2];
          operator = operators[setDefinition.operator];
          set = operator.call(operand1, operand2);
        }
        setsByName[setDefinition.name] = set;
      });
      return setsByName;
    };
    Generator.generateSets = generateSets;
    generateNearRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var healthDelta, inTerrainItemName, outTerrainItemName;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        healthDelta = 0;
        if (ruleSpec.heal) {
          healthDelta += +ruleSpec.heal;
        }
        if (ruleSpec.hurt) {
          healthDelta -= +ruleSpec.hurt;
        }
        return new NearRule(inTerrainItemName, outTerrainItemName, healthDelta);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateNearRules = generateNearRules;
    generateLeaveRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var inTerrainItemName, outTerrainItemName;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        return new LeaveRule(inTerrainItemName, outTerrainItemName);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateLeaveRules = generateLeaveRules;
    generateEnterRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var healthDelta, inTerrainItemName, message, outInventoryItems, outTerrainItemName, teleport;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        outInventoryItems = void 0;
        if (ruleSpec.give) {
          outInventoryItems = ruleSpec.give.map(function(entry) {
            return {
              itemName: entry.itemName,
              quantity: +entry.quantity
            };
          });
        } else {
          outInventoryItems = [];
        }
        healthDelta = 0;
        if (ruleSpec.heal) {
          healthDelta += +ruleSpec.heal;
        }
        if (ruleSpec.hurt) {
          healthDelta -= +ruleSpec.hurt;
        }
        teleport = void 0;
        if (ruleSpec.teleport) {
          teleport = {
            x: +ruleSpec.teleport.x,
            y: +ruleSpec.teleport.y,
            levelName: ruleSpec.teleport.levelName
          };
        }
        message = void 0;
        if (ruleSpec.message) {
          message = ruleSpec.message;
        }
        return new EnterRule(inTerrainItemName, outTerrainItemName, outInventoryItems, healthDelta, teleport, message, ruleSpec.checkpoint);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateEnterRules = generateEnterRules;
    generateUseRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var consume, healthDelta, inInventoryItemName, inTerrainItemName, message, outInventoryItems, outTerrainItemName, sound, teleport;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        inInventoryItemName = ruleSpec.inInventoryItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        outInventoryItems = void 0;
        if (ruleSpec.give) {
          outInventoryItems = ruleSpec.give.map(function(entry) {
            return {
              itemName: entry.itemName,
              quantity: +entry.quantity
            };
          });
        } else {
          outInventoryItems = [];
        }
        consume = !!ruleSpec.consume;
        healthDelta = 0;
        if (ruleSpec.heal) {
          healthDelta += +ruleSpec.heal;
        }
        if (ruleSpec.hurt) {
          healthDelta -= +ruleSpec.hurt;
        }
        teleport = void 0;
        if (ruleSpec.teleport) {
          teleport = {
            x: +ruleSpec.teleport.x,
            y: +ruleSpec.teleport.y,
            levelName: ruleSpec.teleport.levelName
          };
        }
        message = void 0;
        if (ruleSpec.message) {
          message = ruleSpec.message;
        }
        sound = ruleSpec.sound;
        return new UseRule(inTerrainItemName, inInventoryItemName, outTerrainItemName, outInventoryItems, consume, healthDelta, teleport, message, sound);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateUseRules = generateUseRules;
    generateLevels = function(namedStringedLevels, legendSpec, tileDimensions) {
      var legend, levelsByName;
      levelsByName = {};
      legend = Util.arrayToObject(legendSpec, 'name', 'objectName');
      namedStringedLevels.forEach(function(namedStringedLevel) {
        var data, levelDimensions;
        data = namedStringedLevel.data.map(function(line) {
          return line.split('').map(function(char) {
            var itemName;
            itemName = legend[char];
            return Items.collection[itemName];
          });
        });
        levelDimensions = new Vec2(data[0].length, data.length);
        levelsByName[namedStringedLevel.name] = new Level(namedStringedLevel.name, data, levelDimensions, tileDimensions);
      });
      return levelsByName;
    };
    Generator.generateLevels = generateLevels;
    generateSounds = function(sounds) {
      var promises, soundsById;
      soundsById = {};
      promises = sounds.map(function(entry) {
        var generation, parameters, spec, type, _ref;
        _ref = entry.soundString, generation = _ref[0], type = _ref[1];
        spec = Sound.getSpec(generation, type);
        parameters = SoundUtil.decode(entry.soundString, spec);
        return Sound.generate(generation, type, parameters).then(function(buffer) {
          return soundsById[entry.id] = buffer;
        });
      });
      return Promise.all(promises).then(function() {
        return soundsById;
      });
    };
    return Generator;
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('Game',['SystemBus', 'World', 'generator/Generator'], function(SystemBus, World, Generator) {
    
    var Game;
    Game = function() {
      this.world = null;
      return this.requestId = null;
    };
    Game.prototype.init = function(tree) {
      return Generator.generate(tree).then((function(_this) {
        return function(world) {
          _this.world = world;
          return _this.world.init();
        };
      })(this));
    };
    Game.prototype.start = function() {
      var frame;
      frame = (function(_this) {
        return function() {
          _this.world.update();
          _this.world.draw();
          return _this.requestId = window.requestAnimationFrame(frame);
        };
      })(this);
      return frame();
    };
    Game.prototype.cleanup = function() {
      window.cancelAnimationFrame(this.requestId);
      return SystemBus.reset();
    };
    return Game;
  });

}).call(this);

define('tokenizer/TokenCoords',[], function () {
	

	function TokenCoords(line, col) {
		this.line = line;
		this.col = col;
	}

	TokenCoords.prototype.toString = function () {
		return '(line: ' + this.line + ', col: ' + this.col + ')';
	};

	return TokenCoords;
});

define('tokenizer/IterableString',[
	'tokenizer/TokenCoords'
	], function (
		TokenCoords
	) {
	

	function IterableString(str) {
		this.str = str;
		this.pointer = 0;
		this.marker = 0;

		this.line = 1;
		this.col = 1;
	}

	IterableString.prototype.advance = function () {
		if (this.str.charAt(this.pointer) === '\n') {
			this.line++;
			this.col = 1;
		} else {
			this.col++;
		}

		this.pointer++;
	};

	IterableString.prototype.setMarker = function (offset) {
		offset = offset || 0;
		this.marker = this.pointer + offset;
	};

	IterableString.prototype.current = function () {
		return this.str.charAt(this.pointer);
	};

	IterableString.prototype.next = function () {
		return this.str.charAt(this.pointer + 1);
	};

	IterableString.prototype.hasNext = function () {
		return this.pointer < this.str.length;
	};

	IterableString.prototype.getMarked = function (offset) {
		offset = offset || 0;
		return this.str.substring(this.marker, this.pointer + offset);
	};

	IterableString.prototype.getCoords = function () {
		return new TokenCoords(this.line, this.col);
	};

	return IterableString;
});

define('tokenizer/Token',[], function () {
	function Token() {

	}

	return Token;
});
define('tokenizer/TokEnd',['tokenizer/Token'], function (Token) {
	

	function TokEnd(coords) {
		this.coords = coords;
	}

	TokEnd.prototype.match = function (that) {
		return that instanceof TokEnd;
	};

	TokEnd.prototype.toString = function () {
		return 'END';
	};

	TokEnd.prototype.toHTML = function (c) {
		return '';
	};

	return TokEnd;
});

define('tokenizer/TokIdentifier',['tokenizer/Token'], function (Token) {
	

	function TokIdentifier(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokIdentifier.prototype = Object.create(Token.prototype);
	TokIdentifier.prototype.constructor = TokIdentifier;

	TokIdentifier.prototype.match = function (that) {
		return that instanceof TokIdentifier;
	};

	TokIdentifier.prototype.toString = function () {
		return 'Identifier(' + this.value + ' ' + this.coords + ')';
	};

	TokIdentifier.prototype.toHTML = function (c) {
		return '<span style="color:' + c.identifier + '">' + this.s + '</span>';
	};

	return TokIdentifier;
});

define('tokenizer/TokStr',['tokenizer/Token'], function (Token) {
	

	function TokStr(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokStr.prototype = Object.create(Token.prototype);
	TokStr.prototype.constructor = TokStr;

	TokStr.prototype.match = function (that) {
		return that instanceof TokStr;
	};

	TokStr.prototype.toString = function () {
		return 'Str(' + this.value + ')';
	};

	TokStr.prototype.toHTML = function (c) {
		return '<span style="color:' + c.str + '">\'' + this.value + '\'</span>';
	};

	return TokStr;
});

define('tokenizer/TokKeyword',['tokenizer/Token'], function (Token) {
	

	function TokKeyword(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokKeyword.prototype = Object.create(Token.prototype);
	TokKeyword.prototype.constructor = TokKeyword;

	TokKeyword.prototype.match = function (that) {
		return that === this.value;
	};

	TokKeyword.prototype.toString = function () {
		return 'Keyword(' + this.value + ' ' + this.coords + ')';
	};

	TokKeyword.prototype.toHTML = function (c) {
		return '<span style="font-weight: 900;color:' + c.keyword + '">' + this.value + '</span>';
	};

	return TokKeyword;
});

define('tokenizer/TokCommSL',['tokenizer/Token'], function (Token) {
	

	function TokCommSL(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokCommSL.prototype.toString = function() {
		return 'CommSL(' + this.value + ')';
	};

	TokCommSL.prototype.toHTML = function(c) {
		return '<span style="color:' + c.commSL + '">' + this.value + '</span><br />';
	};

	return TokCommSL;
});

define('tokenizer/TokCommML',['tokenizer/Token'], function (Token) {
	

	function TokCommML(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokCommML.prototype.toString = function () {
		return 'CommML(' + this.value + ')';
	};

	TokCommML.prototype.toHTML = function(c) {
		return '<span style="color:' + c.commML + '">' + this.value + '</span>';
	};

	return TokCommML;
});

define('tokenizer/TokComma',['tokenizer/Token'], function (Token) {
	

	function TokComma(coords) {
		this.coords = coords;
	}

	TokComma.prototype.match = function (that) {
		return that instanceof TokComma;
	};

	TokComma.prototype.toString = function () {
		return 'Comma';
	};

	TokComma.prototype.toHTML = function (c) {
		return '<span style="color:' + c.comma + '">)</span>';
	};

	return TokComma;
});

define('tokenizer/TokSemicolon',['tokenizer/Token'], function (Token) {
	

	function TokSemicolon(coords) {
		this.coords = coords;
	}

	TokSemicolon.prototype.match = function (that) {
		return that instanceof TokSemicolon;
	};

	TokSemicolon.prototype.toString = function () {
		return 'Semicolon';
	};

	TokSemicolon.prototype.toHTML = function (c) {
		return '<span style="color:' + c.semicolon + '">)</span>';
	};

	return TokSemicolon;
});

define('tokenizer/TokArrow',['tokenizer/Token'], function (Token) {
	

	function TokArrow(coords) {
		this.coords = coords;
	}

	TokArrow.prototype = Object.create(Token.prototype);
	TokArrow.prototype.constructor = TokArrow;

	TokArrow.prototype.match = function (that) {
		return that instanceof TokArrow;
	};

	TokArrow.prototype.toString = function () {
		return 'Arrow';
	};

	TokArrow.prototype.toHTML = function (c) {
		return '<span style="color:' + c.arrow + '">)</span>';
	};

	return TokArrow;
});

define('tokenizer/TokAssignment',['tokenizer/Token'], function (Token) {
	

	function TokAssignment(coords) {
		this.coords = coords;
	}

	TokAssignment.prototype.match = function (that) {
		return that instanceof TokAssignment;
	};

	TokAssignment.prototype.toString = function () {
		return 'Assignment';
	};

	TokAssignment.prototype.toHTML = function (c) {
		return '<span style="color:' + c.assignment + '">)</span>';
	};

	return TokAssignment;
});

define('tokenizer/TokNewLine',['tokenizer/Token'], function (Token) {
	

	function TokNewLine(coords) {
		this.coords = coords;
	}

	TokNewLine.prototype.match = function (that) {
		return that instanceof TokNewLine;
	};

	TokNewLine.prototype.toString = function () {
		return 'TokNewLine';
	};

	TokNewLine.prototype.toHTML = function (c) {
		return '<span style="color:' + c.par + '">)</span>';
	};

	return TokNewLine;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('tokenizer/Tokenizer',['tokenizer/IterableString', 'tokenizer/TokEnd', 'tokenizer/TokIdentifier', 'tokenizer/TokStr', 'tokenizer/TokKeyword', 'tokenizer/TokCommSL', 'tokenizer/TokCommML', 'tokenizer/TokComma', 'tokenizer/TokSemicolon', 'tokenizer/TokArrow', 'tokenizer/TokAssignment', 'tokenizer/TokNewLine'], function(IterableString, TokEnd, TokIdentifier, TokStr, TokKeyword, TokCommSL, TokCommML, TokComma, TokSemicolon, TokArrow, TokAssignment, TokNewLine) {
    
    var Tokenizer, alphanum, commentMulti, commentSingle, escape, keywords, stringDouble, stringSingle, whitespace;
    Tokenizer = {};
    Tokenizer.chop = function(s) {
      var c, n, str, tok;
      str = new IterableString(s);
      tok = [];
      while (str.hasNext()) {
        c = str.current();
        if (c === "'") {
          tok.push(stringSingle(str));
        } else if (c === '"') {
          tok.push(stringDouble(str));
        } else if (c === '/') {
          n = str.next();
          if (n === '/') {
            commentSingle(str);
          } else if (n === '*') {
            commentMulti(str);
          } else {
            tok.push(alphanum(str));
          }
        } else if (c === '=') {
          tok.push(new TokAssignment(str.getCoords()));
          str.advance();
        } else if (c === ',') {
          tok.push(new TokComma(str.getCoords()));
          str.advance();
        } else if (c === ';') {
          tok.push(new TokSemicolon(str.getCoords()));
          str.advance();
        } else if (c === '-' && str.next() === '>') {
          tok.push(new TokArrow(str.getCoords()));
          str.advance();
          str.advance();
        } else if (c > ' ' && c <= '~') {
          tok.push(alphanum(str));
        } else if (c === '\n') {
          tok.push(new TokNewLine(str.getCoords()));
          str.advance();
        } else {
          whitespace(str);
        }
      }
      tok.push(new TokEnd(str.getCoords()));
      return tok;
    };
    stringSingle = function(str) {
      var accumulated, coords, ex;
      coords = str.getCoords();
      accumulated = [];
      str.advance();
      while (true) {
        if (str.current() === '\\') {
          str.advance();
          if (escape[str.current()]) {
            accumulated.push(escape[str.current()]);
          }
        } else if (str.current() === "'") {
          str.advance();
          return new TokStr(accumulated.join(''), coords);
        } else if (str.current() === '\n' || !str.hasNext()) {
          ex = new Error('String not properly ended');
          ex.coords = str.getCoords();
          throw ex;
        } else {
          accumulated.push(str.current());
        }
        str.advance();
      }
    };
    stringDouble = function(str) {
      var accumulated, coords, ex;
      coords = str.getCoords();
      accumulated = [];
      str.advance();
      while (true) {
        if (str.current() === '\\') {
          str.advance();
          if (escape[str.current()]) {
            accumulated.push(escape[str.current()]);
          }
        } else if (str.current() === '"') {
          str.advance();
          return new TokStr(accumulated.join(''), coords);
        } else if (str.current() === '\n' || !str.hasNext()) {
          ex = new Error('String not properly ended');
          ex.coords = str.getCoords();
          throw ex;
        } else {
          accumulated.push(str.current());
        }
        str.advance();
      }
    };
    commentSingle = function(str) {
      str.setMarker();
      str.advance();
      str.advance();
      while (true) {
        if (str.current() === '\n' || !str.hasNext()) {
          return;
        } else {
          str.advance();
        }
      }
    };
    commentMulti = function(str) {
      str.setMarker();
      str.advance();
      str.advance();
      while (true) {
        if (str.current() === '*' && str.next() === '/') {
          str.advance();
          str.advance();
          return;
        } else if (str.hasNext()) {
          str.advance();
        } else {
          throw 'Multiline comment not properly terminated ' + str.getCoords();
        }
      }
    };
    alphanum = function(str) {
      var coords, tmp;
      coords = str.getCoords();
      str.setMarker();
      tmp = str.current();
      while (tmp > ' ' && tmp <= '~' && (tmp !== '(' && tmp !== ')')) {
        str.advance();
        tmp = str.current();
      }
      tmp = str.getMarked();
      if (keywords.indexOf(tmp) !== -1) {
        return new TokKeyword(tmp, coords);
      } else {
        return new TokIdentifier(tmp, coords);
      }
    };
    whitespace = function(str) {
      str.advance();
    };
    escape = {
      '\\': '\\',
      n: '\n',
      t: '\t',
      '\'': '\'',
      '\"': '\"'
    };
    keywords = ['PARAM', 'COLORS', 'PLAYER', 'OBJECTS', 'SETS', 'SOUNDS', 'NEARRULES', 'LEAVERULES', 'ENTERRULES', 'USERULES', 'LEGEND', 'LEVELS', 'rgb', 'rgba', 'blocking', 'or', 'and', 'minus', 'consume', 'give', 'heal', 'hurt', 'teleport', 'message', 'checkpoint', 'sound'];
    return Tokenizer;
  });

}).call(this);

define('ParserError',[], function() {
	

	function ParserError(message, line, column) {
	  this.name = 'ParserError';
	  this.message = message || 'Default Message';
	  this.line = line;
	  this.column = column;
	}

	ParserError.prototype = Object.create(Error.prototype);
	ParserError.prototype.constructor = ParserError;

	return ParserError;
});
define('parser/TokenList',['ParserError'], function(ParserError) {
	

	function TokenList(token) {
		this.token = token;
		this.pointer = 0;
	}

	TokenList.prototype.match = function(token) {
		return this.token[this.pointer].match(token);
	};

	TokenList.prototype.matchSeq = function(token) {
		for(var i = 0; i < token.length; i++)
			if(!(this.token[this.pointer + i].match(token[i])))
				return false;

		return true;
	};

	TokenList.prototype.matchAnySeq = function(token) {
		for(var i = 0; i < token.length; i++)
			if(this.matchSeq(token[i]))
				return true;

		return false;
	};

	TokenList.prototype.expect = function(token, exMessage) {
		if(this.match(token)) {
			this.adv();
		} else {
			throw new ParserError(
				exMessage /*+ ' instead got ' + this.cur()*/,
				this.cur().coords.line,
				this.cur().coords.col
			);
		}
	};

	TokenList.prototype.adv = function() {
		if(this.pointer >= this.token.length)
			throw 'TokenList: You\'ve not enough tokens!';

		this.pointer++;
	};

	TokenList.prototype.next = function() {
		this.adv();
		return this.token[this.pointer - 1];
	};

	TokenList.prototype.cur = function() {
		return this.token[this.pointer];
	};

	TokenList.prototype.past = function() {
		return this.token[this.pointer - 1];
	};

	TokenList.prototype.toString = function() {
		var ret = 'TokenList(pointer: ' + this.pointer
						+ ', content: [' + this.token.join(', ') + ']';
		return ret;
	};

	return TokenList;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('parser/Parser',['tokenizer/TokEnd', 'tokenizer/TokIdentifier', 'tokenizer/TokStr', 'tokenizer/TokKeyword', 'tokenizer/TokCommSL', 'tokenizer/TokCommML', 'tokenizer/TokComma', 'tokenizer/TokSemicolon', 'tokenizer/TokArrow', 'tokenizer/TokNewLine', 'tokenizer/TokAssignment', 'tokenizer/TokenCoords', 'parser/TokenList'], function(TokEnd, TokIdentifier, TokStr, TokKeyword, TokCommSL, TokCommML, TokComma, TokSemicolon, TokArrow, TokNewLine, TokAssignment, TokenCoords, TokenList) {
    
    var ARROW, ASSIGNMENT, COMMA, END, IDENTIFIER, NEWLINE, Parser, SEMICOLON, STR, chompNL, parse, parseColors, parseEnterRules, parseLeaveRules, parseLegend, parseLevels, parseNearRules, parseObjects, parseParams, parsePlayer, parseSets, parseSounds, parseUseRules;
    IDENTIFIER = new TokIdentifier();
    STR = new TokStr();
    COMMA = new TokComma();
    SEMICOLON = new TokSemicolon();
    ARROW = new TokArrow();
    NEWLINE = new TokNewLine();
    ASSIGNMENT = new TokAssignment();
    END = new TokEnd();
    Parser = {};
    parse = function(tokenArray) {
      var colors, enterRules, leaveRules, legend, levels, nearRules, objects, params, player, sets, sounds, tokens, useRules;
      tokens = new TokenList(tokenArray);
      params = parseParams(tokens);
      colors = parseColors(tokens);
      player = parsePlayer(tokens);
      objects = parseObjects(tokens);
      sets = parseSets(tokens);
      if (tokens.match('SOUNDS')) {
        sounds = parseSounds(tokens);
      }
      if (tokens.match('NEARRULES')) {
        nearRules = parseNearRules(tokens);
      }
      if (tokens.match('LEAVERULES')) {
        leaveRules = parseLeaveRules(tokens);
      }
      if (tokens.match('ENTERRULES')) {
        enterRules = parseEnterRules(tokens);
      }
      useRules = parseUseRules(tokens);
      legend = parseLegend(tokens);
      levels = parseLevels(tokens);
      return {
        params: params,
        colors: colors,
        player: player,
        objects: objects,
        sets: sets,
        sounds: sounds || [],
        nearRules: nearRules || [],
        leaveRules: leaveRules || [],
        enterRules: enterRules || [],
        useRules: useRules,
        legend: legend,
        levels: levels
      };
    };
    Parser.parse = parse;
    chompNL = function(tokens, exMessage) {
      tokens.expect(NEWLINE, exMessage);
      while (tokens.match(NEWLINE)) {
        tokens.adv();
      }
    };
    parseParams = function(tokens) {
      var paramName, params, parts;
      tokens.expect('PARAM', 'Specification must start with PARAM');
      chompNL(tokens, 'Expected new line after PARAM');
      params = [];
      while (!tokens.match('COLORS')) {
        tokens.expect(IDENTIFIER, '');
        paramName = tokens.past();
        parts = [];
        params.push({
          name: paramName,
          parts: parts
        });
        while (tokens.match(IDENTIFIER)) {
          tokens.adv();
          parts.push(tokens.past());
        }
        chompNL(tokens, 'Expect new line between param declarations');
      }
      return params;
    };
    Parser.parseParams = parseParams;
    parseColors = function(tokens) {
      var alpha, blue, colors, green, name, red, rgba;
      tokens.expect('COLORS', 'Expected COLORS section after PARAM');
      chompNL(tokens, 'Expected new line after COLORS');
      colors = [];
      while (!tokens.match('PLAYER')) {
        tokens.expect(IDENTIFIER, '');
        name = tokens.past();
        rgba = false;
        if (tokens.match('rgb')) {
          rgba = false;
        } else if (tokens.match('rgba')) {
          rgba = true;
        } else {
          throw 'Expected either rgb or rgba';
        }
        tokens.adv();
        tokens.expect(IDENTIFIER, 'Expected red value');
        red = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected green value');
        green = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected blue value');
        blue = tokens.past();
        if (rgba) {
          tokens.expect(IDENTIFIER, 'Expected alpha value');
          alpha = tokens.past();
          colors.push({
            name: name,
            red: red,
            green: green,
            blue: blue,
            alpha: alpha
          });
        } else {
          colors.push({
            name: name,
            red: red,
            green: green,
            blue: blue
          });
        }
        chompNL(tokens, 'Expect new line between color bindings');
      }
      return colors;
    };
    Parser.parseColors = parseColors;
    parsePlayer = function(tokens) {
      var data, playerFrameName, playerFrames;
      tokens.expect('PLAYER', 'Expected PLAYER section after COLORS');
      chompNL(tokens, 'Expected new line after PLAYER');
      playerFrames = [];
      while (!tokens.match('OBJECTS')) {
        tokens.expect(IDENTIFIER, 'Expected at least one player frame');
        playerFrameName = tokens.past();
        data = [];
        chompNL(tokens, 'Expected new line after player frame binding');
        while (!tokens.match(NEWLINE)) {
          tokens.expect(IDENTIFIER, 'Expected sprite data line');
          data.push(tokens.past());
          tokens.expect(NEWLINE, 'Expected new line after sprite data line');
        }
        playerFrames.push({
          name: playerFrameName,
          data: data
        });
        chompNL(tokens, 'Expected new line after player frame declaration');
      }
      return playerFrames;
    };
    Parser.parsePlayer = parsePlayer;
    parseObjects = function(tokens) {
      var object, objectName, objects;
      tokens.expect('OBJECTS', 'Expected OBJECTS section after PLAYER');
      chompNL(tokens, 'Expected new line after OBJECTS');
      objects = [];
      while (!tokens.match('SETS')) {
        tokens.expect(IDENTIFIER, 'Expected at least one object');
        objectName = tokens.past();
        object = {
          name: objectName,
          data: []
        };
        if (tokens.match('blocking')) {
          object.blocking = true;
          tokens.adv();
        }
        chompNL(tokens, 'Expected new line after object name binding');
        while (!tokens.match(NEWLINE)) {
          tokens.expect(IDENTIFIER, 'Expected sprite data line');
          object.data.push(tokens.past());
          tokens.expect(NEWLINE, 'Expected new line after sprite data line');
        }
        objects.push(object);
        chompNL(tokens, 'Expected new line after object declaration');
      }
      return objects;
    };
    Parser.parseObjects = parseObjects;
    parseSets = function(tokens) {
      var elements, firstOperandOrElement, operator, secondOperand, set, setName, sets;
      tokens.expect('SETS', 'Expected SETS after OBJECTS');
      chompNL(tokens, 'Expected new line after SETS');
      sets = [];
      while (!(tokens.match('SOUNDS') || tokens.match('NEARRULES') || tokens.match('LEAVERULES') || tokens.match('ENTERRULES') || tokens.match('USERULES'))) {
        tokens.expect(IDENTIFIER, '');
        setName = tokens.past();
        set = {
          name: setName
        };
        tokens.expect(ASSIGNMENT, 'Expecting assignment operator');
        tokens.expect(IDENTIFIER, 'Expecting identifier after assignment');
        firstOperandOrElement = tokens.past();
        if (tokens.match('or') || tokens.match('and') || tokens.match('minus')) {
          operator = tokens.next();
          tokens.expect(IDENTIFIER);
          secondOperand = tokens.past();
          set.operator = operator;
          set.operand1 = firstOperandOrElement;
          set.operand2 = secondOperand;
        } else {
          elements = [firstOperandOrElement];
          while (tokens.match(IDENTIFIER)) {
            elements.push(tokens.next());
          }
          set.elements = elements;
        }
        sets.push(set);
        chompNL(tokens, 'Expected new line after set declaration');
      }
      return sets;
    };
    Parser.parseSets = parseSets;
    parseSounds = function(tokens) {
      var id, soundString, sounds;
      tokens.expect('SOUNDS', 'Expected SOUNDS section after SETS');
      chompNL(tokens, 'Expected new line after SOUNDS');
      sounds = [];
      while (!(tokens.match('NEARRULES') || tokens.match('LEAVERULES') || tokens.match('ENTERRULES') || tokens.match('USERULES'))) {
        tokens.expect(IDENTIFIER, '');
        soundString = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected sound binding');
        id = tokens.past();
        sounds.push({
          soundString: soundString,
          id: id
        });
        chompNL(tokens, 'Expected new line between sound bindings');
      }
      return sounds;
    };
    Parser.parseSounds = parseSounds;
    parseNearRules = function(tokens) {
      var rule, rules;
      tokens.expect('NEARRULES', 'Expected NEARRULES section after SOUNDS');
      chompNL(tokens, 'Expected new line after NEARRULES');
      rules = [];
      while (!(tokens.match('LEAVERULES') || tokens.match('ENTERRULES') || tokens.match('USERULES'))) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        while (tokens.match(SEMICOLON)) {
          tokens.adv();
          if (tokens.match('heal')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected heal quantity');
            rule.heal = tokens.past();
          } else if (tokens.match('hurt')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected hurt quantity');
            rule.hurt = tokens.past();
          }
        }
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseNearRules = parseNearRules;
    parseLeaveRules = function(tokens) {
      var rule, rules;
      tokens.expect('LEAVERULES', 'Expected LEAVERULES section after SETS');
      chompNL(tokens, 'Expected new line after LEAVERULES');
      rules = [];
      while (!tokens.match('ENTERRULES') && !tokens.match('USERULES')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseLeaveRules = parseLeaveRules;
    parseEnterRules = function(tokens) {
      var item, rule, rules;
      tokens.expect('ENTERRULES', 'Expected ENTERRULES section after LEAVERULES');
      chompNL(tokens, 'Expected new line after ENTERRULES');
      rules = [];
      while (!tokens.match('USERULES')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        while (tokens.match(SEMICOLON)) {
          tokens.adv();
          if (tokens.match('give')) {
            tokens.adv();
            item = {};
            tokens.expect(IDENTIFIER, 'Expected give quantity');
            item.quantity = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected give item name');
            item.itemName = tokens.past();
            rule.give = [item];
            while (tokens.match(COMMA)) {
              tokens.adv();
              item = {};
              tokens.expect(IDENTIFIER, 'Expected give quantity');
              item.quantity = tokens.past();
              tokens.expect(IDENTIFIER, 'Expected give item name');
              item.itemName = tokens.past();
              rule.give.push(item);
            }
          } else if (tokens.match('heal')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected heal quantity');
            rule.heal = tokens.past();
          } else if (tokens.match('hurt')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected hurt quantity');
            rule.hurt = tokens.past();
          } else if (tokens.match('teleport')) {
            tokens.adv();
            rule.teleport = {};
            tokens.expect(IDENTIFIER, 'Expected teleport level name');
            rule.teleport.levelName = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position X');
            rule.teleport.x = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position Y');
            rule.teleport.y = tokens.past();
          } else if (tokens.match('message')) {
            tokens.adv();
            tokens.expect(STR, 'Expected message');
            rule.message = tokens.past();
          } else if (tokens.match('checkpoint')) {
            tokens.adv();
            rule.checkpoint = true;
          }
        }
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseEnterRules = parseEnterRules;
    parseUseRules = function(tokens) {
      var item, rule, rules;
      tokens.expect('USERULES', 'Expected USERULES section after SETS');
      chompNL(tokens, 'Expected new line after USERULES');
      rules = [];
      while (!tokens.match('LEGEND')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected inventory unit');
        rule.inInventoryItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        while (tokens.match(SEMICOLON)) {
          tokens.adv();
          if (tokens.match('give')) {
            tokens.adv();
            item = {};
            tokens.expect(IDENTIFIER, 'Expected give quantity');
            item.quantity = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected give item name');
            item.itemName = tokens.past();
            rule.give = [item];
            while (tokens.match(COMMA)) {
              tokens.adv();
              item = {};
              tokens.expect(IDENTIFIER, 'Expected give quantity');
              item.quantity = tokens.past();
              tokens.expect(IDENTIFIER, 'Expected give item name');
              item.itemName = tokens.past();
              rule.give.push(item);
            }
          } else if (tokens.match('consume')) {
            tokens.adv();
            rule.consume = true;
          } else if (tokens.match('heal')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected heal quantity');
            rule.heal = tokens.past();
          } else if (tokens.match('hurt')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected hurt quantity');
            rule.hurt = tokens.past();
          } else if (tokens.match('teleport')) {
            tokens.adv();
            rule.teleport = {};
            tokens.expect(IDENTIFIER, 'Expected teleport level name');
            rule.teleport.levelName = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position X');
            rule.teleport.x = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position Y');
            rule.teleport.y = tokens.past();
          } else if (tokens.match('message')) {
            tokens.adv();
            tokens.expect(STR, 'Expected message');
            rule.message = tokens.past();
          } else if (tokens.match('sound')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected sound identifier');
            rule.sound = tokens.past();
          }
        }
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseUseRules = parseUseRules;
    parseLegend = function(tokens) {
      var legend, objectName, terrainChar;
      tokens.expect('LEGEND', 'Expected LEGEND section after RULES');
      chompNL(tokens, 'Expected new line after LEGEND');
      legend = [];
      while (!tokens.match('LEVELS')) {
        tokens.expect(IDENTIFIER, '');
        terrainChar = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected terrain binding');
        objectName = tokens.past();
        legend.push({
          name: terrainChar,
          objectName: objectName
        });
        chompNL(tokens, 'Expected new line between terrain bindings');
      }
      return legend;
    };
    Parser.parseLegend = parseLegend;
    parseLevels = function(tokens) {
      var levelName, levels, lines;
      tokens.expect('LEVELS', 'Expected LEVELS section after LEGEND');
      chompNL(tokens, 'Expected new line after LEVELS');
      levels = [];
      while (!tokens.match(END)) {
        tokens.expect(IDENTIFIER, 'Expected at least one level');
        levelName = tokens.past();
        lines = [];
        chompNL(tokens, 'Expected new line after level name binding');
        while (!(tokens.match(NEWLINE) || tokens.match(END))) {
          tokens.expect(IDENTIFIER, 'Expected level data line');
          lines.push(tokens.past());
          if (!tokens.match(END)) {
            tokens.expect(NEWLINE, 'Expected new line after level data line');
          }
        }
        levels.push({
          name: levelName,
          data: lines
        });
        if (!tokens.match(END)) {
          chompNL(tokens, 'Expected new line after level declaration');
        }
      }
      return levels;
    };
    Parser.parseLevels = parseLevels;
    return Parser;
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('validator/ValidatorError',[], function() {
    var ValidatorError;
    ValidatorError = function(token, message) {
      this.token = token;
      this.message = message;
    };
    ValidatorError.prototype = Object.create(Error.prototype);
    ValidatorError.prototype.constructor = ValidatorError;
    return ValidatorError;
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('validator/Validator',['validator/ValidatorError', 'Util'], function(ValidatorError, Util) {
    
    var Validator, checkCollisions, validateColorComponent, validateColors, validateEnterRules, validateGive, validateHeal, validateHurt, validateInInventoryItem, validateInTerrainItem, validateLeaveRules, validateLegend, validateLevels, validateNearRules, validateObjects, validateOutTerrainItem, validateParam, validatePlayer, validateSets, validateSound, validateSounds, validateSprites, validateTeleport, validateUseRules;
    Validator = {};
    Validator.validate = function(spec) {
      validateParam(spec.params, spec.levels);
      validateColors(spec.colors);
      validatePlayer(spec.player, spec.colors);
      validateObjects(spec.objects, spec.colors);
      validateSets(spec.sets, spec.objects);
      if (spec.sounds.length) {
        validateSounds(spec.sounds);
      }
      if (spec.nearRules.length) {
        validateNearRules(spec.nearRules, spec.objects, spec.sets);
      }
      if (spec.leaveRules.length) {
        validateLeaveRules(spec.leaveRules, spec.objects, spec.sets);
      }
      if (spec.enterRules.length) {
        validateEnterRules(spec.enterRules, spec.objects, spec.sets, spec.levels);
      }
      if (spec.useRules.length) {
        validateUseRules(spec.useRules, spec.objects, spec.sets, spec.sounds, spec.levels);
      }
      validateLegend(spec.legend, spec.objects);
      validateLevels(spec.levels, spec.legend);
      return true;
    };
    checkCollisions = function(array, valueExtractor, tokenExtractor, err) {
      var maybeDuplicate, plucked;
      plucked = array.map(valueExtractor);
      maybeDuplicate = Util.getDuplicate(plucked);
      if (maybeDuplicate.value != null) {
        throw new ValidatorError(tokenExtractor(array[maybeDuplicate.index]), err);
      }
    };
    validateParam = function(paramSpec, levelsSpec) {
      var levelsSet, paramsSet, startLevelName, _ref, _ref1;
      paramsSet = Util.indexBy(paramSpec, function(entry) {
        return entry.name.value;
      });
      levelsSet = Util.indexBy(levelsSpec, function(entry) {
        return entry.name.value;
      });
      if (paramsSet.camera != null) {
        if (paramsSet.camera.parts.length !== 2) {
          throw new ValidatorError(paramsSet.camera.name, 'Camera must have a width and a height');
        }
        if ((isNaN(paramsSet.camera.parts[0].value)) || (paramsSet.camera.parts[0].value < 5)) {
          throw new ValidatorError(paramsSet.camera.parts[0], 'Camera width value must be at least 5');
        }
        if ((isNaN(paramsSet.camera.parts[1].value)) || (paramsSet.camera.parts[1].value < 5)) {
          throw new ValidatorError(paramsSet.camera.parts[1], 'Camera height value must be at least 5');
        }
      }
      if (paramsSet.scale != null) {
        if (paramsSet.scale.parts.length !== 1) {
          throw new ValidatorError(paramsSet.scale.name, 'Scale must have a value');
        }
        if ((isNaN(paramsSet.scale.parts[0].value)) || (paramsSet.scale.parts[0].value < 1)) {
          throw new ValidatorError(paramsSet.scale.parts[0], 'Scale value must be at least 1');
        }
      }
      if (paramsSet.start_location != null) {
        if (paramsSet.start_location.parts.length !== 3) {
          throw new ValidatorError(paramsSet.start_location.name, 'Start location must have a column, a line and a level name');
        }
        if (isNaN(paramsSet.start_location.parts[0].value)) {
          throw new ValidatorError(paramsSet.start_location.parts[0], 'Start location column must be a number');
        }
        if (isNaN(paramsSet.start_location.parts[1].value)) {
          throw new ValidatorError(paramsSet.start_location.parts[1], 'Start location line must be a number');
        }
        startLevelName = paramsSet.start_location.parts[2].value;
        if (levelsSet[startLevelName] == null) {
          throw new ValidatorError(paramsSet.start_location.parts[2], 'Start level is not defined');
        }
        if (!((0 <= (_ref = +paramsSet.start_location.parts[0].value) && _ref <= levelsSet[startLevelName].data[0].value.length))) {
          throw new ValidatorError(paramsSet.start_location.parts[0], 'Start location coordinates must be within level bounds');
        }
        if (!((0 <= (_ref1 = +paramsSet.start_location.parts[1].value) && _ref1 <= levelsSet[startLevelName].data.length))) {
          throw new ValidatorError(paramsSet.start_location.parts[1], 'Start location coordinates must be within level bounds');
        }
      }
      if (paramsSet.inventory_size_max != null) {
        if (paramsSet.inventory_size_max.parts.length !== 1) {
          throw new ValidatorError(paramsSet.inventory_size_max.name, 'Inventory_size_max must have a value');
        }
        if ((isNaN(paramsSet.inventory_size_max.parts[0].value)) || (paramsSet.inventory_size_max.parts[0].value < 3)) {
          throw new ValidatorError(paramsSet.inventory_size_max.parts[0], 'Inventory_size_max value must be at 3');
        }
      }
      if (paramsSet.health_max != null) {
        if (paramsSet.health_max.parts.length !== 1) {
          throw new ValidatorError(paramsSet.health_max.name, 'Health_max must have a value');
        }
        if ((isNaN(paramsSet.health_max.parts[0].value)) || (paramsSet.health_max.parts[0].value < 0)) {
          throw new ValidatorError(paramsSet.health_max.parts[0], 'Health_max must be at least 0');
        }
      }
    };
    Validator.validateParam = validateParam;
    validateColorComponent = function(component, name, min, max) {
      var value;
      if (isNaN(component.value)) {
        throw new ValidatorError(component, "" + name + " value must be a number");
      }
      value = +component.value;
      if (value < min || value > max) {
        throw new ValidatorError(component, "" + name + " value must be between " + min + " and " + max);
      }
      return true;
    };
    validateColors = function(colorsSpec) {
      checkCollisions(colorsSpec, function(colorSpec) {
        return colorSpec.name.value;
      }, function(colorSpec) {
        return colorSpec.name;
      }, 'Color binding already declared');
      colorsSpec.forEach(function(color) {
        if (color.name.value.length !== 1) {
          throw new ValidatorError(color.name, 'Color bindings must have one character in length');
        }
        validateColorComponent(color.red, 'Red', 0, 255);
        validateColorComponent(color.green, 'Green', 0, 255);
        validateColorComponent(color.blue, 'Blue', 0, 255);
        if (color.alpha) {
          return validateColorComponent(color.alpha, 'Alpha', 0, 1);
        }
      });
      return true;
    };
    Validator.validateColors = validateColors;
    validateSprites = function(spritesSpec, colorsSpec) {
      var colorChars, height, width;
      checkCollisions(spritesSpec, function(spriteSpec) {
        return spriteSpec.name.value;
      }, function(spriteSpec) {
        return spriteSpec.name;
      }, 'Sprite binding already declared');
      width = spritesSpec[0].data[0].value.length;
      height = spritesSpec[0].data.length;
      spritesSpec.forEach(function(spriteSpec) {
        if (spriteSpec.data.length !== height) {
          throw new ValidatorError(spriteSpec.data[0], 'Sprites must be of the same size');
        } else {
          return spriteSpec.data.forEach(function(line, i) {
            if (line.value.length !== width) {
              throw new ValidatorError(line, 'Sprites must be of the same size');
            }
          });
        }
      });
      colorChars = {};
      colorsSpec.forEach(function(colorSpec) {
        return colorChars[colorSpec.name.value] = true;
      });
      return spritesSpec.forEach(function(spriteSpec) {
        return spriteSpec.data.forEach(function(line) {
          return line.value.split('').forEach(function(char) {
            if (!colorChars[char]) {
              throw new ValidatorError(line, 'No color is bound to character ' + char);
            }
          });
        });
      });
    };
    validatePlayer = function(playerSpec, colorsSpec) {
      var spriteNames;
      validateSprites(playerSpec, colorsSpec);
      spriteNames = {};
      playerSpec.forEach(function(frameSpec) {
        return spriteNames[frameSpec.name.value] = true;
      });
      return ['up', 'left', 'down', 'right', 'health'].forEach(function(name) {
        if (!spriteNames[name]) {
          throw new ValidatorError(null, 'Missing player frame: ' + name);
        }
      });
    };
    Validator.validatePlayer = validatePlayer;
    validateObjects = function(objectsSpec, colorsSpec) {
      return validateSprites(objectsSpec, colorsSpec);
    };
    Validator.validateObjects = validateObjects;
    validateSets = function(setSpec, objectsSpec) {
      var objectsSet, setsDefined;
      checkCollisions(setSpec, function(setSpec) {
        return setSpec.name.value;
      }, function(setSpec) {
        return setSpec.name;
      }, 'Set binding already declared');
      setSpec.forEach(function(binding) {
        if (!Util.isCapitalized(binding.name.value)) {
          throw new ValidatorError(binding.name, 'Set bindings must be capitalized');
        }
      });
      objectsSet = Util.getSet(Util.pluck(objectsSpec, 'name'), 'value');
      setsDefined = {};
      return setSpec.forEach(function(binding) {
        setsDefined[binding.name.value] = true;
        if (binding.operator != null) {
          if (!Util.isCapitalized(binding.operand1.value)) {
            throw new ValidatorError(binding.operand1, 'Can only perform set operations on sets');
          }
          if (!Util.isCapitalized(binding.operand2.value)) {
            throw new ValidatorError(binding.operand2, 'Can only perform set operations on sets');
          }
          if (!setsDefined[binding.operand1.value]) {
            throw new ValidatorError(binding.operand1, "Set " + binding.operand1.value + " was not defined");
          }
          if (!setsDefined[binding.operand2.value]) {
            throw new ValidatorError(binding.operand2, "Set " + binding.operand2.value + " was not defined");
          }
          if (binding.operand1.value === binding.name.value || binding.operand2.value === binding.name.value) {
            throw new ValidatorError(binding.operand1, 'Cannot reference a set in its own definition');
          }
        } else {
          return binding.elements.forEach(function(element) {
            if (Util.isCapitalized(element.value)) {
              throw new ValidatorError(element, 'Elements of an enumeration must be objects');
            }
            if (!objectsSet[element.value]) {
              throw new ValidatorError(element, "Object " + element.value + " was not defined");
            }
          });
        }
      });
    };
    Validator.validateSets = validateSets;
    validateSounds = function(soundsSpec) {
      return checkCollisions(soundsSpec, function(binding) {
        return binding.id.value;
      }, function(binding) {
        return binding.id;
      }, 'Sound binding already declared');
    };
    Validator.validateSounds = validateSounds;
    validateInTerrainItem = function(inTerrainItemName, objectsSet, setsSet) {
      if (Util.isCapitalized(inTerrainItemName.value)) {
        if (setsSet[inTerrainItemName.value] == null) {
          throw new ValidatorError(inTerrainItemName, "Set " + inTerrainItemName.value + " was not defined");
        }
      } else {
        if (objectsSet[inTerrainItemName.value] == null) {
          throw new ValidatorError(inTerrainItemName, "Object " + inTerrainItemName.value + " was not defined");
        }
      }
    };
    validateInInventoryItem = function(inInventoryItemName, objectsSet, setsSet) {
      if (Util.isCapitalized(inInventoryItemName.value)) {
        if (setsSet[inInventoryItemName.value] == null) {
          throw new ValidatorError(inInventoryItemName, "Set " + inInventoryItemName.value + " was not defined");
        }
      } else {
        if (objectsSet[inInventoryItemName.value] == null) {
          throw new ValidatorError(inInventoryItemName, "Object " + inInventoryItemName.value + " was not defined");
        }
      }
    };
    validateOutTerrainItem = function(outTerrainItemName, objectsSet, extrasSet) {
      if (extrasSet[outTerrainItemName.value]) {
        return;
      }
      if (Util.isCapitalized(outTerrainItemName.value)) {
        throw new ValidatorError(outTerrainItemName, "Sets are not allowed in the left hand side of rules");
      }
      if (!((objectsSet[outTerrainItemName.value] != null) || outTerrainItemName.value === '_terrain')) {
        throw new ValidatorError(outTerrainItemName, "Object " + outTerrainItemName.value + " was not defined");
      }
    };
    validateGive = function(giveSpec, objectsSet, extrasSet) {
      return giveSpec.forEach(function(entry) {
        if (isNaN(entry.quantity.value)) {
          throw new ValidatorError(entry.quantity, "Quantity must be a number");
        }
        if (extrasSet[entry.itemName.value]) {
          return;
        }
        if (objectsSet[entry.itemName.value] == null) {
          throw new ValidatorError(entry.itemName, "Object " + entry.itemName.value + " was not defined");
        }
      });
    };
    validateTeleport = function(teleportSpec, levelsSet) {
      var level, _ref, _ref1;
      if (isNaN(teleportSpec.x.value)) {
        throw new ValidatorError(teleportSpec.x, "X teleport coordinate must be a number");
      }
      if (isNaN(teleportSpec.y.value)) {
        throw new ValidatorError(teleportSpec.y, "Y teleport coordinate must be a number");
      }
      if (levelsSet[teleportSpec.levelName.value] == null) {
        throw new ValidatorError(teleportSpec.levelName, "Level " + teleportSpec.levelName.value + " does not exist");
      }
      level = levelsSet[teleportSpec.levelName.value];
      if (!((0 <= (_ref = +teleportSpec.x.value) && _ref <= level.data[0].value.length))) {
        throw new ValidatorError(teleportSpec.x, "Teleport coordinates must be within level bounds");
      }
      if (!((0 <= (_ref1 = +teleportSpec.y.value) && _ref1 <= level.data.length))) {
        throw new ValidatorError(teleportSpec.y, "Teleport coordinates must be within level bounds");
      }
    };
    validateHeal = function(healSpec) {
      if (isNaN(healSpec.value)) {
        throw new ValidatorError(healSpec, "Heal quantity must be a number");
      }
    };
    validateHurt = function(hurtSpec) {
      if (isNaN(hurtSpec.value)) {
        throw new ValidatorError(hurtSpec, "Hurt quantity must be a number");
      }
    };
    validateSound = function(soundSpec, soundsSet) {
      if (soundsSet[soundSpec.value] == null) {
        throw new ValidatorError(soundSpec, "Sound " + soundSpec.value + " was not defined");
      }
    };
    validateNearRules = function(rulesSpec, objectsSpec, setsSpec) {
      var extrasSet, objectsSet, setsSet;
      objectsSet = Util.getSet(objectsSpec.map(function(entry) {
        return entry.name.value;
      }));
      setsSet = Util.getSet(setsSpec.map(function(entry) {
        return entry.name.value;
      }));
      extrasSet = {
        _terrain: true
      };
      return rulesSpec.forEach(function(rule) {
        validateInTerrainItem(rule.inTerrainItemName, objectsSet, setsSet);
        validateOutTerrainItem(rule.outTerrainItemName, objectsSet, extrasSet);
        if (rule.heal != null) {
          validateHeal(rule.heal);
        }
        if (rule.hurt != null) {
          return validateHurt(rule.hurt);
        }
      });
    };
    Validator.validateNearRules = validateNearRules;
    validateLeaveRules = function(rulesSpec, objectsSpec, setsSpec) {
      var extrasSet, objectsSet, setsSet;
      objectsSet = Util.getSet(objectsSpec.map(function(entry) {
        return entry.name.value;
      }));
      setsSet = Util.getSet(setsSpec.map(function(entry) {
        return entry.name.value;
      }));
      extrasSet = {};
      return rulesSpec.forEach(function(rule) {
        validateInTerrainItem(rule.inTerrainItemName, objectsSet, setsSet);
        return validateOutTerrainItem(rule.outTerrainItemName, objectsSet, extrasSet);
      });
    };
    Validator.validateLeaveRules = validateLeaveRules;
    validateEnterRules = function(rulesSpec, objectsSpec, setsSpec, levelsSpec) {
      var extrasSet, levelsSet, objectsSet, setsSet;
      objectsSet = Util.getSet(objectsSpec.map(function(entry) {
        return entry.name.value;
      }));
      setsSet = Util.getSet(setsSpec.map(function(entry) {
        return entry.name.value;
      }));
      extrasSet = {
        '_terrain': true
      };
      levelsSet = Util.indexBy(levelsSpec, function(entry) {
        return entry.name.value;
      });
      return rulesSpec.forEach(function(rule) {
        validateInTerrainItem(rule.inTerrainItemName, objectsSet, setsSet);
        validateOutTerrainItem(rule.outTerrainItemName, objectsSet, extrasSet);
        if (rule.give != null) {
          validateGive(rule.give, objectsSet, extrasSet);
        }
        if (rule.heal != null) {
          validateHeal(rule.heal);
        }
        if (rule.hurt != null) {
          validateHurt(rule.hurt);
        }
        if (rule.teleport != null) {
          return validateTeleport(rule.teleport, levelsSet);
        }
      });
    };
    Validator.validateEnterRules = validateEnterRules;
    validateUseRules = function(rulesSpec, objectsSpec, setsSpec, soundsSpec, levelsSpec) {
      var extrasSet, levelsSet, objectsSet, setsSet, soundsSet;
      objectsSet = Util.getSet(objectsSpec.map(function(entry) {
        return entry.name.value;
      }));
      setsSet = Util.getSet(setsSpec.map(function(entry) {
        return entry.name.value;
      }));
      extrasSet = {
        _terrain: true,
        _inventory: true
      };
      soundsSet = Util.getSet(soundsSpec.map(function(entry) {
        return entry.id.value;
      }));
      levelsSet = Util.indexBy(levelsSpec, function(entry) {
        return entry.name.value;
      });
      return rulesSpec.forEach(function(rule) {
        validateInTerrainItem(rule.inTerrainItemName, objectsSet, setsSet);
        validateInInventoryItem(rule.inInventoryItemName, objectsSet, setsSet);
        validateOutTerrainItem(rule.outTerrainItemName, objectsSet, extrasSet);
        if (rule.give != null) {
          validateGive(rule.give, objectsSet, extrasSet);
        }
        if (rule.heal != null) {
          validateHeal(rule.heal);
        }
        if (rule.hurt != null) {
          validateHurt(rule.hurt);
        }
        if (rule.teleport != null) {
          validateTeleport(rule.teleport, levelsSet);
        }
        if (rule.sound != null) {
          return validateSound(rule.sound, soundsSet);
        }
      });
    };
    Validator.validateUseRules = validateUseRules;
    validateLegend = function(legendSpec, objectsSpec) {
      var inverseMapping, objectsSet;
      checkCollisions(legendSpec, function(binding) {
        return binding.name.value;
      }, function(binding) {
        return binding.name;
      }, 'Terrain unit binding already declared');
      inverseMapping = legendSpec.map(function(binding) {
        return binding.objectName;
      });
      checkCollisions(inverseMapping, function(binding) {
        return binding.value;
      }, function(binding) {
        return binding;
      }, 'Object already bound');
      objectsSet = Util.getSet(Util.pluck(objectsSpec, 'name'), 'value');
      legendSpec.forEach(function(binding) {
        if (!objectsSet[binding.objectName.value]) {
          throw new ValidatorError(binding.objectName, 'Bound object is undefined');
        }
      });
      return legendSpec.forEach(function(binding) {
        if (binding.name.value.length !== 1) {
          throw new ValidatorError(binding.name, 'Terrain bindings must have one character in length');
        }
      });
    };
    Validator.validateLegend = validateLegend;
    validateLevels = function(levelsSpec, legendSpec) {
      var terrainChars;
      checkCollisions(levelsSpec, function(binding) {
        return binding.name.value;
      }, function(binding) {
        return binding.name;
      }, 'Level already declared');
      terrainChars = Util.getSet(Util.pluck(legendSpec, 'name'), 'value');
      return levelsSpec.forEach(function(levelsSpec) {
        var levelWidth;
        levelWidth = levelsSpec.data[0].value.length;
        return levelsSpec.data.forEach(function(line) {
          if (line.value.length !== levelWidth) {
            throw new ValidatorError(line, 'All level lines must have the same length');
          }
          return line.value.split('').forEach(function(char) {
            if (!terrainChars[char]) {
              throw new ValidatorError(line, 'No terrain unit is bound to character "' + char + '"');
            }
          });
        });
      });
    };
    Validator.validateLevels = validateLevels;
    return Validator;
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('extractor/ValueExtractor',['tokenizer/Token'], function(Token) {
    
    var ValueExtractor, extract;
    ValueExtractor = {};
    extract = function(tree) {
      var ret;
      if (tree instanceof Token) {
        return tree.value;
      } else if (Array.isArray(tree)) {
        return tree.map(extract);
      } else if (typeof tree === 'object') {
        ret = {};
        Object.keys(tree).forEach(function(key) {
          return ret[key] = extract(tree[key]);
        });
        return ret;
      } else {
        return tree;
      }
    };
    ValueExtractor.extract = extract;
    return ValueExtractor;
  });

}).call(this);

define('KeyListener',['SystemBus'], function (SystemBus) {
	

	var keyState = {};

	function onKeyDown(e) {
		e.preventDefault();
		e.stopPropagation();

		if (!keyState[e.which]) {
			SystemBus.emit('keydown', { key: e.which });
		}
		keyState[e.which] = true;
	}

	function onKeyUp(e) {
		e.preventDefault();
		e.stopPropagation();

		if (keyState[e.which]) {
			SystemBus.emit('keyup', { key: e.which });
		}
		keyState[e.which] = false;
	}



	var KeyListener = {};

	KeyListener.init = function (domElement) {
		domElement.addEventListener('keydown', onKeyDown);
		domElement.addEventListener('keyup', onKeyUp);
	};

	return KeyListener;
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('import-export/FromPng',[], function() {
    var FromPng, imageToData;
    FromPng = {};
    imageToData = function(image) {
      var canvas, context;
      canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      context = canvas.getContext('2d');
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height).data;
    };
    FromPng.decode = function(path, callback) {
      var image;
      image = new Image;
      image.crossOrigin = '';
      image.src = path;
      return image.addEventListener('load', function() {
        var c, data, i, text, textSize;
        data = imageToData(image);
        textSize = data[0] * 256 + data[1];
        text = [];
        i = 4;
        c = 0;
        while (c < textSize - 3) {
          text.push(String.fromCharCode(data[i + 0]));
          text.push(String.fromCharCode(data[i + 1]));
          text.push(String.fromCharCode(data[i + 2]));
          i += 4;
          c += 3;
        }
        while (c < textSize) {
          text.push(String.fromCharCode(data[i]));
          i++;
          c++;
        }
        return callback(text.join(''));
      });
    };
    return FromPng;
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('AjaxUtil',[], function() {
    var AjaxUtil;
    AjaxUtil = {};
    AjaxUtil.load = function(url, callback) {
      var httpRequest;
      httpRequest = new XMLHttpRequest();
      httpRequest.onreadystatechange = function() {
        if (httpRequest.readyState === 4) {
          if (httpRequest.status === 200) {
            return callback(httpRequest.responseText);
          } else {
            throw new Error('Could not retrieve ' + url);
          }
        }
      };
      httpRequest.open('GET', url);
      return httpRequest.send();
    };
    return AjaxUtil;
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('main',['SystemBus', 'Text', 'Game', 'tokenizer/Tokenizer', 'parser/Parser', 'validator/Validator', 'extractor/ValueExtractor', 'KeyListener', 'import-export/FromPng', 'AjaxUtil'], function(SystemBus, Text, Game, Tokenizer, Parser, Validator, ValueExtractor, KeyListener, FromPng, AjaxUtil) {
    
    var checkUrl, compile, edit, editorEventHandlers, editorListener, editorListenerInstalled, editorWindow, emit, game, originUrl, parse, run, setupGUI, source;
    source = '';
    game = null;
    editorWindow = null;
    editorListenerInstalled = false;
    parse = function(inText) {
      var ex, tokens, tree;
      try {
        tokens = Tokenizer.chop(inText);
        tree = Parser.parse(tokens);
        Validator.validate(tree);
        return ValueExtractor.extract(tree);
      } catch (_error) {
        ex = _error;
        console.error(ex);
        return null;
      }
    };
    compile = function(tree) {
      if (game) {
        game.cleanup();
      }
      game = new Game;
      game.init(tree).then(function() {
        return game.start();
      });
    };
    editorEventHandlers = {
      'compile': function(data) {
        var tree;
        tree = parse(data.source);
        return compile(tree);
      },
      'request-source': function(data) {
        return emit({
          type: 'source',
          source: source
        });
      }
    };
    originUrl = '*';
    editorListener = function(e) {
      var data;
      e.preventDefault();
      data = e.data;
      if (data.type != null) {
        editorEventHandlers[data.type](data);
      }
    };
    edit = function() {
      if (!editorListenerInstalled) {
        editorListenerInstalled = true;
        window.addEventListener('message', editorListener, false);
      }
      if ((editorWindow == null) || editorWindow.closed) {
        editorWindow = window.open('editor.html', '_blank', 'menubar=no, location=no, width=656, height=640');
      } else {
        editorWindow.focus();
      }
    };
    emit = function(data) {
      editorWindow.postMessage(data, originUrl);
    };
    setupGUI = function() {
      var editButton;
      editButton = document.getElementById('edit');
      editButton.addEventListener('click', edit);
    };
    checkUrl = function(callback) {
      var sample, urlParams;
      urlParams = purl(true).param();
      if (urlParams.spec) {
        callback(urlParams.spec);
      } else if (urlParams.png) {
        FromPng.decode(urlParams.png, function(text) {
          return callback(text);
        });
      } else if (urlParams.text) {
        AjaxUtil.load(urlParams.text, function(text) {
          return callback(text);
        });
      } else if (urlParams.sample) {
        sample = window.sampleSpecs[urlParams.sample];
        callback(sample || window.sampleSpecs['little-furnace']);
      } else {
        callback(window.sampleSpecs['little-furnace']);
      }
    };
    run = function() {
      setupGUI();
      checkUrl(function(_source) {
        var tree;
        source = _source;
        Text.init();
        document.getElementById('can').tabIndex = 0;
        KeyListener.init(document.getElementById('can'));
        tree = parse(_source);
        compile(tree);
        document.getElementById('can').focus();
      });
    };
    return {
      run: run
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('import-export/ToPng',[], function() {
    var ToPng, dataToCanvas, maxAlpha;
    ToPng = {};
    dataToCanvas = function(data) {
      var canvas, context, i, imageData, p, sqrt;
      canvas = document.createElement('canvas');
      sqrt = Math.ceil(Math.sqrt((data.length + 3) / 3));
      canvas.width = sqrt;
      canvas.height = sqrt;
      context = canvas.getContext('2d');
      imageData = context.createImageData(sqrt, sqrt);
      imageData.data[0] = Math.floor(data.length / 256);
      imageData.data[1] = data.length % 256;
      imageData.data[3] = 255;
      i = 0;
      p = 4;
      while (i < data.length) {
        imageData.data[p + 0] = data[i + 0];
        imageData.data[p + 1] = data[i + 1];
        imageData.data[p + 2] = data[i + 2];
        imageData.data[p + 3] = 255;
        i += 3;
        p += 4;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    };
    maxAlpha = function(rawData) {
      var data, i;
      data = [];
      i = 0;
      while (i < rawData.length) {
        data.push(rawData[i + 0]);
        data.push(rawData[i + 1]);
        data.push(rawData[i + 2]);
        data.push(255);
        i += 3;
      }
      return data;
    };
    ToPng.encode = function(text) {
      var data, i;
      data = [];
      i = 0;
      while (i < text.length) {
        data.push(text.charCodeAt(i));
        i++;
      }
      return dataToCanvas(data);
    };
    return ToPng;
  });

}).call(this);

define('editor/furnace-rules',[],function () {
    

    ace.define('ace/mode/furnace-rules', function (require_, exports, module) {
        var oop = require_('../lib/oop');
        var TextHighlightRules = require_('./text_highlight_rules').TextHighlightRules;

        var FurnaceHighlightRules = function () {
            var SECTION = 'keyword';
            var BINDING = 'variable';
            var RESERVED = 'constant.other';
            var STRING = 'string';
            var COMMENT = 'comment';
            var SETBINDING = 'storage.type';
            var PLAIN = 'text';

            this.$rules = {
                'start': [{
                    token: SECTION,
                    regex: /^\s*PARAM\s*$/,
                    next: 'PARAM'
                }],
                'PARAM': [{
                    token: SECTION,
                    regex: /^\s*COLORS\s*$/,
                    next: 'COLORS'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: BINDING,
                    regex: /^[_a-zA-Z]\w*/
                }, {
                    token: PLAIN,
                    regex: /\w+/
                }],
                'COLORS': [{
                    token: SECTION,
                    regex: /^\s*PLAYER\s*$/,
                    next: 'PLAYER'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: BINDING,
                    regex: /^\w/
                }, {
                    token: RESERVED,
                    regex: /rgb|rgba/
                }, {
                    token: PLAIN,
                    regex: /\d+/
                }],
                'PLAYER': [{
                    token: SECTION,
                    regex: /^\s*OBJECTS\s*$/,
                    next: 'OBJECTS'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: BINDING,
                    regex: /^\s*\w+\s*$/,
                    next: 'PLAYER-data'
                }, {
                    token: BINDING,
                    regex: /^\s*\w+\s*(?=\/\/)/,
                    next: 'PLAYER-data'
                }],
                'PLAYER-data': [{
                    token: PLAIN,
                    regex: /^\w+$/
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: PLAIN,
                    regex: /^\s*$/,
                    next: 'PLAYER'
                }],
                'OBJECTS': [{
                    token: SECTION,
                    regex: /^\s*SETS\s*$/,
                    next: 'SETS'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: BINDING,
                    regex: /^\s*\w+(?:\:\d+)?(?=\s+blocking)/
                }, {
                    token: RESERVED,
                    regex: /blocking\s*$/,
                    next: 'OBJECTS-data'
                }, {
                    token: BINDING,
                    regex: /^\s*\w+(?:\:\d+)?\s*$/,
                    next: 'OBJECTS-data'
                }, {
                    token: BINDING,
                    regex: /^\s*\w+(?:\:\d+)?\s*(?=\/\/)/,
                    next: 'OBJECTS-data'
                }],
                'OBJECTS-data': [{
                    token: PLAIN,
                    regex: /^\w+$/
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: PLAIN,
                    regex: /^\s*$/,
                    next: 'OBJECTS'
                }],
                'SETS': [{
                    token: SECTION,
                    regex: /^\s*SOUNDS\s*$/,
                    next: 'SOUNDS'
                }, {
                    token: SECTION,
                    regex: /^\s*NEARRULES\s*$/,
                    next: 'NEARRULES'
                }, {
                    token: SECTION,
                    regex: /^\s*LEAVERULES\s*$/,
                    next: 'LEAVERULES'
                }, {
                    token: SECTION,
                    regex: /^\s*ENTERRULES\s*$/,
                    next: 'ENTERRULES'
                }, {
                    token: SECTION,
                    regex: /^\s*USERULES\s*$/,
                    next: 'USERULES'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: RESERVED,
                    regex: /=|and|or|minus/
                }, {
                    token: SETBINDING,
                    regex: /[A-Z]\w*/
                }, {
                    token: BINDING,
                    regex: /[a-z]\w*/
                }],
                'SOUNDS': [{
                    token: SECTION,
                    regex: /^\s*NEARRULES\s*$/,
                    next: 'NEARRULES'
                }, {
                    token: SECTION,
                    regex: /^\s*LEAVERULES\s*$/,
                    next: 'LEAVERULES'
                }, {
                    token: SECTION,
                    regex: /^\s*ENTERRULES\s*$/,
                    next: 'ENTERRULES'
                }, {
                    token: SECTION,
                    regex: /^\s*USERULES\s*$/,
                    next: 'USERULES'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: PLAIN,
                    regex: /^[0-9A-F]+/
                }, {
                    token: BINDING,
                    regex: /\w+/
                }],
                'NEARRULES': [{
                    token: SECTION,
                    regex: /^\s*LEAVERULES\s*$/,
                    next: 'LEAVERULES'
                }, {
                    token: SECTION,
                    regex: /^\s*ENTERRULES\s*$/,
                    next: 'ENTERRULES'
                }, {
                    token: SECTION,
                    regex: /^\s*USERULES\s*$/,
                    next: 'USERULES'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: RESERVED,
                    regex: /->|;|heal|hurt/
                }, {
                    token: SETBINDING,
                    regex: /[A-Z]\w*/
                }, {
                    token: BINDING,
                    regex: /[a-z]\w*/
                }],
                'LEAVERULES': [{
                    token: SECTION,
                    regex: /^\s*ENTERRULES\s*$/,
                    next: 'ENTERRULES'
                }, {
                    token: SECTION,
                    regex: /^\s*USERULES\s*$/,
                    next: 'USERULES'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: RESERVED,
                    regex: /->/
                }, {
                    token: SETBINDING,
                    regex: /[A-Z]\w*/
                }, {
                    token: BINDING,
                    regex: /[a-z]\w*/
                }],
                'ENTERRULES': [{
                    token: SECTION,
                    regex: /USERULES/,
                    next: 'USERULES'
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: STRING,
                    regex: /"(?:(?:\\.)|(?:[^"\\]))*"/
                }, {
                    token: RESERVED,
                    regex: /->|;|,|_terrain|_inventory|give|heal|hurt|teleport|message|checkpoint/
                }, {
                    token: SETBINDING,
                    regex: /[A-Z]\w*/
                }, {
                    token: BINDING,
                    regex: /[a-z]\w*/
                }],
                'USERULES': [{
                    token: SECTION,
                    regex: /LEGEND/,
                    next: 'LEGEND'
                }, {
                    token: STRING,
                    regex: /"(?:(?:\\.)|(?:[^"\\]))*"/
                }, {
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: RESERVED,
                    regex: /->|;|,|_terrain|_inventory|give|heal|hurt|teleport|message|sound|consume/
                }, {
                    token: SETBINDING,
                    regex: /[A-Z]\w*/
                }, {
                    token: BINDING,
                    regex: /[a-z]\w*/
                }],
                'LEGEND': [{
                    token: SECTION,
                    regex: /LEVELS/,
                    next: 'LEVELS'
                }, {
                    token: BINDING,
                    regex: /^[\w!@#$%^&*\-=+]/
                }],
                'LEVELS': [{
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: BINDING,
                    regex: /^\s*\w+\s*$/,
                    next: 'LEVELS-data'
                }, {
                    token: BINDING,
                    regex: /^\s*\w+\s*(?=\/\/)/,
                    next: 'LEVELS-data'
                }],
                'LEVELS-data': [{
                    token: COMMENT,
                    regex: /\/\/.*$/
                }, {
                    token: PLAIN,
                    regex: /^\w+$/
                }, {
                    token: PLAIN,
                    regex: /^\s*$/,
                    next: 'LEVELS'
                }]
            };
        };

        oop.inherits(FurnaceHighlightRules, TextHighlightRules);

        exports.FurnaceHighlightRules = FurnaceHighlightRules;
    });
});

// Generated by CoffeeScript 1.8.0
(function() {
  define('editor/furnace-mode',['editor/furnace-rules'], function() {
    
    return ace.define('ace/mode/furnace', function(require_, exports, module) {
      var HighlightRules, Mode, TextMode, Tokenizer, oop;
      require_('ace/theme/furnace-monokai');
      oop = require_('ace/lib/oop');
      TextMode = require_('./text').Mode;
      Tokenizer = require_('ace/tokenizer').Tokenizer;
      HighlightRules = require_('ace/mode/furnace-rules').FurnaceHighlightRules;
      Mode = function() {
        this.$tokenizer = new Tokenizer(new HighlightRules().getRules());
      };
      oop.inherits(Mode, TextMode);
      exports.Mode = Mode;
    });
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('main-editor',['tokenizer/Tokenizer', 'parser/Parser', 'validator/Validator', 'extractor/ValueExtractor', 'import-export/ToPng', 'sound/Sound', 'sound/SoundUtil', 'editor/furnace-mode'], function(Tokenizer, Parser, Validator, ValueExtractor, ToPng, Sound, SoundUtil) {
    
    var baseUrl, compile, emit, errorLine, exportAsPng, inWorldEditor, mainEventHandlers, mainListener, onChange, originUrl, parse, playing, randomSound, requestSource, run, setUrl, setupComm, setupEditors, setupGui, setupSoundPanel;
    baseUrl = 'http://madflame991.github.io/furnace-engine/src/index.html';
    errorLine = null;
    inWorldEditor = null;
    onChange = function() {
      parse(inWorldEditor.getValue());
    };
    setupEditors = function() {
      inWorldEditor = ace.edit('in');
      inWorldEditor.getSession().setMode('ace/mode/furnace');
      inWorldEditor.setTheme('ace/theme/monokai');
      inWorldEditor.on('input', onChange);
    };
    playing = false;
    randomSound = function(type) {
      var encoded, parameters, spec;
      if (playing) {
        return;
      }
      playing = true;
      spec = Sound.getSpec(Sound.CURRENT_GENERATION, type);
      parameters = Sound.getRandomParameters(type);
      encoded = SoundUtil.encode(Sound.CURRENT_GENERATION, type, parameters, spec);
      document.getElementById('sound-encoded').value = encoded;
      Sound.generate(Sound.CURRENT_GENERATION, type, parameters).then(function(buffer) {
        Sound.play(buffer, function() {
          return playing = false;
        });
      });
    };
    setupSoundPanel = function() {
      var i, _fn, _i;
      _fn = function(i) {
        var sXButton;
        sXButton = document.getElementById("s" + i);
        return sXButton.addEventListener('click', function() {
          return randomSound(i);
        });
      };
      for (i = _i = 0; _i <= 4; i = ++_i) {
        _fn(i);
      }
    };
    setupGui = function() {
      var compileButton, exportAsPngButton, getUrlButton;
      compileButton = document.getElementById('compile');
      compileButton.addEventListener('click', compile);
      getUrlButton = document.getElementById('geturl');
      getUrlButton.addEventListener('click', setUrl);
      exportAsPngButton = document.getElementById('exportaspng');
      exportAsPngButton.addEventListener('click', exportAsPng);
    };
    requestSource = function() {
      emit({
        type: 'request-source'
      });
    };
    compile = function() {
      emit({
        type: 'compile',
        source: inWorldEditor.getValue()
      });
    };
    mainEventHandlers = {
      'source': function(data) {
        return inWorldEditor.setValue(data.source, -1);
      }
    };
    mainListener = function(e) {
      var data;
      e.preventDefault();
      data = e.data;
      if (data.type != null) {
        mainEventHandlers[data.type](data);
      }
    };
    setupComm = function() {
      window.addEventListener('message', mainListener, false);
    };
    originUrl = '*';
    emit = function(data) {
      window.opener.postMessage(data, originUrl);
    };
    parse = function(inText) {
      var ex, line, tokens, tree;
      try {
        tokens = Tokenizer.chop(inText);
        tree = Parser.parse(tokens);
        Validator.validate(tree);
        if (errorLine !== null) {
          inWorldEditor.getSession().setAnnotations([]);
          errorLine = null;
        }
        document.getElementById('status').classList.add('ok');
        document.getElementById('status').classList.remove('err');
        document.getElementById('status').innerHTML = 'OK';
        document.getElementById('compile').disabled = false;
        return ValueExtractor.extract(tree);
      } catch (_error) {
        ex = _error;
        document.getElementById('compile').disabled = true;
        if (ex.line || ex.token) {
          line = ex.line || ex.token.coords.line;
          if (line !== errorLine && errorLine !== null) {
            inWorldEditor.getSession().setAnnotations([]);
          }
          errorLine = line;
          inWorldEditor.getSession().setAnnotations([
            {
              row: errorLine - 1,
              text: ex.message || ex,
              type: 'error'
            }
          ]);
        }
        document.getElementById('status').classList.add('err');
        document.getElementById('status').classList.remove('ok');
        document.getElementById('status').innerHTML = ex.message || ex;
        return null;
      }
    };
    setUrl = function() {
      var encodedLevel, spec, url, urlTextarea;
      spec = inWorldEditor.getValue();
      encodedLevel = encodeURIComponent(spec);
      url = "" + baseUrl + "?spec=" + encodedLevel;
      urlTextarea = document.getElementById('url');
      urlTextarea.value = url;
    };
    exportAsPng = function() {
      var canvas, container, existingImage, image, spec, urlTextarea;
      spec = inWorldEditor.getValue();
      canvas = ToPng.encode(spec);
      image = document.createElement('img');
      image.src = canvas.toDataURL();
      image.id = 'exported-spec';
      existingImage = document.getElementById('exported-spec');
      if (existingImage) {
        existingImage.parentNode.removeChild(existingImage);
      }
      urlTextarea = document.getElementById('url');
      urlTextarea.value = 'Exported spec as image\n' + 'To decode the image access: ' + baseUrl + '?png=_image_url_';
      container = document.getElementById('exported-container');
      container.appendChild(image);
    };
    run = function() {
      setupEditors();
      setupGui();
      setupSoundPanel();
      setupComm();
      requestSource();
    };
    return {
      run: run
    };
  });

}).call(this);

// Generated by CoffeeScript 1.8.0
(function() {
  define('furnace',['main', 'main-editor'], function() {});

}).call(this);

  })();
})();