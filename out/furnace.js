(function () {
  if (localStorage.furnaceDev) { require.config({ baseUrl: "js" }); }
  else (function () {
define('Util',[], function () {
	

	var Util = {};

	Util.maptree = function (tree, fun, predicate) {
		if (predicate(tree)) {
			return fun(tree);
		}

		if (tree instanceof Array) {
			return tree.map(function (elem) {
				return Util.maptree(elem, fun, predicate);
			});
		} else if (typeof tree === 'object') {
			var newObj = {};
			for (var key in tree) {
				newObj[key] = Util.maptree(tree[key], fun, predicate);
			}
			return newObj;
		}
	};

	Util.findFirst = function (array, predicate) {
		for (var i = 0; i < array.length; i++) {
			if (predicate(array[i], i)) {
				return { element: array[i], index: i };
			}
		}
	};

	Util.removeFirst = function (array, predicate) {
		var firstMatch = Util.findFirst(array, predicate);
		if (firstMatch) {
			array.splice(firstMatch.index, 1);
		}
	};

	Util.remove = function (array, element) {
		Util.removeFirst(array, function (entry) {
			return entry === element;
		});
	};

	Util.objectToArray = function (object, nameProperty, dataProperty) {
		var array = [];
		for (var key in object) {
			var entry = {};
			entry[nameProperty] = key;
			entry[dataProperty] = object[key];

			array.push(entry);
		}
		return array;
	};

	Util.arrayToObject = function (array, nameProperty, dataProperty) {
		var object = {};

		array.forEach(function (element) {
			object[element[nameProperty]] = element[dataProperty];
		});

		return object;
	};

	Util.mapOnKeys = function (object, fun) {
		var ret = {};
		for (var key in object) {
			ret[key] = fun(object[key]);
		}
		return ret;
	};

	Util.groupBy = function (array, fun) {
		var groups = {};
		array.forEach(function (element) {
			var ret = fun(element);
			if (!groups[ret]) {
				groups[ret] = [];
			}
			groups[ret].push(element);
		});
		return groups;
	};

	Util.capitalize = function (string) {
		return string.substring(0, 1).toUpperCase() + string.substring(1);
	};

	Util.isCapitalized = function (string) {
		return string.substring(0, 1).toUpperCase() === string.substring(0, 1);
	};

	return Util;
});

define('Bus',['Util'], function (Util) {
	

	function Bus() {
		this.channels = {};
	}

	Bus.prototype.addListener = function (channel, id, callback) {
		if (!this.channels[channel]) {
			this.channels[channel] = [];
		}
		this.channels[channel].push({ id: id, callback: callback });
	};

	Bus.prototype.emit = function (channel, data) {
		if (this.channels[channel]) {
			this.channels[channel].forEach(function(listener) {
				listener.callback(data);
			});
		}
	};

	Bus.prototype.removeListener = function (channel, id) {
		Util.removeFirst(this.channels[channel], function(listener) { return listener.id === id; });
	};

	Bus.prototype.removeChannel = function (channel) {
		delete this.channels[channel];
	};

	Bus.prototype.reset = function () {
		this.channels = {};
	};

	return Bus;
});

define('SystemBus',['Bus'], function (Bus) {
	

	var SystemBus = new Bus();

	return SystemBus;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('Font',[], function() {
    var colorBindings, convert, spritesByName;
    colorBindings = {
      '1': 'rgb(255, 255, 255)',
      '2': 'rgb(0, 0, 0)',
      '.': 'rgba(0, 0, 0, 0)'
    };
    spritesByName = {
      '0': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112....11112..\n..112.1112.112..\n..11112....112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....',
      'A': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..',
      'N': '.112.........112\n.112.........112\n.11112.......112\n.112.112.....112\n.112...112...112\n.112.....112.112\n.112.......11112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112',
      '1': '.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......',
      'B': '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....',
      'O': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....',
      '2': '....11111112....\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n...........112..\n....11111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..',
      'C': '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112......112..\n..112......112..\n....11111112....',
      'P': '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........',
      '3': '....11111112....\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n...........112..\n.......11112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....',
      'D': '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....',
      'Q': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112..112.112..\n..112....11112..\n..112......112..\n..112......112..\n....11111112....',
      '4': '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..',
      'E': '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..',
      'R': '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..',
      '5': '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....',
      'F': '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........',
      'S': '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n....11111112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....',
      '6': '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111.....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....',
      'G': '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....',
      'T': '..1111111111112.\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......',
      '7': '..111111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..',
      'H': '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..',
      'U': '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....',
      '8': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....',
      'I': '.....1111112....\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.....1111112....',
      'V': '.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.......112......',
      '9': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....1111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....',
      'J': '..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n....112...112...\n....112...112...\n......11112.....',
      'W': '.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112...112...112\n.112.112.112.112\n.11112.....11112\n.112.........112\n.112.........112',
      '.': '................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n.......112......\n.......112......',
      'K': '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112....112....\n..11111112......\n..112....112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..',
      'X': '.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.....112.112....\n.....112.112....\n...112.....112..\n...112.....112..\n.112.........112\n.112.........112\n.112.........112',
      '!': '.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n................\n................\n.......112......\n.......112......',
      'L': '..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..',
      'Y': '.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......',
      '?': '....11111112....\n..112......112..\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n.........112....\n.......112......\n.......112......\n.......112......\n.......112......\n................\n................\n.......112......\n.......112......',
      'M': '.112.........112\n.112.........112\n.11112.....11112\n.112.112.112.112\n.112...112...112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112',
      'Z': '...11111111112..\n...........112..\n...........112..\n...........112..\n.........112....\n.........112....\n.........112....\n.......112......\n.......112......\n.......112......\n.....112........\n.....112........\n.....112........\n...112..........\n...112..........\n...11111111112..'
    };
    convert = function(stringedSprites) {
      var key, ret, sprite;
      ret = {};
      for (key in stringedSprites) {
        sprite = stringedSprites[key];
        ret[key] = sprite.split('\n').map(function(line) {
          return {
            s: line
          };
        });
      }
      return ret;
    };
    return {
      colorBindings: colorBindings,
      spritesByName: convert(spritesByName)
    };
  });

}).call(this);

define('con2d',[], function () {
	

	var canvas = document.getElementById('can');

	var con2d = canvas.getContext('2d');

	return con2d;
});

define('Sprite',[
	'con2d'
	], function (
		con2d
	) {
	

	function Sprite(spriteSheet, start, end) {
		this.spriteSheet = spriteSheet;
		this.start = start;
		this.end = end;
	}

	Sprite.prototype.drawAt = function(x, y) {
		con2d.drawImage(
			this.spriteSheet,
			this.start.x, this.start.y, this.end.x - this.start.x, this.end.y - this.start.y,
			x, y, this.end.x - this.start.x, this.end.y - this.start.y
		);
	};

	return Sprite;
});

define('Vec2',[], function () {
	

	function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
            return new Vec2(x, y);
        }
		this.x = x;
		this.y = y;
	}

	Vec2.prototype.copy = function () {
		return new Vec2(this.x, this.y);
	};

	Vec2.prototype.add = function (that) {
		return new Vec2(this.x + that.x, this.y + that.y);
	};

	Vec2.prototype.addOn = function (that) {
		this.x += that.x;
		this.y += that.y;
	};

	Vec2.prototype.sub = function (that) {
		return new Vec2(this.x - that.x, this.y - that.y);
	};

	Vec2.prototype.subOn = function (that) {
		this.x -= that.x;
		this.y -= that.y;
	};

	Vec2.prototype.scale = function (scale) {
		return new Vec2(this.x * scale, this.y * scale);
	};

	Vec2.prototype.scaleOn = function (scale) {
		this.x *= scale;
		this.y *= scale;
	};

	Vec2.prototype.mul = function (that) {
		return new Vec2(this.x * that.x, this.y * that.y);
	};

	Vec2.prototype.mulOn = function (that) {
		this.x *= that.x;
		this.y *= that.y;
	};

	return Vec2;
});

define('SpriteSheet',[
	'Sprite',
	'Vec2'
	], function (
		Sprite,
		Vec2
	) {
	

	function SpriteSheet(image, width, height) {
		this.image = image;
		this.width = width;
		this.height = height;
		this.spriteWidth = Math.floor(this.image.width / this.width);
		this.spriteHeight = Math.floor(this.image.height / this.height);
	}

	SpriteSheet.prototype.getSprite = function(x, y) {
		return new Sprite(
			this.image,
			new Vec2(this.spriteWidth * x, this.spriteHeight * y),
			new Vec2((x + 1) * this.spriteWidth, (y + 1) * this.spriteHeight)
		);
	};

	return SpriteSheet;
});

define('generator/SpriteSheetGenerator',[
	'Util',
	'SpriteSheet'
	], function (
		Util, SpriteSheet
	) {
	

	var SpriteSheetGenerator = {};

	SpriteSheetGenerator.generate = function(stringedSpritesByName, colorBindings, scale) {
		var stringedSprites = Util.objectToArray(stringedSpritesByName, 'name', 'data');

		var width = Math.ceil(Math.sqrt(stringedSprites.length));

		var canvas = document.createElement('canvas');

		//document.body.appendChild(canvas); //

		canvas.width = stringedSprites[0].data.length * width * scale;
		canvas.height = stringedSprites[0].data.length * width * scale;
		var con2d = canvas.getContext('2d');

		function pixel(x, y, color) {
			con2d.fillStyle = color;
			con2d.fillRect(x * scale, y * scale, scale, scale);
		}

		function paint(x, y, data) {
			var baseOffsetX = x * data.length;
			var baseOffsetY = y * data.length;

			data.forEach(function (line, i) {
				// should not need s
				line.s.split('').forEach(function (char, j) {
					var color = colorBindings[char];
					pixel(baseOffsetX + j, baseOffsetY + i, color);
				});
			});
		}

		stringedSprites.forEach(function (stringedSprite, index) {
			var x = index % width;
			var y = Math.floor(index / width);

			paint(x, y, stringedSprite.data);
		});


		var dataURL = canvas.toDataURL('image/png');
		var image = new Image();
		image.src = dataURL;

		var spriteSheet = new SpriteSheet(image, width, width);


		var namedSprites = stringedSprites.map(function (stringedSprite, index) {
			var x = index % width;
			var y = Math.floor(index / width);

			return {
				name: stringedSprite.name,
				sprite: spriteSheet.getSprite(x, y)
			};
		});

		return namedSprites;
	};

	return SpriteSheetGenerator;
});

define('Text',[
    'Font',
    'generator/SpriteSheetGenerator',
    'Util'
], function (
    Font,
    SpriteSheetGenerator,
    Util
    ) {

	

	var Text = {};

	Text.sprites = [];

	Text.init = function() {
        var namedSprites = SpriteSheetGenerator.generate(Font.spritesByName, Font.colorBindings, 1);

        namedSprites.forEach(function (namedSprite) {
            Text.sprites[namedSprite.name.charCodeAt(0)] = namedSprite.sprite;
        });
	};

	Text.drawAt = function(string, x, y) {
		string += '';

		var chars = string.split('').map(function(char) { return char.charCodeAt(0); });

		for (var i = 0; i < chars.length; i++) {
			var sprite = Text.sprites[chars[i]];
			if (sprite) {
                sprite.drawAt(x + i * 16, y);
            }
		}
	};

	return Text;
});

define('Items',[], function () {
	

	var Items = {};

	Items.collection = {};

	return Items;
});

define('Player',[
	'SystemBus',
	'Vec2',
	'Items'
	], function(
		SystemBus,
		Vec2,
		Items
	) {
	

	function Player(world, spritesByName, tileDimensions, uiOffset) {
		this.world = world;
		this.blockWidth = tileDimensions.x;
		this.blockHeight = tileDimensions.y;
		this.uiOffset = uiOffset || new Vec2(0, 0);
		this.position = new Vec2(0, 0);
		this.sprite = null;
		this.spritesByName = spritesByName;
		this.direction = 'down';
	}

	var keyMapping = {
		65: 'use',
		83: 'invleft',
		68: 'invright',
		70: 'invmark',
		38: 'up',
		37: 'left',
		40: 'down',
		39: 'right'
	};

	var deltas = {
		up: new Vec2(0, -1),
		left: new Vec2(-1, 0),
		down: new Vec2(0, 1),
		right: new Vec2(1, 0)
	};

	var invDeltas = {
		invleft: -1,
		invright: 1
	};

	/**
	 * Initializes the player
	 */
	Player.prototype.init = function () {
		this.direction = 'down';
		this.sprite = this.spritesByName[this.direction];

		SystemBus.addListener('keydown', '', function(data) {
            if (this.world.textBubble.visible) {
                if (data.key === 65) {
                    this.world.textBubble.hide();
                }
            } else {
                if (data.key === 65) {
                    this.use();
                } else if (data.key === 83 || data.key === 68) {
                    this.world.inventory.move(invDeltas[keyMapping[data.key]]);
                } else {
                    if (keyMapping[data.key]) {
                        this.move(deltas[keyMapping[data.key]]);
                        this.direction = keyMapping[data.key];
                        this.sprite = this.spritesByName[this.direction];
                    }
                }
            }
		}.bind(this));
	};

	/**
	 * Sets the position of the player
	 */
	Player.prototype.setPosition = function (x, y) {
		this.position.x = x;
		this.position.y = y;
		this.world.camera.centerOn(this.position.x, this.position.y, this.world.level.width, this.world.level.height);
	};

	/**
	 * Moves delta units
	 */
	Player.prototype.move = function (delta) {
		var candidatePosition = this.position.add(delta);
		if (this.world.level.withinBounds(candidatePosition.x, candidatePosition.y)) {
			var futureBlock = this.world.level.get(candidatePosition.x, candidatePosition.y);
			if (!futureBlock.blocking) {
				this.leave();

				this.position = candidatePosition;
				this.world.camera.centerOn(this.position.x, this.position.y, this.world.level.width, this.world.level.height);

				this.enter();

                this.near();
			}
		}
	};

	/**
	 * Teleports the player in the given level at the given coordinates
	 * @param {string} levelName
	 * @param {number} x
	 * @param {number} y
	 */
	Player.prototype.teleport = function (levelName, x, y) {
		this.world.setLevel(levelName);
		this.setPosition(x, y);
	};

	/**
	 * Returns the facing position
	 */
	Player.prototype.getFacing = function () {
		return this.position.add(deltas[this.direction]);
	};

	function resolveItem(inTerrainItem, inInventoryItem, outItem) {
		if (outItem === '_terrain') {
			return inTerrainItem;
		} else if (outItem === '_inventory') {
			return inInventoryItem;
		} else {
			return outItem;
		}
	}

    /**
     * Standard 8 neighbouring locations on a tiled map
     * @type {Vec2[]}
     */
    Player.neighbourhood = [
        new Vec2( 0, -1),
        new Vec2(-1, -1),
        new Vec2(-1,  0),
        new Vec2(-1,  1),
        new Vec2( 0,  1),
        new Vec2( 1,  1),
        new Vec2( 1,  0),
        new Vec2( 1, -1)
    ];

    /**
     * Returns a list of neighbouring locations which are within the bound of the level
     * @returns {Vec2[]}
     */
    Player.prototype.getNearLocations = function () {
        return Player.neighbourhood.map(function (location) {
            return this.position.add(location);
        }.bind(this)).filter(function (location) {
            return this.world.level.withinBounds(location.x, location.y);
        }.bind(this));
    };

    /**
     * Nears neighbouring locations
     */
    Player.prototype.near = function () {
        var level = this.world.level;
        var ruleSet = this.world.nearRuleSet;

        this.getNearLocations().forEach(function (location) {
            var currentTerrainItem = level.get(location.x, location.y);

            var rule = ruleSet.getRuleFor(currentTerrainItem.id);
            if (rule) {
                level.set(
                    location.x,
                    location.y,
                    Items.collection[
                        resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);

                this.health += rule.healthDelta;
            }
        }.bind(this));
    };

	/**
	 * Leaves a location
	 */
	Player.prototype.leave = function () {
		var level = this.world.level;
		var ruleSet = this.world.leaveRuleSet;

		var currentTerrainItem = level.get(this.position.x, this.position.y);

		var rule = ruleSet.getRuleFor(currentTerrainItem.id);
		if (rule) {
			level.set(
				this.position.x,
				this.position.y,
				Items.collection[
					resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);
		}
	};

	/**
	 * Enters a new location
	 */
	Player.prototype.enter = function () {
		var inventory = this.world.inventory;
		var level = this.world.level;
		var ruleSet = this.world.enterRuleSet;

		var currentTerrainItem = level.get(this.position.x, this.position.y);

		var rule = ruleSet.getRuleFor(currentTerrainItem.id);
		if (rule) {
			level.set(
				this.position.x,
				this.position.y,
				Items.collection[
					resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);

			rule.outInventoryItems.forEach(function (item) {
				inventory.addItem(
					Items.collection[
						resolveItem(currentTerrainItem.id, -1, item.itemName)],
					item.quantity);
			});

			this.health += rule.healthDelta;

			if (rule.teleport) {
				this.teleport(rule.teleport.levelName, rule.teleport.x, rule.teleport.y);
			}

            if (rule.message) {
                this.world.textBubble.show().setText(rule.message);
            }
		}
	};

	/**
	 * Uses the current inventory item on the terrain unit that it's facing
	 */
	Player.prototype.use = function () {
		var inventory = this.world.inventory;
		var level = this.world.level;
		var ruleSet = this.world.useRuleSet;

		var currentInventoryItem = inventory.getCurrent();
		var facingPosition = this.getFacing();
		if (level.withinBounds(facingPosition.x, facingPosition.y)) {
			var currentTerrainItem = level.get(facingPosition.x, facingPosition.y);

			var rule = ruleSet.getRuleFor(currentTerrainItem.id, currentInventoryItem.id);
			if (rule) {
				if (!rule.consume ||
					(rule.consume &&
						inventory.has(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, currentInventoryItem.id)]))) {

					if (rule.consume) {
						inventory.consume(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, currentInventoryItem.id)]);
					}

					level.set(
						facingPosition.x,
						facingPosition.y,
						Items.collection[
							resolveItem(currentTerrainItem.id, currentInventoryItem.id, rule.outTerrainItem)]);

					rule.outInventoryItems.forEach(function (item) {
						inventory.addItem(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, item.itemName)],
							item.quantity);
					});

					this.health += rule.healthDelta;

					if (rule.teleport) {
						this.teleport(rule.teleport.levelName, rule.teleport.x, rule.teleport.y);
					}

                    if (rule.message) {
                        this.world.textBubble.show().setText(rule.message);
                    }
				}
			}
		}
	};

	/**
	 * Draws the player
	 */
	Player.prototype.draw = function (camera, tick) {
		this.sprite.drawAt(
			this.uiOffset.x +
			(this.position.x - camera.position.x /*+ Math.floor(camera.dimensions.x / 2)*/) * this.blockWidth,
			this.uiOffset.y +
			(this.position.y - camera.position.y /*+ Math.floor(camera.dimensions.y / 2)*/) * this.blockHeight
		);
	};

	return Player;
});

define('Inventory',[
		'Items',
		'Text',
		'con2d',
		'Util'
	], function (
		Items,
		Text,
		con2d,
		Util
	) {
	

	function Inventory(sizeMax, tileDimensions, uiOffset) {
		this.sizeMax = sizeMax; // unused
		this.tileDimensions = tileDimensions;
		this.uiOffset = uiOffset;
		this.inventory = {};
		this.arrangement = [];
		this.current = 0;
	}

	/**
	 * Draw the inventory
	 */
	Inventory.prototype.draw = function() {
		con2d.fillStyle = '#000000';
		con2d.fillRect(
			this.uiOffset.x, this.uiOffset.y,
			(this.arrangement.length + 1) * this.tileDimensions.x, this.tileDimensions.y);

		for (var i = 0; i < this.arrangement.length; i++) {
			// if null then skip
			var itemName = this.arrangement[i];
			var sprite = Items.collection[itemName];
			sprite.drawAt(
				this.uiOffset.x + i * this.tileDimensions.x,
				this.uiOffset.y
			);

			var text = '' + this.inventory[itemName];
			var offsetX = this.uiOffset.x + i * this.tileDimensions.x + this.tileDimensions.x - 4 - 16 * text.length;
			var offsetY = this.uiOffset.y + this.tileDimensions.y - 20;

			Text.drawAt(text, offsetX, offsetY);
		}

		con2d.lineWidth = 2;
		con2d.strokeStyle = '#FFF';
		con2d.strokeRect(
			this.uiOffset.x + this.current * this.tileDimensions.x + 1, this.uiOffset.y + 1,
			this.tileDimensions.x - 2, this.tileDimensions.y - 2
		);
		con2d.strokeStyle = '#000';
		con2d.strokeRect(
			this.uiOffset.x + this.current * this.tileDimensions.x + 2, this.uiOffset.y + 2,
			this.tileDimensions.x - 4, this.tileDimensions.y - 4
		);
	};

	/**
	 * Move the cursor left and right, changing the current inventory item
	 */
	Inventory.prototype.move = function(delta) {
		this.current += delta + this.arrangement.length;
		this.current %= this.arrangement.length;
	};

	/**
	 * Checks if an item is present in the inventory
	 * @param {Item} item
	 */
	Inventory.prototype.has = function(item) {
		return !!this.inventory[item.id];
	};

	/**
	 * Consumes a specified item from the inventory
	 * @param {Item} item
	 */
	Inventory.prototype.consume = function(item) {
		this.inventory[item.id]--;
		if (!this.inventory[item.id]) {
			Util.remove(this.arrangement, item.id);
			if (this.current === this.arrangement.length) {
				this.current--;
			}
		}
	};

	/**
	 * Adds an item in the inventory
	 * @param {Item} item
 	 * @param {number} quantity
	 */
	Inventory.prototype.addItem = function(item, quantity) {
		if (typeof this.inventory[item.id] === 'number') {
			if (this.inventory[item.id] === 0) {
				this.arrangement.push(item.id);
			}
			this.inventory[item.id] += quantity;
		} else {
			this.inventory[item.id] = quantity;
			this.arrangement.push(item.id);
		}
	};

	/**
	 * Gets the current selected inventory item
	 */
	Inventory.prototype.getCurrent = function() {
		var itemName = this.arrangement[this.current];
		return Items.collection[itemName];
	};

	return Inventory;
});

define('Set',[], function () {
	

	function Set() {
		this.elements = {};
	}

	Set.prototype.add = function(element) {
		this.elements[element] = true;
		return this;
	};

	Set.prototype.remove = function(element) {
		delete this.elements[element];
		return this;
	};

	Set.prototype.has = function(element) {
		return !!this.elements[element];
	};

	Set.prototype.keys = function() {
		return Object.keys(this.elements);
	};

	Set.prototype.copy = function() {
		var newSet = new Set();

		for (var key in this.elements) {
			newSet.add(key);
		}

		return newSet;
	};

	Set.prototype.union = function(that) {
		var newSet = this.copy();

		for (var key in that.elements) {
			newSet.add(key);
		}

		return newSet;
	};

	Set.prototype.intersection = function(that) {
		var newSet = new Set();

		for (var key in this.elements) {
			if (that.has(key)) {
				newSet.add(key);
			}
		}

		return newSet;
	};

	Set.prototype.difference = function(that) {
		var newSet = new Set();

		for (var key in this.elements) {
			if (!that.has(key)) {
				newSet.add(key);
			}
		}

		return newSet;
	};

	return Set;
});

define('rule/RuleSet',[
	'Set',
	'Util'
	], function (
		Set,
		Util
	) {
	

	function RuleSet(rules, setsByName) {
		this.rules = rules || [];
		this.setsByName = setsByName || {};
	}

	RuleSet.prototype.getRuleFor = function(inTerrainItem, inInventoryItem) {
		var firstMatchingRule = Util.findFirst(this.rules, function(rule) {

			var terrainMatch;
			if (Util.isCapitalized(rule.inTerrainItem)) {
				terrainMatch = this.setsByName[rule.inTerrainItem].has(inTerrainItem);
			} else {
				terrainMatch = rule.inTerrainItem === inTerrainItem;
			}

			if (!terrainMatch) {
				return false;
			}

			if (!inInventoryItem) {
				return terrainMatch;
			}

			var inventoryMatch;
			if (Util.isCapitalized(rule.inInventoryItem)) {
				inventoryMatch = this.setsByName[rule.inInventoryItem].has(inInventoryItem);
			} else {
				inventoryMatch = rule.inInventoryItem === inInventoryItem;
			}

			return terrainMatch && inventoryMatch;
		}.bind(this));

		if (firstMatchingRule) {
			return firstMatchingRule.element;
		}
	};

	return RuleSet;
});

define('Camera',[], function () {
	

	function Camera(position, dimensions) {
		this.position = position;
		this.dimensions = dimensions;
	}

	Camera.prototype.centerOn = function (x, y, levelWidth, levelHeight) {
		this.position.x = x - Math.floor(this.dimensions.x / 2);
		this.position.y = y - Math.floor(this.dimensions.y / 2);

		if (this.position.x < 0) {
			this.position.x = 0;
		} else if (this.position.x >= levelWidth - this.dimensions.x) {
			this.position.x = levelWidth - this.dimensions.x;
		}

		if (this.position.y < 0) {
			this.position.y = 0;
		} else if (this.position.y >= levelHeight - this.dimensions.y) {
			this.position.y = levelHeight - this.dimensions.y;
		}
	};

	return Camera;
});

define('TextBubble',[
    'Text',
    'Vec2',
    'con2d',
    'Util'
], function (
    Text,
    Vec2,
    con2d,
    Util
    ) {

	

	function TextBubble() {
        this.position = new Vec2(8, 8);
        this.visible = true;
        this.text = '';
        this.length = -Infinity;
        this.maxLength = 20;
        this.lines = [];
    }

    TextBubble.prototype.hide = function () {
        this.visible = false;
        return this;
	};

    TextBubble.prototype.show = function () {
        this.visible = true;
        return this;
    };

    TextBubble.prototype.draw = function () {
        if (!this.visible) { return; }
        // clear bubble
        con2d.fillStyle = '#007B90';
        con2d.fillRect(this.position.x, this.position.y, this.length * 16 + 8, this.lines.length * 18 + 8);

        // draw the text, line by line
        for (var i = 0; i < this.lines.length; i++) {
            Text.drawAt(this.lines[i], this.position.x + 4, this.position.y + i * 18 + 4);
        }
    };

    TextBubble.prototype.setText = function (text) {
        this.text = text.toUpperCase();

        this.lines = [];
        this.length = -Infinity;

        // chop text on multiple lines
        for (var i = 0; i < this.text.length; i += this.maxLength) {
            var line = this.text.substr(i, this.maxLength).trim();
            this.lines.push(line);

            if (line.length > this.length) {
                this.length = line.length;
            }
        }

        var boxWidth = this.length * 16 + 8;
        this.position.x = Math.floor((con2d.canvas.width - boxWidth) / 2);

        return this;
    };

	return TextBubble;
});

define('World',[
	'Player',
	'Inventory',
	'Items',
	'Vec2',
    'rule/RuleSet',
	'con2d',
	'Camera',
    'TextBubble'
	], function (
		Player,
		Inventory,
		Items,
		Vec2,
        RuleSet,
		con2d,
		Camera,
        TextBubble
	) {
	

	function World(
		playerSpritesByName,
		levelsByName,
		startLocation,
        nearRuleSet,
		leaveRuleSet,
		enterRuleSet,
		useRuleSet,
		tileDimensions,
		cameraDimensions
		) {
		this.player = new Player(this, playerSpritesByName, tileDimensions);
		this.startLocation = startLocation;
		this.levelsByName = levelsByName;
		this.level = null;
        this.nearRuleSet = nearRuleSet;
		this.leaveRuleSet = leaveRuleSet;
		this.enterRuleSet = enterRuleSet;
		this.useRuleSet = useRuleSet;
		this.tileDimensions = tileDimensions;

		this.camera = new Camera(new Vec2(0, 0), new Vec2(cameraDimensions.x, cameraDimensions.y));

		this.inventory = new Inventory(
			4,
			tileDimensions,
			new Vec2(0, this.tileDimensions.y * this.camera.dimensions.y + 8)
		);

		// adding an initial item in the inventory with which you obtain the rest of the items
		this.inventory.addItem(Items.collection.pickaxe, 9);

        this.textBubble = new TextBubble().hide();

        // animation related
		this.tick = 0;
		this.z = 0;
	}

	World.prototype.init = function () {
		con2d.canvas.width = this.tileDimensions.x * this.camera.dimensions.x; //this.levelsByName.entry.width;
		con2d.canvas.height = this.tileDimensions.y * (this.camera.dimensions.y + 1) + 8; //(this.levelsByName.entry.height + 1) + 8;

		this.player.init();
		this.initStartingLocation();

		con2d.fillStyle = '#000';
		con2d.fillRect(0, 0, con2d.canvas.width, con2d.canvas.height);

		this.camera.centerOn(this.player.position.x, this.player.position.y, this.level.width, this.level.height);
	};

	World.prototype.setLevel = function (levelName) {
		this.level = this.levelsByName[levelName];
	};

	World.prototype.initStartingLocation = function () {
		this.level = this.levelsByName[this.startLocation.levelName];
		this.player.setPosition(this.startLocation.x, this.startLocation.y);
	};

	World.prototype.draw = function () {
		this.level.draw(this.camera, this.tick);
		this.inventory.draw();
		this.player.draw(this.camera, this.tick);
        this.textBubble.draw();
	};

	World.prototype.update = function () {
		this.z++; // should count deltaTime
		if (this.z >= 20) {
			this.z = 0;
			this.tick = 1 - this.tick;
		}
	};

	return World;
});

define('Item',[], function() {
	

	function Item(id, name, sprites, blocking) {
		this.id = id;
		this.name = name;
		this.sprites = sprites;
		this.blocking = blocking;
	}

	Item.prototype.drawAt = function(x, y, tick) {
		if (tick !== undefined) {
			tick = Math.min(tick, this.sprites.length - 1);
		} else {
			tick = 0;
		}
		//tick = tick || (this.sprites.length - 1);
		this.sprites[tick].drawAt(x, y);
	};

	return Item;
});

define('rule/NearRule',[], function() {
	

	function NearRule(
		inTerrainItem,
		outTerrainItem,
		healthDelta
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
		this.healthDelta = healthDelta;
	}

	return NearRule;
});

define('rule/LeaveRule',[], function() {
	

	function LeaveRule(
		inTerrainItem,
		outTerrainItem
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
	}

	return LeaveRule;
});

define('rule/EnterRule',[], function() {
	

	function EnterRule(
		inTerrainItem,
		outTerrainItem,
		outInventoryItems,
		healthDelta,
		teleport,
		message
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
		this.outInventoryItems = outInventoryItems;
		this.healthDelta = healthDelta;
		this.teleport = teleport;
		this.message = message;
	}

	return EnterRule;
});

define('rule/UseRule',[], function() {
	

	function UseRule(
		inTerrainItem,
		inInventoryItem,
		outTerrainItem,
		outInventoryItems,
		consume,
		healthDelta,
		teleport,
		message
	) {
		this.inTerrainItem = inTerrainItem;
		this.inInventoryItem = inInventoryItem;
		this.outTerrainItem = outTerrainItem;
		this.outInventoryItems = outInventoryItems;
		this.consume = consume;
		this.healthDelta = healthDelta;
		this.teleport = teleport;
		this.message = message;
	}

	return UseRule;
});

define('Level',[
	'Items',
	'Vec2'
	], function(
		Items,
		Vec2
	) {
	

	function Level(data, levelDimensions, tileDimensions, uiOffset) {
		this.data = data;
		this.width = levelDimensions.x;
		this.height = levelDimensions.y;
		this.blockWidth = tileDimensions.x;
		this.blockHeight = tileDimensions.y;
		this.uiOffset = uiOffset || new Vec2(0, 0);
	}

	Level.prototype.get = function(x, y) {
		return this.data[y][x];
	};

	Level.prototype.set = function(x, y, item) {
		this.data[y][x] = item;
		return this;
	};

	Level.prototype.draw = function(camera, tick) {
		for (var i = 0; i < camera.dimensions.y; i++) {
			for (var j = 0; j < camera.dimensions.x; j++) {
				this.data[i + camera.position.y][j + camera.position.x].drawAt(
					this.uiOffset.x + j * this.blockWidth,
					this.uiOffset.y + i * this.blockHeight,
					tick
				);
			}
		}
	};

	Level.prototype.withinBounds = function(x, y) {
		return x >= 0 && x < this.width && y >= 0 && y < this.height;
	};

	return Level;
});

define('generator/Generator',[
	'generator/SpriteSheetGenerator',
	'Util',
	'World',
	'Item',
	'Items',
	'Set',
    'rule/NearRule',
	'rule/LeaveRule',
	'rule/EnterRule',
	'rule/UseRule',
	'rule/RuleSet',
	'Vec2',
	'Level'
	], function (
		SpriteSheetGenerator,
		Util,
		World,
		Item,
		Items,
		Set,
        NearRule,
		LeaveRule,
		EnterRule,
		UseRule,
		RuleSet,
		Vec2,
		Level
	) {
	

	var Generator = {};

	Generator.generate = function (spec) {
		var params = Generator.generate.params(spec.params, spec.levels);

		var playerSpritesByName = Generator.generate.player(spec.player, spec.colors, params.scale);

		var itemsByName = Generator.generate.objects(spec.objects, spec.colors, params.scale);
		Items.collection = itemsByName;

		var setsByName = Generator.generate.sets(spec.sets);
        var nearRuleSet = Generator.generate.nearRules(spec.nearRules, setsByName);
		var leaveRuleSet = Generator.generate.leaveRules(spec.leaveRules, setsByName);
		var enterRuleSet = Generator.generate.enterRules(spec.enterRules, setsByName);
		var useRuleSet = Generator.generate.useRules(spec.useRules, setsByName);

		// sort of hacky
		var tileDimensions = playerSpritesByName.left.end.sub(playerSpritesByName.left.start);

		var levelsByName = Generator.generate.levels(spec.levels, spec.legend, tileDimensions);

		var world = new World(
			playerSpritesByName,
			levelsByName,
			params.startLocation,
            nearRuleSet,
			leaveRuleSet,
			enterRuleSet,
			useRuleSet,
			tileDimensions,
			params.camera
		);

		return world;
	};

	Generator.generate.params = function (paramSpec, levelsSpec) {
		// needs rewriting using some variant of deepExend
		return {
			camera: {
				x: +paramSpec.camera[0].s || 7,
				y: +paramSpec.camera[1].s || 7
			},
			scale: +paramSpec.scale[0].s || 8,
			startLocation: {
				x: +paramSpec.start_location[0].s || 2,
				y: +paramSpec.start_location[1].s || 2,
				levelName: paramSpec.start_location[2].s || (levelsByName.entry ? 'entry' : Object.keys(levelsByName)[0])
			}
		};
	};

	Generator.generate.player = function (playerSpec, colorSpec, scale) {
		var namedPlayerSprites = SpriteSheetGenerator.generate(playerSpec, colorSpec, scale);
		var playerSpritesByName = Util.arrayToObject(namedPlayerSprites, 'name', 'sprite');
		return playerSpritesByName;
	};

	Generator.generate.objects = function (objectsSpec, colorSpec, scale) {
		var stringedObjects = Util.mapOnKeys(objectsSpec, function(object) {
			return object.lines;
		});
		var namedSprites = SpriteSheetGenerator.generate(stringedObjects, colorSpec, scale);

		function processSpriteName(nam) {
			var separator = nam.lastIndexOf(':');
			if (separator === -1) {
				return {
					name: nam,
					frame: 0
				};
			} else {
				return {
					name: nam.substr(0, separator),
					frame: +nam.substr(separator + 1)
				};
			}
		}

		var groupedSprites = Util.groupBy(namedSprites, function (namedSprite) {
			var frameAndName = processSpriteName(namedSprite.name);
			return frameAndName.name;
		});

		var namedSpriteGroups = Util.objectToArray(groupedSprites, 'groupName', 'namedSprites');

		var itemsByName = {};

		namedSpriteGroups.forEach(function (namedSpriteGroup) {
			var sortedSprites = namedSpriteGroup.namedSprites.map(function (namedSprite) {
				var nameAndFrame = processSpriteName(namedSprite.name);
				return {
					sprite: namedSprite.sprite,
					name: nameAndFrame.name,
					frame: nameAndFrame.frame
				};
			}).sort(function (a, b) {
				return a.frame - b.frame;
			});

			var sprites = sortedSprites.map(function (namedSprite) {
				return namedSprite.sprite;
			});

			itemsByName[namedSpriteGroup.groupName] = new Item(
				namedSpriteGroup.groupName,
				Util.capitalize(namedSpriteGroup.groupName),
				sprites,
				objectsSpec[namedSpriteGroup.groupName].blocking
			);
		});

		return itemsByName;
	};

	Generator.generate.sets = function(spec) {
		var ops = {
			'or': Set.prototype.union,
			'and': Set.prototype.intersection,
			'minus': Set.prototype.difference
		};

		var setsByName = {};

		spec.forEach(function(setDefinition) {
			var set;

			if (setDefinition.elements) {
				set = new Set();

				setDefinition.elements.forEach(function (element) {
					set.add(element);
				});
			} else {
				var operand1 = setsByName[setDefinition.operand1.s];
				var operand2 = setsByName[setDefinition.operand2.s];
				var operator = ops[setDefinition.operator.s];

				set = operator.call(operand1, operand2);
			}

			setsByName[setDefinition.name] = set;
		});

		return setsByName;
	};

    Generator.generate.nearRules = function(rulesSpec, setsByName) {
        var rules = rulesSpec.map(function (ruleSpec) {
            var inTerrainItemName = ruleSpec.inTerrainItemName.s;
            var outTerrainItemName = ruleSpec.outTerrainItemName.s;

            var healthDelta = 0;
            if (ruleSpec.heal) {
                healthDelta += +ruleSpec.heal.s;
            }
            if (ruleSpec.hurt) {
                healthDelta -= +ruleSpec.hurt.s;
            }

            return new NearRule(
                inTerrainItemName,
                outTerrainItemName,
                healthDelta
            );
        });

        return new RuleSet(rules, setsByName);
    };

	Generator.generate.leaveRules = function(rulesSpec, setsByName) {
		var rules = rulesSpec.map(function (ruleSpec) {
			var inTerrainItemName = ruleSpec.inTerrainItemName.s;
			var outTerrainItemName = ruleSpec.outTerrainItemName.s;

			return new LeaveRule(
				inTerrainItemName,
				outTerrainItemName
			);
		});

		return new RuleSet(rules, setsByName);
	};

	Generator.generate.enterRules = function(rulesSpec, setsByName) {
		var rules = rulesSpec.map(function (ruleSpec) {
			var inTerrainItemName = ruleSpec.inTerrainItemName.s;
			var outTerrainItemName = ruleSpec.outTerrainItemName.s;

			// some don't give back anything
			var outInventoryItems;

			if (ruleSpec.give) {
				outInventoryItems = ruleSpec.give.map(function (entry) {
					return {
						itemName: entry.itemName.s,
						quantity: +entry.quantity.s
					};
				});
			} else {
				outInventoryItems = [];
			}

			var healthDelta = 0;
			if (ruleSpec.heal) {
				healthDelta += +ruleSpec.heal.s;
			}
			if (ruleSpec.hurt) {
				healthDelta -= +ruleSpec.hurt.s;
			}

			var teleport;

			if (ruleSpec.teleport) {
				teleport = {
					x: +ruleSpec.teleport.x.s,
					y: +ruleSpec.teleport.y.s,
					levelName: ruleSpec.teleport.levelName.s
				};
			}

			var message;
			if (ruleSpec.message) {
				message = ruleSpec.message.s;
			}

			return new EnterRule(
				inTerrainItemName,
				outTerrainItemName,
				outInventoryItems,
				healthDelta,
				teleport,
				message
			);
		});

		return new RuleSet(rules, setsByName);
	};

	Generator.generate.useRules = function(rulesSpec, setsByName) {
		var rules = rulesSpec.map(function (ruleSpec) {
			var inTerrainItemName = ruleSpec.inTerrainItemName.s;
			var inInventoryItemName = ruleSpec.inInventoryItemName.s;
			var outTerrainItemName = ruleSpec.outTerrainItemName.s;

			// some don't give back anything
			var outInventoryItems;

			if (ruleSpec.give) {
				outInventoryItems = ruleSpec.give.map(function (entry) {
					return {
						itemName: entry.itemName.s,
						quantity: +entry.quantity.s
					};
				});
			} else {
				outInventoryItems = [];
			}

			var consume = !!ruleSpec.consume;

			var healthDelta = 0;
			if (ruleSpec.heal) {
				healthDelta += +ruleSpec.heal.s;
			}
			if (ruleSpec.hurt) {
				healthDelta -= +ruleSpec.hurt.s;
			}

			var teleport;

			if (ruleSpec.teleport) {
				teleport = {
					x: +ruleSpec.teleport.x.s,
					y: +ruleSpec.teleport.y.s,
					levelName: ruleSpec.teleport.levelName.s
				};
			}

			var message;
			if (ruleSpec.message) {
				message = ruleSpec.message.s;
			}

			return new UseRule(
				inTerrainItemName,
				inInventoryItemName,
				outTerrainItemName,
				outInventoryItems,
				consume,
				healthDelta,
				teleport,
				message
			);
		});

		return new RuleSet(rules, setsByName);
	};

	Generator.generate.levels = function(levelsSpec, legendSpec, tileDimensions) {
		var levelsByName = {};

		var namedStringedLevels = Util.objectToArray(levelsSpec, 'levelName', 'lines');

		namedStringedLevels.forEach(function (namedStringedLevel) {
			var data = namedStringedLevel.lines.map(function (line) {
				return line.s.split('').map(function (char) {
					var itemName = legendSpec[char];
					return Items.collection[itemName];
				});
			});

			var levelDimensions = new Vec2(data[0].length, data.length);

			levelsByName[namedStringedLevel.levelName] = new Level(data, levelDimensions, tileDimensions);
		});

		return levelsByName;
	};

	return Generator;
});

define('Game',[
	'SystemBus',
	'World',
	'generator/Generator'
	], function(
		SystemBus,
		World,
		Generator
	) {
	

	function Game() {
		this.world = null;
		this.requestId = null;
	}

	Game.prototype.init = function (tree) {
		this.world = Generator.generate(tree);
		this.world.init();
	};

	Game.prototype.start = function () {
		var loop = function () {
			this.world.update();
			this.world.draw();
			this.requestId = window.requestAnimationFrame(loop);
		}.bind(this);

		loop();
	};

	Game.prototype.cleanup = function () {
		window.cancelAnimationFrame(this.requestId);
		SystemBus.reset();
	};

	return Game;
});

define('tokenizer/TokenCoords',[], function () {
	

	function TokenCoords(line, col) {
		this.line = line;
		this.col = col;
	}

	TokenCoords.prototype.toString = function() {
		return '(line: ' + this.line + ', col: ' + this.col + ')';
	};

	return TokenCoords;
});

define('tokenizer/IterableString',[
	'tokenizer/TokenCoords'
	], function(
		TokenCoords
	) {
	

	function IterableString(s) {
		this.s = s;
		this.pointer = 0;
		this.marker = 0;

		this.line = 0;
		this.col = 0;
	}

	IterableString.prototype.adv = function() {
		if(this.s.charAt(this.pointer) == '\n') {
			this.line++;
			this.col = 0;
		}
		else this.col++;

		this.pointer++;
	};

	IterableString.prototype.setMarker = function() {
		this.marker = this.pointer;
	};

	IterableString.prototype.cur = function() {
		return this.s.charAt(this.pointer);
	};

	IterableString.prototype.next = function() {
		return this.s.charAt(this.pointer + 1);
	};

	IterableString.prototype.hasNext = function() {
		return this.pointer < this.s.length;
	};

	IterableString.prototype.getMarked = function() {
		return this.s.substring(this.marker, this.pointer);
	};

	IterableString.prototype.match = function(str) {
		var substr = this.s.substring(this.pointer, this.pointer + str.length);
		if(substr == str) {
			this.pointer += str.length;

			var count = str.match(/\n/g).length;
			if(count > 0) {
				this.line += count;
				this.col = str.length - str.lastIndexOf('\n');
			}
			else this.col += str.length;

			return true;
		}
		return false;
	};

	IterableString.prototype.getCoords = function() {
		return new TokenCoords(this.line, this.col);
	};

	return IterableString;
});

define('tokenizer/TokEnd',[], function () {
	

	function TokEnd(coords) {
		this.coords = coords;
	}

	TokEnd.prototype.match = function(that) {
		return that instanceof TokEnd;
	};

	TokEnd.prototype.toString = function() {
		return "END";
	};

	TokEnd.prototype.toHTML = function(c) {
		return '';
	};

	return TokEnd;
});

define('tokenizer/TokNum',[], function () {
	

	function TokNum(s, coords) {
		this.n = parseFloat(s);
		this.coords = coords;
	}

	TokNum.prototype.match = function(that) {
		return that instanceof TokNum;
	};

	TokNum.prototype.toString = function() {
		return "Num(" + this.n + ")";
	};

	TokNum.prototype.toHTML = function(c) {
		return '<span style="color:' + c.num + '">' + this.n + '</span>';
	};

	return TokNum;
});

define('tokenizer/TokIdentifier',[], function () {
	

	function TokIdentifier(s, coords) {
		this.s = s;
		this.coords = coords;
	}

	TokIdentifier.prototype.match = function (that) {
		return that instanceof TokIdentifier;
	};

	TokIdentifier.prototype.toString = function () {
		return "Identifier(" + this.s + ' ' + this.coords + ")";
	};

	TokIdentifier.prototype.toHTML = function (c) {
		return '<span style="color:' + c.identifier + '">' + this.s + '</span>';
	};

	return TokIdentifier;
});

define('tokenizer/TokStr',[], function () {
	

	function TokStr(s, coords) {
		this.s = s;
		this.coords = coords;
	}

	TokStr.prototype.match = function(that) {
		return that instanceof TokStr;
	};

	TokStr.prototype.toString = function() {
		return "Str(" + this.s + ")";
	};

	TokStr.prototype.toHTML = function(c) {
		return '<span style="color:' + c.str + '">\'' + this.s + '\'</span>';
	};

	return TokStr;
});

define('tokenizer/TokLPar',[], function () {
	

	function TokLPar(coords) {
		this.coords = coords;
	}

	TokLPar.prototype.match = function(that) {
		return that instanceof TokLPar;
	};

	TokLPar.prototype.toString = function() {
		return "LPar";
	};

	TokLPar.prototype.toHTML = function(c) {
		return '<span style="color:' + c.par + '">(</span>';
	};

	return TokLPar;
});

define('tokenizer/TokRPar',[], function () {
	

	function TokRPar(coords) {
		this.coords = coords;
	}

	TokRPar.prototype.match = function(that) {
		return that instanceof TokRPar;
	};

	TokRPar.prototype.toString = function() {
		return "RPar";
	};

	TokRPar.prototype.toHTML = function(c) {
		return '<span style="color:' + c.par + '">)</span>';
	};

	return TokRPar;
});

define('tokenizer/TokKeyword',[], function () {
	

	function TokKeyword(s, coords) {
		this.s = s;
		this.coords = coords;
	}

	TokKeyword.prototype.match = function(that) {
		return that === this.s;
	};

	TokKeyword.prototype.toString = function() {
		return "Keyword(" + this.s + ' ' + this.coords + ")";
	};

	TokKeyword.prototype.toHTML = function(c) {
		return '<span style="font-weight: 900;color:' + c.keyword + '">' + this.s + '</span>';
	};

	return TokKeyword;
});

define('tokenizer/TokWhitespace',[], function () {
	

	function TokWhitespace(s) {
		this.s = s;
	}

	TokWhitespace.prototype.match = function(that) {
		return that instanceof TokWhitespace;
	};

	TokWhitespace.prototype.toString = function() {
		return 'Whitespace(' + this.s + ')';
	};

	TokWhitespace.prototype.toHTML = function(c) {
		if(this.s == '\n') return '<br />';
		else if(this.s == ' ') return '<span style="color:' + c.whitespace + '">&nbsp;</span>';
		else return '<span style="color:' + c.whitespace + '">' + this.s + '</span>';
	};

	return TokWhitespace;
});

define('tokenizer/TokCommSL',[], function () {
	

	function TokCommSL(s, coords) {
		this.s = s;
		this.coords = coords;
	}

	TokCommSL.prototype.toString = function() {
		return "CommSL(" + this.s + ")";
	};

	TokCommSL.prototype.toHTML = function(c) {
		return '<span style="color:' + c.commSL + '">' + this.s + '</span><br />';
	};

	return TokCommSL;
});

define('tokenizer/TokCommML',[], function () {
	

	function TokCommML(s, coords) {
		this.s = s;
		this.coords = coords;
	}

	TokCommML.prototype.toString = function() {
		return 'CommML(' + this.s + ')';
	};

	TokCommML.prototype.toHTML = function(c) {
		return '<span style="color:' + c.commML + '">' + this.s + '</span>';
	};

	return TokCommML;
});

define('tokenizer/TokComma',[], function () {
	

	function TokComma(coords) {
		this.coords = coords;
	}

	TokComma.prototype.match = function(that) {
		return that instanceof TokComma;
	};

	TokComma.prototype.toString = function() {
		return 'Comma';
	};

	TokComma.prototype.toHTML = function(c) {
		return '<span style="color:' + c.comma + '">)</span>';
	};

	return TokComma;
});

define('tokenizer/TokSemicolon',[], function () {
	

	function TokSemicolon(coords) {
		this.coords = coords;
	}

	TokSemicolon.prototype.match = function(that) {
		return that instanceof TokSemicolon;
	};

	TokSemicolon.prototype.toString = function() {
		return 'Semicolon';
	};

	TokSemicolon.prototype.toHTML = function(c) {
		return '<span style="color:' + c.semicolon + '">)</span>';
	};

	return TokSemicolon;
});

define('tokenizer/TokArrow',[], function () {
	

	function TokArrow(coords) {
		this.coords = coords;
	}

	TokArrow.prototype.match = function(that) {
		return that instanceof TokArrow;
	};

	TokArrow.prototype.toString = function() {
		return 'Arrow';
	};

	TokArrow.prototype.toHTML = function(c) {
		return '<span style="color:' + c.arrow + '">)</span>';
	};

	return TokArrow;
});

define('tokenizer/TokAssignment',[], function () {
	

	function TokAssignment(coords) {
		this.coords = coords;
	}

	TokAssignment.prototype.match = function(that) {
		return that instanceof TokAssignment;
	};

	TokAssignment.prototype.toString = function() {
		return 'Assignment';
	};

	TokAssignment.prototype.toHTML = function(c) {
		return '<span style="color:' + c.assignment + '">)</span>';
	};

	return TokAssignment;
});

define('tokenizer/TokNewLine',[], function () {
	

	function TokNewLine(coords) {
		this.coords = coords;
	}

	TokNewLine.prototype.match = function (that) {
		return that instanceof TokNewLine;
	};

	TokNewLine.prototype.toString = function () {
		return 'TokNewLine';
	};

	TokNewLine.prototype.toHTML = function (c) {
		return '<span style="color:' + c.par + '">)</span>';
	};

	return TokNewLine;
});

define('tokenizer/Tokenizer',[
	'tokenizer/IterableString',
	'tokenizer/TokEnd',
	'tokenizer/TokNum',
	'tokenizer/TokIdentifier',
	'tokenizer/TokStr',
	'tokenizer/TokLPar',
	'tokenizer/TokRPar',
	'tokenizer/TokKeyword',
	'tokenizer/TokWhitespace',
	'tokenizer/TokCommSL',
	'tokenizer/TokCommML',
	'tokenizer/TokComma',
	'tokenizer/TokSemicolon',
	'tokenizer/TokArrow',
	'tokenizer/TokAssignment',
	'tokenizer/TokNewLine',
	'tokenizer/TokenCoords'
	], function (
		IterableString,
		TokEnd,
		TokNum,
		TokIdentifier,
		TokStr,
		TokLPar,
		TokRPar,
		TokKeyword,
		TokWhitespace,
		TokCommSL,
		TokCommML,
		TokComma,
		TokSemicolon,
		TokArrow,
		TokAssignment,
		TokNewLine,
		TokenCoords
	) {
	

	var Tokenizer = {};

	Tokenizer.chop = function(s, ws, comm) {
		ws = !!ws;
		comm = !!comm;

		var str = new IterableString(s + ' ');
		var tok = [];

		while(str.hasNext()) {
			var c = str.cur();

			if(c == "'") {
				tok.push(Tokenizer.chop.strs(str));
			}
			else if(c == '"') {
				tok.push(Tokenizer.chop.strd(str));
			}
			else if(c == '/') {
				var n = str.next();
				if(n == '/') {
					var tmp = Tokenizer.chop.commsl(str);
					if(comm) tok.push(tmp);
				}
				else if(n == '*') {
					var tmp = Tokenizer.chop.commml(str);
					if(comm) tok.push(tmp);
				}
				else {
					tok.push(Tokenizer.chop.alphanum(str));
				}
			}
			else if(c == '(') {
				tok.push(new TokLPar(str.getCoords()));
				str.adv();
			}
			else if(c == ')') {
				tok.push(new TokRPar(str.getCoords()));
				str.adv();
			}
			else if(c == '=') {
				tok.push(new TokAssignment(str.getCoords()));
				str.adv();
			}
			else if(c == ',') {
				tok.push(new TokComma(str.getCoords()));
				str.adv();
			}
			else if(c == ';') {
				tok.push(new TokSemicolon(str.getCoords()));
				str.adv();
			}
			else if(c === '-' && str.next() === '>') {
				tok.push(new TokArrow(str.getCoords()));
				str.adv();
				str.adv();
			}
			else if(c > ' ' && c <= '~') {
				tok.push(Tokenizer.chop.alphanum(str));
			}
			else if (c === '\n') {
				tok.push(new TokNewLine(str.getCoords()));
				str.adv();
			} else {
				var tmp = Tokenizer.chop.whitespace(str);
				if(ws) tok.push(tmp);
			}
		}

		tok.push(new TokEnd(str.getCoords()));

		return tok;
	};

	Tokenizer.chop.strUnescape = function(s) {
		return s.replace(/\\\'/g, '\'')
				.replace(/\\\"/g, '\"')
				.replace(/\\\\/g, '\\')
				.replace(/\\\n/g, '\n');
	};

	Tokenizer.chop.strs = function(str) {
		var coords = str.getCoords();
		str.setMarker();
		str.adv();

		while (true) {
			if(str.cur() == '\\') str.adv();
			else if(str.cur() == "'") { str.adv(); return new TokStr(Tokenizer.chop.strUnescape(str.getMarked().slice(1, -1)), coords); }
			else if(str.cur() == '\n' || !str.hasNext()) throw 'String did not end well ' + str.getCoords();
			str.adv();
		}
	};

	Tokenizer.chop.strd = function(str) {
		var coords = str.getCoords();
		str.setMarker();
		str.adv();

		while (true) {
			if(str.cur() == '\\') str.adv();
			else if(str.cur() == '"') { str.adv(); return new TokStr(Tokenizer.chop.strUnescape(str.getMarked().slice(1, -1)), coords); }
			else if(str.cur() == '\n' || !str.hasNext()) throw 'String did not end well ' + str.getCoords();;
			str.adv();
		}
	};

	Tokenizer.chop.num = function(str) {
		var coords = str.getCoords();
		str.setMarker();

		var tmp = str.cur();
		while (tmp >= '0' && tmp <= '9') {
			str.adv();
			tmp = str.cur();
		}

		if (str.cur() == '.') {
			str.adv();
			var tmp = str.cur();
			while (tmp >= '0' && tmp <= '9') {
				str.adv();
				tmp = str.cur();
			}
		}

		if (') \n\t'.indexOf(str.cur()) == -1) throw "Unexpected character '" + str.cur() + "' after \"" + str.getMarked() + '" ' + str.getCoords();

		return new TokNum(str.getMarked(), coords);
	};

	Tokenizer.chop.commml = function(str) {
		var coords = str.getCoords();
		str.setMarker();
		str.adv();
		str.adv();

		while (true) {
			if (str.cur() == '*' && str.next() == '/') {
				str.adv();
				str.adv();
				return new TokCommML(str.getMarked(), coords);
			}
			else if (str.hasNext()) {
				str.adv();
			}
			else throw 'Multiline comment not properly terminated ' + str.getCoords();;
		}
	};

	Tokenizer.chop.commsl = function(str) {
		var coords = str.getCoords();
		str.setMarker();
		str.adv();
		str.adv(2);

		while (true) {
			if(str.cur() == '\n' || !str.hasNext()) {
				str.adv();
				return new TokCommSL(str.getMarked(), coords);
			}
			else str.adv();
		}
	};

	Tokenizer.chop.alphanum = function(str) {
		var coords = str.getCoords();
		str.setMarker();

		var tmp = str.cur();
		while(tmp > ' ' && tmp <= '~' && (tmp != '(' && tmp != ')')) {
			str.adv();
			tmp = str.cur();
		}

		tmp = str.getMarked();

		if(Tokenizer.chop.alphanum.reserved.indexOf(tmp) != -1) return new TokKeyword(tmp, coords);
		else return new TokIdentifier(tmp, coords);
	};

	Tokenizer.chop.alphanum.reserved = [
		'PARAM', 'COLORS', 'PLAYER', 'OBJECTS', 'SETS', 'NEARRULES', 'LEAVERULES', 'ENTERRULES', 'USERULES', 'LEGEND', 'LEVELS',
		'rgb',
		'blocking',
		'or', 'and', 'minus',
		'consume', 'give', 'heal', 'hurt', 'teleport', 'message'
	];

	Tokenizer.chop.whitespace = function(str) {
		var tmp = str.cur();
		str.adv();
		return new TokWhitespace(tmp);
	};

	return Tokenizer;
});

define('ParserError',[], function() {
	

	function ParserError(message, line, column) {
	  this.name = 'ParserError';
	  this.message = message || 'Default Message';
	  this.line = line;
	  this.column = column;
	}

	ParserError.prototype = Object.create(Error.prototype);
	ParserError.prototype.constructor = ParserError;

	return ParserError;
});
define('parser/TokenList',['ParserError'], function(ParserError) {
	

	function TokenList(token) {
		this.token = token;
		this.pointer = 0;
	}

	TokenList.prototype.match = function(token) {
		return this.token[this.pointer].match(token);
	};

	TokenList.prototype.matchSeq = function(token) {
		for(var i = 0; i < token.length; i++)
			if(!(this.token[this.pointer + i].match(token[i])))
				return false;

		return true;
	};

	TokenList.prototype.matchAnySeq = function(token) {
		for(var i = 0; i < token.length; i++)
			if(this.matchSeq(token[i]))
				return true;

		return false;
	};

	TokenList.prototype.expect = function(token, exMessage) {
		if(this.match(token)) {
			this.adv();
		} else {
			throw new ParserError(
				exMessage /*+ ' instead got ' + this.cur()*/,
				this.cur().coords.line,
				this.cur().coords.col
			);
		}
	};

	TokenList.prototype.adv = function() {
		if(this.pointer >= this.token.length)
			throw 'TokenList: You\'ve not enough tokens!';

		this.pointer++;
	};

	TokenList.prototype.next = function() {
		this.adv();
		return this.token[this.pointer - 1];
	};

	TokenList.prototype.cur = function() {
		return this.token[this.pointer];
	};

	TokenList.prototype.past = function() {
		return this.token[this.pointer - 1];
	};

	TokenList.prototype.toString = function() {
		var ret = 'TokenList(pointer: ' + this.pointer
						+ ', content: [' + this.token.join(', ') + ']';
		return ret;
	};

	return TokenList;
});

define('parser/RDP',[
	'tokenizer/IterableString',
	'tokenizer/TokEnd',
	'tokenizer/TokNum',
	'tokenizer/TokIdentifier',
	'tokenizer/TokStr',
	'tokenizer/TokLPar',
	'tokenizer/TokRPar',
	'tokenizer/TokKeyword',
	'tokenizer/TokWhitespace',
	'tokenizer/TokCommSL',
	'tokenizer/TokCommML',
	'tokenizer/TokComma',
	'tokenizer/TokSemicolon',
	'tokenizer/TokArrow',
	'tokenizer/TokNewLine',
	'tokenizer/TokAssignment',
	'tokenizer/TokenCoords',
	'parser/TokenList'
	], function (
		IterableString,
		TokEnd,
		TokNum,
		TokIdentifier,
		TokStr,
		TokLPar,
		TokRPar,
		TokKeyword,
		TokWhitespace,
		TokCommSL,
		TokCommML,
		TokComma,
		TokSemicolon,
		TokArrow,
		TokNewLine,
		TokAssignment,
		TokenCoords,
		TokenList
	) {
		

	var RDP = {};

	RDP.errPref = 'Parsing exception: ';

	RDP.parse = function(tokenArray) {
		var tokens = new TokenList(tokenArray);

		var params = RDP.tree.params(tokens);
		var colors = RDP.tree.colors(tokens);
		var player = RDP.tree.player(tokens);
		var objects = RDP.tree.objects(tokens);
		var sets = RDP.tree.sets(tokens);

        if (tokens.match('NEARRULES')) {
            var nearRules = RDP.tree.nearRules(tokens);
        }
        if (tokens.match('LEAVERULES')) {
		    var leaveRules = RDP.tree.leaveRules(tokens);
        }
        if (tokens.match('ENTERRULES')) {
		    var enterRules = RDP.tree.enterRules(tokens);
        }
        // use rules must always exist
		var useRules = RDP.tree.useRules(tokens);

        var legend = RDP.tree.legend(tokens);
		var levels = RDP.tree.levels(tokens);

		//tokens.expect(new TokEnd(), 'RDP: expression not properly terminated');

		return {
			params: params,
			colors: colors,
			player: player,
			objects: objects,
			sets: sets,
            nearRules: nearRules || [],
			leaveRules: leaveRules || [],
			enterRules: enterRules || [],
			useRules: useRules,
			legend: legend,
			levels: levels
		};
	};

	RDP.tree = {};

	RDP.tree.num = new TokNum();
	RDP.tree.identifier = new TokIdentifier();
	RDP.tree.str = new TokStr();

	RDP.tree.lPar = new TokLPar();
	RDP.tree.rPar = new TokRPar();

	RDP.tree.comma = new TokComma();
	RDP.tree.semicolon = new TokSemicolon();
	RDP.tree.arrow = new TokArrow();
	RDP.tree.newLine = new TokNewLine();
	RDP.tree.assignment = new TokAssignment();

	RDP.tree.end = new TokEnd();

	RDP.tree.chompNL = function(tokens, exMessage) {
		tokens.expect(RDP.tree.newLine, exMessage);
		while (tokens.match(RDP.tree.newLine)) {
			tokens.adv();
		}
	};

	RDP.tree.params = function(tokens) {
		tokens.expect('PARAM', 'Specification must start with PARAM');
		RDP.tree.chompNL(tokens, 'Expected new line after PARAM');

		var params = {};

		while (!tokens.match('COLORS')) {
			tokens.expect(RDP.tree.identifier, '');
			var paramName = tokens.past().s;
			if (params[paramName]) {
				throw 'Param definition ' + paramName + ' already declared';
			}

			params[paramName] = [];

			while (tokens.match(RDP.tree.identifier)) {
				tokens.adv();
				params[paramName].push(tokens.past());
			}

			RDP.tree.chompNL(tokens, 'Expect new line between param declarations');
		}

		return params;
	};

	RDP.tree.colors = function(tokens) {
		tokens.expect('COLORS', 'Expected COLORS section after PARAM');
		RDP.tree.chompNL(tokens, 'Expected new line after COLORS');

		var colors = {};

		while (!tokens.match('PLAYER')) {
			tokens.expect(RDP.tree.identifier, '');
			var colorChar = tokens.past().s;
			if (colors[colorChar]) {
				throw 'Color binding ' + colorChar + ' already declared';
			}

			tokens.expect('rgb', 'Expected rgb');

			tokens.expect(RDP.tree.identifier, 'Expected red value');
			var r = tokens.past().s;

			tokens.expect(RDP.tree.identifier, 'Expected blue value');
			var g = tokens.past().s;

			tokens.expect(RDP.tree.identifier, 'Expected green value');
			var b = tokens.past().s;

			colors[colorChar] = 'rgb(' + r + ', ' + g + ', ' + b + ')';

			RDP.tree.chompNL(tokens, 'Expect new line between color bindings');
		}

		return colors;
	};

	RDP.tree.player = function(tokens) {
		tokens.expect('PLAYER', 'Expected PLAYER section after COLORS');
		RDP.tree.chompNL(tokens, 'Expected new line after PLAYER');


		var playerFrames = {};

		while (!tokens.match('OBJECTS')) {
			// name
			tokens.expect(RDP.tree.identifier, 'Expected at least one player frame');
			var playerFrameName = tokens.past().s;
			if (playerFrames[playerFrameName]) {
				throw playerFrameName + ' already declared';
			}
			playerFrames[playerFrameName] = [];

			RDP.tree.chompNL(tokens, 'Expected new line after player frame binding');

			while (!tokens.match(RDP.tree.newLine)) {
				tokens.expect(RDP.tree.identifier, '');
				playerFrames[playerFrameName].push(tokens.past());

				tokens.expect(RDP.tree.newLine, '');
			}

			RDP.tree.chompNL(tokens, 'Expected new line after player frame declaration');
		}

		return playerFrames;
	};

	RDP.tree.objects = function(tokens) {
		tokens.expect('OBJECTS', 'Expected OBJECTS section after PLAYER');
		RDP.tree.chompNL(tokens, 'Expected new line after OBJECTS');


		var objects = {};

		while (!tokens.match('SETS')) {
			// name
			tokens.expect(RDP.tree.identifier, 'Expected at least one object');
			var objName = tokens.past().s;
			if (objects[objName]) {
				throw objName + ' already declared';
			}
			objects[objName] = { lines: [] };

			if (tokens.match('blocking')) {
				objects[objName].blocking = true;
				tokens.adv();
			}

			RDP.tree.chompNL(tokens, 'Expected new line after object name binding');

			while (!tokens.match(RDP.tree.newLine)) {
				tokens.expect(RDP.tree.identifier, '');
				objects[objName].lines.push(tokens.past());

				if (tokens.match('blocking')) {
					objects[objName].blocking = true;
				}

				tokens.expect(RDP.tree.newLine, '');
			}

			RDP.tree.chompNL(tokens, 'Expected new line after object declaration');
		}

		return objects;
	};

	RDP.tree.sets = function(tokens) {
		tokens.expect('SETS', 'Expected SETS after OBJECTS');
		RDP.tree.chompNL(tokens, 'Expected new line after SETS');


		var sets = [];

		while (!tokens.match('NEARRULES') &&
            !tokens.match('LEAVERULES') &&
            !tokens.match('ENTERRULES') &&
            !tokens.match('USERULES')) {
			tokens.expect(RDP.tree.identifier, '');
			var setName = tokens.past().s;

			var set = { name: setName };

			tokens.expect(RDP.tree.assignment, 'Expecting assignment operator');
			tokens.expect(RDP.tree.identifier, 'Expecting identifier after assignment');
			var firstOperandOrElement = tokens.past().s;

			if (tokens.match('or') || tokens.match('and') || tokens.match('minus')) {
				var operator = tokens.next().s;
				tokens.expect(RDP.tree.identifier);
				var secondOperand = tokens.past().s;

				set.operator = operator;
				set.operand1 = firstOperandOrElement;
				set.operand2 = secondOperand;
			} else {
				var elements = [firstOperandOrElement];
				while (tokens.match(RDP.tree.identifier)) {
					elements.push(tokens.next().s);
				}

				set.elements = elements;
			}

			sets.push(set);

			RDP.tree.chompNL(tokens, 'Expected new line after set declaration');
		}

		return sets;
	};

    RDP.tree.nearRules = function(tokens) {
        tokens.expect('NEARRULES', 'Expected NEARRULES section after SETS');
        RDP.tree.chompNL(tokens, 'Expected new line after NEARRULES');


        var rules = [];

        while (!tokens.match('LEAVERULES') &&
            !tokens.match('ENTERRULES') &&
            !tokens.match('USERULES')) {
            var rule = {};

            tokens.expect(RDP.tree.identifier, 'Expected terrain unit');
            rule.inTerrainItemName = tokens.past();

            tokens.expect(RDP.tree.arrow, 'Expected ->');

            tokens.expect(RDP.tree.identifier, 'Expected out terrain unit');
            rule.outTerrainItemName = tokens.past();

            while (tokens.match(RDP.tree.semicolon)) {
                tokens.adv();

                if (tokens.match('heal')) {
                    tokens.adv();

                    tokens.expect(RDP.tree.identifier, 'Expected heal quantity');
                    rule.heal = tokens.past();
                } else if (tokens.match('hurt')) {
                    tokens.adv();

                    tokens.expect(RDP.tree.identifier, 'Expected hurt quantity');
                    rule.hurt = tokens.past();
                }
            }

            RDP.tree.chompNL(tokens, 'Expected new line between rules');

            rules.push(rule);
        }

        return rules;
    };

	RDP.tree.leaveRules = function(tokens) {
		tokens.expect('LEAVERULES', 'Expected LEAVERULES section after SETS');
		RDP.tree.chompNL(tokens, 'Expected new line after LEAVERULES');


		var rules = [];

		while (!tokens.match('ENTERRULES') &&
            !tokens.match('USERULES')) {
			var rule = {};

			tokens.expect(RDP.tree.identifier, 'Expected terrain unit');
			rule.inTerrainItemName = tokens.past();

			tokens.expect(RDP.tree.arrow, 'Expected ->');

			tokens.expect(RDP.tree.identifier, 'Expected out terrain unit');
			rule.outTerrainItemName = tokens.past();

			RDP.tree.chompNL(tokens, 'Expected new line between rules');

			rules.push(rule);
		}

		return rules;
	};

	RDP.tree.enterRules = function(tokens) {
		tokens.expect('ENTERRULES', 'Expected ENTERRULES section after LEAVERULES');
		RDP.tree.chompNL(tokens, 'Expected new line after ENTERRULES');


		var rules = [];

		while (!tokens.match('USERULES')) {
			var rule = {};

			tokens.expect(RDP.tree.identifier, 'Expected terrain unit');
			rule.inTerrainItemName = tokens.past();

			tokens.expect(RDP.tree.arrow, 'Expected ->');

			tokens.expect(RDP.tree.identifier, 'Expected out terrain unit');
			rule.outTerrainItemName = tokens.past();

			while (tokens.match(RDP.tree.semicolon)) {
				tokens.adv();

				if (tokens.match('give')) {
					tokens.adv();

					var item = {};

					tokens.expect(RDP.tree.identifier, 'Expected give quantity');
					item.quantity = tokens.past();

					tokens.expect(RDP.tree.identifier, 'Expected give item name');
					item.itemName = tokens.past();

					rule.give = [item];

					while (tokens.match(RDP.tree.comma)) {
						tokens.adv();

						item = {};

						tokens.expect(RDP.tree.identifier, 'Expected give quantity');
						item.quantity = tokens.past();

						tokens.expect(RDP.tree.identifier, 'Expected give item name');
						item.itemName = tokens.past();

						rule.give.push(item);
					}
				} else if (tokens.match('heal')) {
					tokens.adv();

					tokens.expect(RDP.tree.identifier, 'Expected heal quantity');
					rule.heal = tokens.past();
				} else if (tokens.match('hurt')) {
					tokens.adv();

					tokens.expect(RDP.tree.identifier, 'Expected hurt quantity');
					rule.hurt = tokens.past();
				} else if (tokens.match('teleport')) {
					tokens.adv();

					rule.teleport = {};

					tokens.expect(RDP.tree.identifier, 'Expected teleport level name');
					rule.teleport.levelName = tokens.past();

					tokens.expect(RDP.tree.identifier, 'Expected teleport position X');
					rule.teleport.x = tokens.past();

					tokens.expect(RDP.tree.identifier, 'Expected teleport position Y');
					rule.teleport.y = tokens.past();
				} else if (tokens.match('message')) {
					tokens.adv();

					tokens.expect(RDP.tree.str, 'Expected message');
					rule.message = tokens.past();
				}
			}

			RDP.tree.chompNL(tokens, 'Expected new line between rules');

			rules.push(rule);
		}

		return rules;
	};

	RDP.tree.useRules = function(tokens) {
		tokens.expect('USERULES', 'Expected USERULES section after SETS');
		RDP.tree.chompNL(tokens, 'Expected new line after USERULES');


		var rules = [];

		while (!tokens.match('LEGEND')) {
			var rule = {};

			tokens.expect(RDP.tree.identifier, 'Expected terrain unit');
			rule.inTerrainItemName = tokens.past();

			tokens.expect(RDP.tree.identifier, 'Expected inventory unit');
			rule.inInventoryItemName = tokens.past();

			tokens.expect(RDP.tree.arrow, 'Expected ->');

			tokens.expect(RDP.tree.identifier, 'Expected out terrain unit');
			rule.outTerrainItemName = tokens.past();

			while (tokens.match(RDP.tree.semicolon)) {
				tokens.adv();

				if (tokens.match('give')) {
					tokens.adv();

					var item = {};

					tokens.expect(RDP.tree.identifier, 'Expected give quantity');
					item.quantity = tokens.past();

					tokens.expect(RDP.tree.identifier, 'Expected give item name');
					item.itemName = tokens.past();

					rule.give = [item];

					while (tokens.match(RDP.tree.comma)) {
						tokens.adv();

						item = {};

						tokens.expect(RDP.tree.identifier, 'Expected give quantity');
						item.quantity = tokens.past();

						tokens.expect(RDP.tree.identifier, 'Expected give item name');
						item.itemName = tokens.past();

						rule.give.push(item);
					}
				} else if (tokens.match('consume')) {
					tokens.adv();

					rule.consume = true;
				} else if (tokens.match('heal')) {
					tokens.adv();

					tokens.expect(RDP.tree.identifier, 'Expected heal quantity');
					rule.heal = tokens.past();
				} else if (tokens.match('hurt')) {
					tokens.adv();

					tokens.expect(RDP.tree.identifier, 'Expected hurt quantity');
					rule.hurt = tokens.past();
				} else if (tokens.match('teleport')) {
					tokens.adv();

					rule.teleport = {};

					tokens.expect(RDP.tree.identifier, 'Expected teleport level name');
					rule.teleport.levelName = tokens.past();

					tokens.expect(RDP.tree.identifier, 'Expected teleport position X');
					rule.teleport.x = tokens.past();

					tokens.expect(RDP.tree.identifier, 'Expected teleport position Y');
					rule.teleport.y = tokens.past();
				} else if (tokens.match('message')) {
					tokens.adv();

					tokens.expect(RDP.tree.str, 'Expected message');
					rule.message = tokens.past();
				}
			}

			RDP.tree.chompNL(tokens, 'Expected new line between rules');

			rules.push(rule);
		}

		return rules;
	};

	RDP.tree.legend = function(tokens) {
		tokens.expect('LEGEND', 'Expected LEGEND section after RULES');
		RDP.tree.chompNL(tokens, 'Expected new line after LEGEND');

		var legend = {};

		while (!tokens.match('LEVELS')) {
			tokens.expect(RDP.tree.identifier, '');
			var terrainChar = tokens.past().s;
			if (legend[terrainChar]) {
				throw terrainChar + ' already declared';
			}

			tokens.expect(RDP.tree.identifier, 'Expected terrain binding');
			legend[terrainChar] = tokens.past().s;

			RDP.tree.chompNL(tokens, 'Expected new line');
		}

		return legend;
	};

	RDP.tree.levels = function(tokens) {
		tokens.expect('LEVELS', 'Expected LEVELS section after LEGEND');
		RDP.tree.chompNL(tokens, 'Expected new line after LEVELS');


		var levels = {};

		while (!tokens.match(RDP.tree.end)) {
			tokens.expect(RDP.tree.identifier, 'Expected at least one level');
			var levelName = tokens.past().s;
			if (levels[levelName]) {
				throw levelName + ' already declared';
			}

			var lines = [];

			RDP.tree.chompNL(tokens, 'Expected new line after level name binding');

			while (!tokens.match(RDP.tree.newLine)) {
				tokens.expect(RDP.tree.identifier, '');
				lines.push(tokens.past());

				tokens.expect(RDP.tree.newLine, '');
			}

			levels[levelName] = lines;

			RDP.tree.chompNL(tokens, 'Expected new line after level declaration');
		}

		return levels;
	};

	return RDP;
});
define('KeyListener',['SystemBus'], function (SystemBus) {
	

	var keyState = {};

	function onKeyDown(e) {
		e.preventDefault();
		e.stopPropagation();

		if (!keyState[e.which]) {
			SystemBus.emit('keydown', { key: e.which });
		}
		keyState[e.which] = true;
	}

	function onKeyUp(e) {
		e.preventDefault();
		e.stopPropagation();

		if (keyState[e.which]) {
			SystemBus.emit('keyup', { key: e.which });
		}
		keyState[e.which] = false;
	}



	var KeyListener = {};

	KeyListener.init = function (domElement) {
		domElement.addEventListener('keydown', onKeyDown);
		domElement.addEventListener('keyup', onKeyUp);
	};

	return KeyListener;
});

define('main',[
	'SystemBus',
	'Text',
	'Game',
	'tokenizer/Tokenizer',
	'parser/RDP',
	'KeyListener'
	], function (
		SystemBus,
		Text,
		Game,
		Tokenizer,
		RDP,
		KeyListener
	) {
	

	var tree;
	var errorLine = null;
	var inWorldEditor;
	var game;

	function setupEditors() {
		inWorldEditor = CodeMirror.fromTextArea(document.getElementById('in'), {
            lineNumbers: true,
            styleActiveLine: true
        });
        inWorldEditor.setSize(400, 400);
        inWorldEditor.setOption('theme', 'cobalt');
        inWorldEditor.on('change', parse);
	}

	function parse() {
		var inText = inWorldEditor.getValue();

		try {
			var tokens = Tokenizer.chop(inText);
			tree = RDP.parse(tokens);

			if (errorLine !== null) {
				inWorldEditor.removeLineClass(errorLine, 'background', 'line-error');
				errorLine = null;
			}

			document.getElementById('status').classList.add('ok');
			document.getElementById('status').classList.remove('err');
			document.getElementById('status').innerHTML = 'OK';

			document.getElementById('compile').disabled = false;
		} catch (ex) {
			tree = null;
			document.getElementById('compile').disabled = true;

			if (ex.line !== undefined) {
				if (ex.line !== errorLine && errorLine !== null) {
					inWorldEditor.removeLineClass(errorLine, 'background', 'line-error');
				}
				errorLine = ex.line;
				inWorldEditor.addLineClass(errorLine, 'background', 'line-error');
			}

			document.getElementById('status').classList.add('err');
			document.getElementById('status').classList.remove('ok');
			document.getElementById('status').innerHTML = ex.message || ex;
		}
	}

	function compile() {
		if (tree) {
			if (game) {
				game.cleanup();
			}

			game = new Game();
			game.init(tree);
			game.start();
		}
	}

	function hide() {
		var editorDiv = document.getElementById('editor');
		editor.style.display = 'none';

		var editButton = document.getElementById('edit');
		editButton.style.display = 'block';

		var hideButton = document.getElementById('hide');
		hideButton.style.display = 'none';

		var gameContDiv = document.getElementById('gamecont');
		gameContDiv.classList.add('centeredcont');

		var canvas = document.getElementById('can');
		canvas.focus();
	}

	function edit() {
		var editorDiv = document.getElementById('editor');
		editor.style.display = 'block';

		var editButton = document.getElementById('edit');
		editButton.style.display = 'none';

		var hideButton = document.getElementById('hide');
		hideButton.style.display = 'block';

		var gameContDiv = document.getElementById('gamecont');
		gameContDiv.classList.remove('centeredcont');

		inWorldEditor.refresh();
	}

	function setupGUI() {
		var compileButton = document.getElementById('compile');
		compileButton.addEventListener('click', compile);

		var getUrlButton = document.getElementById('geturl');
		getUrlButton.addEventListener('click', setUrl);

		var editButton = document.getElementById('edit');
		editButton.addEventListener('click', edit);

		var hideButton = document.getElementById('hide');
		hideButton.addEventListener('click', hide);
	}

	function setUrl() {
		var spec = inWorldEditor.getValue();
		var baseUrl = 'http://madflame991.github.io/furnace-engine/src/index.html';
		var encodedLevel = encodeURIComponent(spec);
		var url = baseUrl + '?spec=' + encodedLevel;

		var urlTextarea = document.getElementById('url');
		urlTextarea.value = url;
	}

	function checkUrl() {
		var urlParams = purl(true).param();
		if (urlParams.spec) {
			inWorldEditor.setValue(urlParams.spec);
		}
	}

	function run() {
		setupEditors();
		setupGUI();

		checkUrl();


        Text.init();

        document.getElementById('can').tabIndex = 0;
        KeyListener.init(document.getElementById('can'));

        parse();
        compile();

        var canvas = document.getElementById('can');
        canvas.focus();
	}

	return { run: run };
});
  })();
})();