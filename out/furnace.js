(function () {
  if (localStorage.furnaceDev) { require.config({ baseUrl: "js" }); }
  else (function () {
// Generated by CoffeeScript 1.7.1
(function() {
  define('Util',[], function() {
    
    var Util;
    Util = {};
    Util.maptree = function(tree, fun, predicate) {
      var key, newObj;
      if (predicate(tree)) {
        return fun(tree);
      }
      if (tree instanceof Array) {
        return tree.map(function(elem) {
          return Util.maptree(elem, fun, predicate);
        });
      } else if (typeof tree === 'object') {
        newObj = {};
        for (key in tree) {
          newObj[key] = Util.maptree(tree[key], fun, predicate);
        }
        return newObj;
      }
    };
    Util.findFirst = function(array, predicate) {
      var i;
      i = 0;
      while (i < array.length) {
        if (predicate(array[i], i)) {
          return {
            element: array[i],
            index: i
          };
        }
        i++;
      }
    };
    Util.removeFirst = function(array, predicate) {
      var firstMatch;
      firstMatch = Util.findFirst(array, predicate);
      if (firstMatch) {
        array.splice(firstMatch.index, 1);
      }
    };
    Util.remove = function(array, element) {
      Util.removeFirst(array, function(entry) {
        return entry === element;
      });
    };
    Util.objectToArray = function(object, nameProperty, dataProperty) {
      var array, entry, key;
      array = [];
      for (key in object) {
        entry = {};
        entry[nameProperty] = key;
        entry[dataProperty] = object[key];
        array.push(entry);
      }
      return array;
    };
    Util.arrayToObject = function(array, nameProperty, dataProperty) {
      var object;
      object = {};
      array.forEach(function(element) {
        object[element[nameProperty]] = element[dataProperty];
      });
      return object;
    };
    Util.mapOnKeys = function(object, fun) {
      var key, ret;
      ret = {};
      for (key in object) {
        ret[key] = fun(object[key]);
      }
      return ret;
    };
    Util.groupBy = function(array, fun) {
      var groups;
      groups = {};
      array.forEach(function(element) {
        var ret;
        ret = fun(element);
        if (!groups[ret]) {
          groups[ret] = [];
        }
        groups[ret].push(element);
      });
      return groups;
    };
    Util.getDuplicate = function(array) {
      var duplicate, elementsByName, index;
      elementsByName = {};
      duplicate = null;
      index = -1;
      array.every(function(element, i) {
        if (elementsByName[element] != null) {
          duplicate = element;
          index = i;
          return false;
        } else {
          elementsByName[element] = true;
          return true;
        }
      });
      return {
        value: duplicate,
        index: index
      };
    };
    Util.capitalize = function(string) {
      return string.substring(0, 1).toUpperCase() + string.substring(1);
    };
    Util.isCapitalized = function(string) {
      return string.substring(0, 1).toUpperCase() === string.substring(0, 1);
    };
    return Util;
  });

}).call(this);

define('Bus',['Util'], function (Util) {
	

	function Bus() {
		this.channels = {};
	}

	Bus.prototype.addListener = function (channel, id, callback) {
		if (!this.channels[channel]) {
			this.channels[channel] = [];
		}
		this.channels[channel].push({ id: id, callback: callback });
	};

	Bus.prototype.emit = function (channel, data) {
		if (this.channels[channel]) {
			this.channels[channel].forEach(function(listener) {
				listener.callback(data);
			});
		}
	};

	Bus.prototype.removeListener = function (channel, id) {
		Util.removeFirst(this.channels[channel], function(listener) { return listener.id === id; });
	};

	Bus.prototype.removeChannel = function (channel) {
		delete this.channels[channel];
	};

	Bus.prototype.reset = function () {
		this.channels = {};
	};

	return Bus;
});

define('SystemBus',['Bus'], function (Bus) {
	

	var SystemBus = new Bus();

	return SystemBus;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('Font',[], function() {
    var colorBindings, convert, namedSprites;
    colorBindings = [
      {
        name: '1',
        red: '255',
        green: '255',
        blue: '255'
      }, {
        name: '2',
        red: '0',
        green: '0',
        blue: '0'
      }, {
        name: '.',
        red: '0',
        green: '0',
        blue: '0',
        alpha: '0'
      }
    ];
    namedSprites = [
      {
        name: '0',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112....11112..\n..112.1112.112..\n..11112....112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'A',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: 'N',
        data: '.112.........112\n.112.........112\n.11112.......112\n.112.112.....112\n.112...112...112\n.112.....112.112\n.112.......11112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112'
      }, {
        name: '1',
        data: '.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......'
      }, {
        name: 'B',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....'
      }, {
        name: 'O',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '2',
        data: '....11111112....\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n...........112..\n....11111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..'
      }, {
        name: 'C',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'P',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........'
      }, {
        name: '3',
        data: '....11111112....\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n...........112..\n.......11112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'D',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....'
      }, {
        name: 'Q',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112..112.112..\n..112....11112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '4',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..'
      }, {
        name: 'E',
        data: '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..'
      }, {
        name: 'R',
        data: '..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..1111111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: '5',
        data: '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'F',
        data: '..111111111112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..1111111112....\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........'
      }, {
        name: 'S',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n....11111112....\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '6',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111.....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'G',
        data: '....11111112....\n..112......112..\n..112......112..\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'T',
        data: '..1111111111112.\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......'
      }, {
        name: '7',
        data: '..111111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..'
      }, {
        name: 'H',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..111111111112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: 'U',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: '8',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'I',
        data: '.....1111112....\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.....1111112....'
      }, {
        name: 'V',
        data: '.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.......112......'
      }, {
        name: '9',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n....1111111112..\n...........112..\n...........112..\n...........112..\n...........112..\n...........112..\n..112......112..\n..112......112..\n....11111112....'
      }, {
        name: 'J',
        data: '..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n..........112...\n....112...112...\n....112...112...\n......11112.....'
      }, {
        name: 'W',
        data: '.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112...112...112\n.112.112.112.112\n.11112.....11112\n.112.........112\n.112.........112'
      }, {
        name: '.',
        data: '................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n................\n.......112......\n.......112......'
      }, {
        name: 'K',
        data: '..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112....112....\n..11111112......\n..112....112....\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..\n..112......112..'
      }, {
        name: 'X',
        data: '.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.....112.112....\n.....112.112....\n...112.....112..\n...112.....112..\n.112.........112\n.112.........112\n.112.........112'
      }, {
        name: '!',
        data: '.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n................\n................\n.......112......\n.......112......'
      }, {
        name: 'L',
        data: '..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..112...........\n..111111111112..'
      }, {
        name: 'Y',
        data: '.112.........112\n.112.........112\n.112.........112\n...112.....112..\n...112.....112..\n...112.....112..\n.....112.112....\n.....112.112....\n.....112.112....\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......\n.......112......'
      }, {
        name: '?',
        data: '....11111112....\n..112......112..\n..112......112..\n..112......112..\n...........112..\n...........112..\n...........112..\n.........112....\n.......112......\n.......112......\n.......112......\n.......112......\n................\n................\n.......112......\n.......112......'
      }, {
        name: 'M',
        data: '.112.........112\n.112.........112\n.11112.....11112\n.112.112.112.112\n.112...112...112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112\n.112.........112'
      }, {
        name: 'Z',
        data: '...11111111112..\n...........112..\n...........112..\n...........112..\n.........112....\n.........112....\n.........112....\n.......112......\n.......112......\n.......112......\n.....112........\n.....112........\n.....112........\n...112..........\n...112..........\n...11111111112..'
      }
    ];
    convert = function(namedSprites) {
      return namedSprites.map(function(namedSprite) {
        return {
          name: namedSprite.name,
          data: namedSprite.data.split('\n')
        };
      });
    };
    return {
      colorBindings: colorBindings,
      namedSprites: convert(namedSprites)
    };
  });

}).call(this);

define('con2d',[], function () {
	

	var canvas = document.getElementById('can');

	var con2d = canvas.getContext('2d');

	return con2d;
});

define('Sprite',[
	'con2d'
	], function (
		con2d
	) {
	

	function Sprite(spriteSheet, start, end) {
		this.spriteSheet = spriteSheet;
		this.start = start;
		this.end = end;
	}

	Sprite.prototype.drawAt = function(x, y) {
		con2d.drawImage(
			this.spriteSheet,
			this.start.x, this.start.y, this.end.x - this.start.x, this.end.y - this.start.y,
			x, y, this.end.x - this.start.x, this.end.y - this.start.y
		);
	};

	return Sprite;
});

define('Vec2',[], function () {
	

	function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
            return new Vec2(x, y);
        }
		this.x = x;
		this.y = y;
	}

	Vec2.prototype.copy = function () {
		return new Vec2(this.x, this.y);
	};

	Vec2.prototype.add = function (that) {
		return new Vec2(this.x + that.x, this.y + that.y);
	};

	Vec2.prototype.addOn = function (that) {
		this.x += that.x;
		this.y += that.y;
	};

	Vec2.prototype.sub = function (that) {
		return new Vec2(this.x - that.x, this.y - that.y);
	};

	Vec2.prototype.subOn = function (that) {
		this.x -= that.x;
		this.y -= that.y;
	};

	Vec2.prototype.scale = function (scale) {
		return new Vec2(this.x * scale, this.y * scale);
	};

	Vec2.prototype.scaleOn = function (scale) {
		this.x *= scale;
		this.y *= scale;
	};

	Vec2.prototype.mul = function (that) {
		return new Vec2(this.x * that.x, this.y * that.y);
	};

	Vec2.prototype.mulOn = function (that) {
		this.x *= that.x;
		this.y *= that.y;
	};

	return Vec2;
});

define('SpriteSheet',[
	'Sprite',
	'Vec2'
	], function (
		Sprite,
		Vec2
	) {
	

	function SpriteSheet(image, width, height) {
		this.image = image;
		this.width = width;
		this.height = height;
		this.spriteWidth = Math.floor(this.image.width / this.width);
		this.spriteHeight = Math.floor(this.image.height / this.height);
	}

	SpriteSheet.prototype.getSprite = function(x, y) {
		return new Sprite(
			this.image,
			new Vec2(this.spriteWidth * x, this.spriteHeight * y),
			new Vec2((x + 1) * this.spriteWidth, (y + 1) * this.spriteHeight)
		);
	};

	return SpriteSheet;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('generator/SpriteSheetGenerator',['Util', 'SpriteSheet'], function(Util, SpriteSheet) {
    var SpriteSheetGenerator;
    SpriteSheetGenerator = {};
    SpriteSheetGenerator.generate = function(stringedSprites, colorBindings, scale) {
      var canvas, colorsByBinding, con2d, dataURL, image, namedSprites, paint, pixel, spriteSheet, width;
      pixel = function(x, y, color) {
        con2d.fillStyle = color;
        con2d.fillRect(x * scale, y * scale, scale, scale);
      };
      paint = function(x, y, data) {
        var baseOffsetX, baseOffsetY;
        baseOffsetX = x * data.length;
        baseOffsetY = y * data.length;
        data.forEach(function(line, i) {
          line.split('').forEach(function(char, j) {
            var color;
            color = colorsByBinding[char];
            pixel(baseOffsetX + j, baseOffsetY + i, color);
          });
        });
      };
      colorsByBinding = Util.arrayToObject(colorBindings.map(function(binding) {
        var stringedColor;
        stringedColor = binding.alpha != null ? "rgba(" + binding.red + "," + binding.green + "," + binding.blue + "," + binding.alpha + ")" : "rgb(" + binding.red + "," + binding.green + "," + binding.blue + ")";
        return {
          name: binding.name,
          stringedColor: stringedColor
        };
      }), 'name', 'stringedColor');
      width = Math.ceil(Math.sqrt(stringedSprites.length));
      canvas = document.createElement('canvas');
      canvas.width = stringedSprites[0].data.length * width * scale;
      canvas.height = stringedSprites[0].data.length * width * scale;
      con2d = canvas.getContext('2d');
      stringedSprites.forEach(function(stringedSprite, index) {
        var x, y;
        x = index % width;
        y = Math.floor(index / width);
        paint(x, y, stringedSprite.data);
      });
      dataURL = canvas.toDataURL('image/png');
      image = new Image();
      image.src = dataURL;
      spriteSheet = new SpriteSheet(image, width, width);
      namedSprites = stringedSprites.map(function(stringedSprite, index) {
        var x, y;
        x = index % width;
        y = Math.floor(index / width);
        return {
          name: stringedSprite.name,
          sprite: spriteSheet.getSprite(x, y)
        };
      });
      return namedSprites;
    };
    return SpriteSheetGenerator;
  });

}).call(this);

define('Text',[
    'Font',
    'generator/SpriteSheetGenerator',
    'Util'
], function (
    Font,
    SpriteSheetGenerator,
    Util
    ) {

	

	var Text = {};

	Text.sprites = [];

	Text.init = function() {
        var namedSprites = SpriteSheetGenerator.generate(Font.namedSprites, Font.colorBindings, 1);

        namedSprites.forEach(function (namedSprite) {
            Text.sprites[namedSprite.name.charCodeAt(0)] = namedSprite.sprite;
        });
	};

	Text.drawAt = function(string, x, y) {
		string += '';

		var chars = string.split('').map(function(char) { return char.charCodeAt(0); });

		for (var i = 0; i < chars.length; i++) {
			var sprite = Text.sprites[chars[i]];
			if (sprite) {
                sprite.drawAt(x + i * 16, y);
            }
		}
	};

	return Text;
});

define('Items',[], function () {
	

	var Items = {};

	Items.collection = {};

	return Items;
});

define('Player',[
	'SystemBus',
	'Vec2',
	'Items',
    'con2d'
	], function(
		SystemBus,
		Vec2,
		Items,
        con2d
	) {
	

	function Player(world, healthMax, spritesByName, tileDimensions, uiOffset) {
		this.world = world;
        this.healthMax = healthMax;
        this.health = this.healthMax;
		this.blockWidth = tileDimensions.x;
		this.blockHeight = tileDimensions.y;
		this.uiOffset = uiOffset || new Vec2(0, 0);
		this.position = new Vec2(0, 0);
		this.spritesByName = spritesByName;
        this.sprite = null;
        this.healthSprite = spritesByName['health'];
		this.direction = 'down';
        this.alive = true;
	}

	var keyMapping = {
		65: 'use',
		83: 'invleft',
		68: 'invright',
		70: 'invmark',
		38: 'up',
		37: 'left',
		40: 'down',
		39: 'right'
	};

	var deltas = {
		up: new Vec2(0, -1),
		left: new Vec2(-1, 0),
		down: new Vec2(0, 1),
		right: new Vec2(1, 0)
	};

	var invDeltas = {
		invleft: -1,
		invright: 1
	};

	/**
	 * Initializes the player
	 */
	Player.prototype.init = function () {
		this.direction = 'down';
		this.sprite = this.spritesByName[this.direction];

		SystemBus.addListener('keydown', '', function (data) {
            if (data.key === 75) {
                delete localStorage['furnace-save'];
            }

            if (this.alive) {
                if (this.world.textBubble.visible) {
                    if (data.key === 65) {
                        this.world.textBubble.hide();
                    }
                } else {
                    if (data.key === 85) {
                        this.restore();
                    } else if (data.key === 65) {
                        this.use();
                    } else if (data.key === 83 || data.key === 68) {
                        this.world.inventory.move(invDeltas[keyMapping[data.key]]);
                    } else {
                        if (keyMapping[data.key]) {
                            this.move(deltas[keyMapping[data.key]]);
                            this.direction = keyMapping[data.key];
                            this.sprite = this.spritesByName[this.direction];
                        }
                    }
                }
            } else {
                if (data.key === 82) {
                    this.alive = true;
                    this.world.textBubble.hide();
                    this.restore();
                }
            }
		}.bind(this));
	};

    Player.prototype.healOrHurt = function (delta) {
        if (this.healthMax > 0) {
            this.health += delta;

            if (this.health <= 0) {
                this.alive = false;
                this.world.textBubble.show().setText('Press R to restart');
            } else if (this.health > this.healthMax) {
                this.health = this.healthMax;
            }
        }
    };

	/**
	 * Sets the position of the player
	 */
	Player.prototype.setPosition = function (x, y) {
		this.position.x = x;
		this.position.y = y;
		this.world.camera.centerOn(this.position.x, this.position.y, this.world.level.width, this.world.level.height);
	};

	/**
	 * Moves delta units
	 */
	Player.prototype.move = function (delta) {
		var candidatePosition = this.position.add(delta);
		if (this.world.level.withinBounds(candidatePosition.x, candidatePosition.y)) {
			var futureBlock = this.world.level.get(candidatePosition.x, candidatePosition.y);
			if (!futureBlock.blocking) {
				this.leave();

				this.position = candidatePosition;
				this.world.camera.centerOn(this.position.x, this.position.y, this.world.level.width, this.world.level.height);

				this.enter();

                this.near();
			}
		}
	};

	/**
	 * Teleports the player in the given level at the given coordinates
	 * @param {string} levelName
	 * @param {number} x
	 * @param {number} y
	 */
	Player.prototype.teleport = function (levelName, x, y) {
		this.world.setLevel(levelName);
		this.setPosition(x, y);
	};

	/**
	 * Returns the facing position
	 */
	Player.prototype.getFacing = function () {
		return this.position.add(deltas[this.direction]);
	};

	function resolveItem(inTerrainItem, inInventoryItem, outItem) {
		if (outItem === '_terrain') {
			return inTerrainItem;
		} else if (outItem === '_inventory') {
			return inInventoryItem;
		} else {
			return outItem;
		}
	}

    /**
     * Standard 8 neighbouring locations on a tiled map
     * @type {Vec2[]}
     */
    Player.neighbourhood = [
        new Vec2( 0, -1),
        new Vec2(-1, -1),
        new Vec2(-1,  0),
        new Vec2(-1,  1),
        new Vec2( 0,  1),
        new Vec2( 1,  1),
        new Vec2( 1,  0),
        new Vec2( 1, -1)
    ];

    /**
     * Returns a list of neighbouring locations which are within the bound of the level
     * @returns {Vec2[]}
     */
    Player.prototype.getNearLocations = function () {
        return Player.neighbourhood.map(function (location) {
            return this.position.add(location);
        }.bind(this)).filter(function (location) {
            return this.world.level.withinBounds(location.x, location.y);
        }.bind(this));
    };

    /**
     * Nears neighbouring locations
     */
    Player.prototype.near = function () {
        var level = this.world.level;
        var ruleSet = this.world.nearRuleSet;

        this.getNearLocations().forEach(function (location) {
            var currentTerrainItem = level.get(location.x, location.y);

            var rule = ruleSet.getRuleFor(currentTerrainItem.id);
            if (rule) {
                level.set(
                    location.x,
                    location.y,
                    Items.collection[
                        resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);

                this.healOrHurt(rule.healthDelta);
            }
        }.bind(this));
    };

	/**
	 * Leaves a location
	 */
	Player.prototype.leave = function () {
		var level = this.world.level;
		var ruleSet = this.world.leaveRuleSet;

		var currentTerrainItem = level.get(this.position.x, this.position.y);

		var rule = ruleSet.getRuleFor(currentTerrainItem.id);
		if (rule) {
			level.set(
				this.position.x,
				this.position.y,
				Items.collection[
					resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);
		}
	};

	/**
	 * Enters a new location
	 */
	Player.prototype.enter = function () {
		var inventory = this.world.inventory;
		var level = this.world.level;
		var ruleSet = this.world.enterRuleSet;

		var currentTerrainItem = level.get(this.position.x, this.position.y);

		var rule = ruleSet.getRuleFor(currentTerrainItem.id);
		if (rule) {
			level.set(
				this.position.x,
				this.position.y,
				Items.collection[
					resolveItem(currentTerrainItem.id, -1, rule.outTerrainItem)]);

			rule.outInventoryItems.forEach(function (item) {
				inventory.addItem(
					Items.collection[
						resolveItem(currentTerrainItem.id, -1, item.itemName)],
					item.quantity);
			});

            this.healOrHurt(rule.healthDelta);

			if (rule.teleport) {
				this.teleport(rule.teleport.levelName, rule.teleport.x, rule.teleport.y);
			}

            if (rule.message) {
                this.world.textBubble.show().setText(rule.message);
            }

            if (rule.checkpoint) {
                this.save();
            }
		}
	};

    /**
     * Restores the game to a previously saved state
     */
    Player.prototype.restore = function () {
        if (localStorage['furnace-save']) {
            var serializedGameState = JSON.parse(localStorage['furnace-save']);
            if (serializedGameState) {
                this.world.deserialize(serializedGameState);
            }
        } else {
            this.world.deserialize(this.world.initialState);
        }
    };

    /**
     * Saves the current game state
     */
    Player.prototype.save = function () {
        var serializedGameState = JSON.stringify(this.world.serialize());
        localStorage['furnace-save'] = serializedGameState;
    };

	/**
	 * Uses the current inventory item on the terrain unit that it's facing
	 */
	Player.prototype.use = function () {
		var inventory = this.world.inventory;
		var level = this.world.level;
		var ruleSet = this.world.useRuleSet;

		var currentInventoryItem = inventory.getCurrent();
        if (!currentInventoryItem) { return; }

		var facingPosition = this.getFacing();
		if (level.withinBounds(facingPosition.x, facingPosition.y)) {
			var currentTerrainItem = level.get(facingPosition.x, facingPosition.y);

			var rule = ruleSet.getRuleFor(currentTerrainItem.id, currentInventoryItem.id);
			if (rule) {
				if (!rule.consume ||
					(rule.consume &&
						inventory.has(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, currentInventoryItem.id)]))) {

					if (rule.consume) {
						inventory.consume(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, currentInventoryItem.id)]);
					}

					level.set(
						facingPosition.x,
						facingPosition.y,
						Items.collection[
							resolveItem(currentTerrainItem.id, currentInventoryItem.id, rule.outTerrainItem)]);

					rule.outInventoryItems.forEach(function (item) {
						inventory.addItem(
							Items.collection[
								resolveItem(currentTerrainItem.id, currentInventoryItem.id, item.itemName)],
							item.quantity);
					});

                    this.healOrHurt(rule.healthDelta);

					if (rule.teleport) {
						this.teleport(rule.teleport.levelName, rule.teleport.x, rule.teleport.y);
					}

                    if (rule.message) {
                        this.world.textBubble.show().setText(rule.message);
                    }
				}
			}
		}
	};

	/**
	 * Draws the player
	 */
	Player.prototype.draw = function (camera, tick) {
		this.sprite.drawAt(
			this.uiOffset.x +
			(this.position.x - camera.position.x /*+ Math.floor(camera.dimensions.x / 2)*/) * this.blockWidth,
			this.uiOffset.y +
			(this.position.y - camera.position.y /*+ Math.floor(camera.dimensions.y / 2)*/) * this.blockHeight
		);

        // health
        var offsetX = this.world.tileDimensions.x * (this.world.camera.dimensions.x - 1);
        var offsetY = this.world.tileDimensions.y * this.world.camera.dimensions.y + 8;

        con2d.fillStyle = '#000000';
        con2d.fillRect(
            offsetX - this.healthMax * this.world.tileDimensions.x, offsetY,
            this.healthMax * this.world.tileDimensions.x, this.world.tileDimensions.y
        );

        for (var i = 0; i < this.health; i++) {
            this.healthSprite.drawAt(
                offsetX - i * this.world.tileDimensions.x,
                offsetY
            );
        }
	};

    Player.prototype.serialize = function () {
        return {
            position: {
                x: this.position.x,
                y: this.position.y
            },
            direction: this.direction,
            health: this.health
        };
    };

    Player.prototype.deserialize = function (config) {
        this.setPosition(config.position.x, config.position.y);

        this.direction = config.direction;
        this.sprite = this.spritesByName[this.direction];

        this.health = config.health;
    };

	return Player;
});

define('Inventory',[
		'Items',
		'Text',
		'con2d',
		'Util',
        'underscore'
	], function (
		Items,
		Text,
		con2d,
		Util,
        _
	) {
	

	function Inventory(sizeMax, tileDimensions, uiOffset) {
		this.sizeMax = sizeMax;
        this.sizeCurrent = 0;
		this.tileDimensions = tileDimensions;
		this.uiOffset = uiOffset;
		this.inventory = {};
		this.arrangement = [];
		this.current = 0;
        this.offset = 0;
	}

	/**
	 * Draw the inventory
	 */
	Inventory.prototype.draw = function () {
        // wrap this in a procedure
		con2d.fillStyle = '#000000';
		con2d.fillRect(
			this.uiOffset.x, this.uiOffset.y,
			this.sizeMax * this.tileDimensions.x, this.tileDimensions.y
        );

		for (var i = 0; i < this.sizeCurrent; i++) {
			// if null then skip
			var itemName = this.arrangement[(i + this.offset) % this.arrangement.length];
			var sprite = Items.collection[itemName];
			sprite.drawAt(
				this.uiOffset.x + i * this.tileDimensions.x,
				this.uiOffset.y
			);

			var text = '' + this.inventory[itemName];
			var offsetX = this.uiOffset.x + i * this.tileDimensions.x + this.tileDimensions.x - 4 - 16 * text.length;
			var offsetY = this.uiOffset.y + this.tileDimensions.y - 20;

			Text.drawAt(text, offsetX, offsetY);
		}

        if (this.empty()) { return; }
        // wrap this in a procedure
		con2d.lineWidth = 2;
		con2d.strokeStyle = '#FFF';
		con2d.strokeRect(
			this.uiOffset.x + (this.current - this.offset) * this.tileDimensions.x + 1, this.uiOffset.y + 1,
			this.tileDimensions.x - 2, this.tileDimensions.y - 2
		);
		con2d.strokeStyle = '#000';
		con2d.strokeRect(
			this.uiOffset.x + (this.current - this.offset) * this.tileDimensions.x + 2, this.uiOffset.y + 2,
			this.tileDimensions.x - 4, this.tileDimensions.y - 4
		);
	};

	/**
	 * Move the cursor left and right, changing the current inventory item
	 */
	Inventory.prototype.move = function (delta) {
        if (this.empty()) {
            this.current = 0;
            this.offset = 0;
            return;
        }

        this.current += delta;

        if (this.current < 0) {
            this.current = 0;
            this.offset = 0;
        } else if (this.current < this.offset) {
            this.offset = this.current;
        } else if (this.current >= this.arrangement.length) {
            this.current = this.arrangement.length - 1;
            this.offset = this.current - this.sizeCurrent + 1;
        } else if (this.current >= this.offset + this.sizeMax) {
            this.offset = this.current - this.sizeCurrent + 1;
        }
	};

    /**
     * Checks if the inventory is empty or not
     */
    Inventory.prototype.empty = function () {
        return this.arrangement.length === 0;
    };

    /**
	 * Checks if an item is present in the inventory
	 * @param {Item} item
	 */
	Inventory.prototype.has = function (item) {
		return !!this.inventory[item.id];
	};

	/**
	 * Consumes a specified item from the inventory
	 * @param {Item} item
	 */
	Inventory.prototype.consume = function (item) {
		this.inventory[item.id]--;
		if (!this.inventory[item.id]) {
			Util.remove(this.arrangement, item.id);
			if (this.current >= this.arrangement.length - this.offset - 1) {
				this.current--;
                this.offset = Math.max(this.offset - 1, 0);
			}
            this.sizeCurrent = Math.min(this.sizeMax, this.arrangement.length);
		}
	};

	/**
	 * Adds an item to the inventory
	 * @param {Item} item
 	 * @param {number} quantity
	 */
	Inventory.prototype.addItem = function (item, quantity) {
		if (typeof this.inventory[item.id] === 'number') {
			if (this.inventory[item.id] === 0) {
				this.arrangement.push(item.id);
			}
			this.inventory[item.id] += quantity;
		} else {
			this.inventory[item.id] = quantity;
			this.arrangement.push(item.id);
		}

        this.sizeCurrent = Math.min(this.sizeMax, this.arrangement.length);
	};

	/**
	 * Gets the current selected inventory item
	 */
	Inventory.prototype.getCurrent = function () {
		var itemName = this.arrangement[this.current];
		return Items.collection[itemName];
	};

    Inventory.prototype.serialize = function () {
        var inventory = _.clone(this.inventory);
        var arrangement = _.clone(this.arrangement);

        return {
            inventory: inventory,
            arrangement: arrangement,
            current: this.current,
            sizeCurrent: this.sizeCurrent,
            offset: this.offset
        };
    };

    Inventory.prototype.deserialize = function (config) {
        this.inventory = _.clone(config.inventory);
        this.arrangement = _.clone(config.arrangement);
        this.current = config.current;
        this.sizeCurrent = config.sizeCurrent;
        this.offset = config.offset;
    };

	return Inventory;
});

define('Set',[], function () {
	

	function Set() {
		this.elements = {};
	}

	Set.prototype.add = function(element) {
		this.elements[element] = true;
		return this;
	};

	Set.prototype.remove = function(element) {
		delete this.elements[element];
		return this;
	};

	Set.prototype.has = function(element) {
		return !!this.elements[element];
	};

	Set.prototype.keys = function() {
		return Object.keys(this.elements);
	};

	Set.prototype.copy = function() {
		var newSet = new Set();

		for (var key in this.elements) {
			newSet.add(key);
		}

		return newSet;
	};

	Set.prototype.union = function(that) {
		var newSet = this.copy();

		for (var key in that.elements) {
			newSet.add(key);
		}

		return newSet;
	};

	Set.prototype.intersection = function(that) {
		var newSet = new Set();

		for (var key in this.elements) {
			if (that.has(key)) {
				newSet.add(key);
			}
		}

		return newSet;
	};

	Set.prototype.difference = function(that) {
		var newSet = new Set();

		for (var key in this.elements) {
			if (!that.has(key)) {
				newSet.add(key);
			}
		}

		return newSet;
	};

	return Set;
});

define('rule/RuleSet',[
	'Set',
	'Util'
	], function (
		Set,
		Util
	) {
	

	function RuleSet(rules, setsByName) {
		this.rules = rules || [];
		this.setsByName = setsByName || {};
	}

	RuleSet.prototype.getRuleFor = function(inTerrainItem, inInventoryItem) {
		var firstMatchingRule = Util.findFirst(this.rules, function(rule) {

			var terrainMatch;
			if (Util.isCapitalized(rule.inTerrainItem)) {
				terrainMatch = this.setsByName[rule.inTerrainItem].has(inTerrainItem);
			} else {
				terrainMatch = rule.inTerrainItem === inTerrainItem;
			}

			if (!terrainMatch) {
				return false;
			}

			if (!inInventoryItem) {
				return terrainMatch;
			}

			var inventoryMatch;
			if (Util.isCapitalized(rule.inInventoryItem)) {
				inventoryMatch = this.setsByName[rule.inInventoryItem].has(inInventoryItem);
			} else {
				inventoryMatch = rule.inInventoryItem === inInventoryItem;
			}

			return terrainMatch && inventoryMatch;
		}.bind(this));

		if (firstMatchingRule) {
			return firstMatchingRule.element;
		}
	};

	return RuleSet;
});

define('Camera',[], function () {
	

	function Camera(position, dimensions) {
		this.position = position;
		this.dimensions = dimensions;
	}

	Camera.prototype.centerOn = function (x, y, levelWidth, levelHeight) {
		this.position.x = x - Math.floor(this.dimensions.x / 2);
		this.position.y = y - Math.floor(this.dimensions.y / 2);

		if (this.position.x < 0) {
			this.position.x = 0;
		} else if (this.position.x >= levelWidth - this.dimensions.x) {
			this.position.x = levelWidth - this.dimensions.x;
		}

		if (this.position.y < 0) {
			this.position.y = 0;
		} else if (this.position.y >= levelHeight - this.dimensions.y) {
			this.position.y = levelHeight - this.dimensions.y;
		}
	};

	return Camera;
});

define('TextBubble',[
    'Text',
    'Vec2',
    'con2d',
    'Util'
], function (
    Text,
    Vec2,
    con2d,
    Util
    ) {

	

	function TextBubble() {
        this.position = new Vec2(8, 8);
        this.visible = true;
        this.text = '';
        this.length = -Infinity;
        this.maxLength = 20;
        this.lines = [];
    }

    TextBubble.prototype.hide = function () {
        this.visible = false;
        return this;
	};

    TextBubble.prototype.show = function () {
        this.visible = true;
        return this;
    };

    TextBubble.prototype.draw = function () {
        if (!this.visible) { return; }
        // clear bubble
        con2d.fillStyle = '#007B90';
        con2d.fillRect(this.position.x, this.position.y, this.length * 16 + 8, this.lines.length * 18 + 8);

        // draw the text, line by line
        for (var i = 0; i < this.lines.length; i++) {
            Text.drawAt(this.lines[i], this.position.x + 4, this.position.y + i * 18 + 4);
        }
    };

    TextBubble.prototype.setText = function (text) {
        this.text = text.toUpperCase();

        this.lines = [];
        this.length = -Infinity;

        // chop text on multiple lines
        for (var i = 0; i < this.text.length; i += this.maxLength) {
            var line = this.text.substr(i, this.maxLength).trim();
            this.lines.push(line);

            if (line.length > this.length) {
                this.length = line.length;
            }
        }

        var boxWidth = this.length * 16 + 8;
        this.position.x = Math.floor((con2d.canvas.width - boxWidth) / 2);

        return this;
    };

	return TextBubble;
});

define('World',[
	'Player',
	'Inventory',
	'Items',
	'Vec2',
    'rule/RuleSet',
	'con2d',
	'Camera',
    'TextBubble',
    'Util',
    'underscore'
	], function (
		Player,
		Inventory,
		Items,
		Vec2,
        RuleSet,
		con2d,
		Camera,
        TextBubble,
        Util,
        _
	) {
	

	function World(
		playerSpritesByName,
		levelsByName,
		startLocation,
        nearRuleSet,
		leaveRuleSet,
		enterRuleSet,
		useRuleSet,
		tileDimensions,
		cameraDimensions,
        inventorySizeMax,
        playerMaxHealth
		) {
		this.player = new Player(this, playerMaxHealth, playerSpritesByName, tileDimensions);
		this.startLocation = startLocation;
		this.levelsByName = levelsByName;
		this.level = null;
        this.nearRuleSet = nearRuleSet;
		this.leaveRuleSet = leaveRuleSet;
		this.enterRuleSet = enterRuleSet;
		this.useRuleSet = useRuleSet;
		this.tileDimensions = tileDimensions;

		this.camera = new Camera(new Vec2(0, 0), new Vec2(cameraDimensions.x, cameraDimensions.y));

		this.inventory = new Inventory(
			inventorySizeMax,
			tileDimensions,
			new Vec2(0, this.tileDimensions.y * this.camera.dimensions.y + 8)
		);

        this.textBubble = new TextBubble().hide();

        // animation related
		this.tick = 0;
		this.z = 0;
	}

	World.prototype.init = function () {
		con2d.canvas.width = this.tileDimensions.x * this.camera.dimensions.x; //this.levelsByName.entry.width;
		con2d.canvas.height = this.tileDimensions.y * (this.camera.dimensions.y + 1) + 8; //(this.levelsByName.entry.height + 1) + 8;

		this.player.init();
		this.initStartingLocation();

		con2d.fillStyle = '#000';
		con2d.fillRect(0, 0, con2d.canvas.width, con2d.canvas.height);

		this.camera.centerOn(this.player.position.x, this.player.position.y, this.level.width, this.level.height);

        this.initialState = this.serialize();
	};

	World.prototype.setLevel = function (levelName) {
		this.level = this.levelsByName[levelName];
	};

	World.prototype.initStartingLocation = function () {
		this.level = this.levelsByName[this.startLocation.levelName];
		this.player.setPosition(this.startLocation.x, this.startLocation.y);
	};

	World.prototype.draw = function () {
        if (this.player.alive) {
            this.level.draw(this.camera, this.tick);
            this.inventory.draw();
            this.player.draw(this.camera, this.tick);
        } else {
            con2d.fillStyle = '#000';
            con2d.fillRect(0, 0, con2d.canvas.width, con2d.canvas.height);
        }
        this.textBubble.draw();
	};

	World.prototype.update = function () {
		this.z++; // should count deltaTime
		if (this.z >= 20) {
			this.z = 0;
			this.tick = 1 - this.tick;
		}
	};

    World.prototype.serialize = function () {
        var levels = Util.mapOnKeys(this.levelsByName, function (level) {
            return level.serialize();
        });

        var currentLevel = this.level.id;

        return {
            player: this.player.serialize(),
            inventory: this.inventory.serialize(),
            levels: levels,
            currentLevel: currentLevel
        };
    };

    World.prototype.deserialize = function (config) {
        _.each(config.levels, function (levelConfig, key) {
            this.levelsByName[key].deserialize(levelConfig);
        }.bind(this));

        this.setLevel(config.currentLevel);

        this.player.deserialize(config.player);

        this.inventory.deserialize(config.inventory);
    };

	return World;
});

define('Item',[], function() {
	

	function Item(id, name, sprites, blocking) {
		this.id = id;
		this.name = name;
		this.sprites = sprites;
		this.blocking = blocking;
	}

	Item.prototype.drawAt = function(x, y, tick) {
		if (tick !== undefined) {
			tick = Math.min(tick, this.sprites.length - 1);
		} else {
			tick = 0;
		}
		//tick = tick || (this.sprites.length - 1);
		this.sprites[tick].drawAt(x, y);
	};

	return Item;
});

define('rule/NearRule',[], function() {
	

	function NearRule(
		inTerrainItem,
		outTerrainItem,
		healthDelta
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
		this.healthDelta = healthDelta;
	}

	return NearRule;
});

define('rule/LeaveRule',[], function() {
	

	function LeaveRule(
		inTerrainItem,
		outTerrainItem
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
	}

	return LeaveRule;
});

define('rule/EnterRule',[], function() {
	

	function EnterRule(
		inTerrainItem,
		outTerrainItem,
		outInventoryItems,
		healthDelta,
		teleport,
		message,
        checkpoint
	) {
		this.inTerrainItem = inTerrainItem;
		this.outTerrainItem = outTerrainItem;
		this.outInventoryItems = outInventoryItems;
		this.healthDelta = healthDelta;
		this.teleport = teleport;
		this.message = message;
        this.checkpoint = checkpoint;
	}

	return EnterRule;
});

define('rule/UseRule',[], function() {
	

	function UseRule(
		inTerrainItem,
		inInventoryItem,
		outTerrainItem,
		outInventoryItems,
		consume,
		healthDelta,
		teleport,
		message
	) {
		this.inTerrainItem = inTerrainItem;
		this.inInventoryItem = inInventoryItem;
		this.outTerrainItem = outTerrainItem;
		this.outInventoryItems = outInventoryItems;
		this.consume = consume;
		this.healthDelta = healthDelta;
		this.teleport = teleport;
		this.message = message;
	}

	return UseRule;
});

define('Level',[
	'Items',
	'Vec2'
	], function(
		Items,
		Vec2
	) {
	

	function Level(id, data, levelDimensions, tileDimensions, uiOffset) {
        this.id = id;
		this.data = data;
		this.width = levelDimensions.x;
		this.height = levelDimensions.y;
		this.blockWidth = tileDimensions.x;
		this.blockHeight = tileDimensions.y;
		this.uiOffset = uiOffset || new Vec2(0, 0);
	}

	Level.prototype.get = function(x, y) {
		return this.data[y][x];
	};

	Level.prototype.set = function(x, y, item) {
		this.data[y][x] = item;
		return this;
	};

	Level.prototype.draw = function(camera, tick) {
		for (var i = 0; i < camera.dimensions.y; i++) {
			for (var j = 0; j < camera.dimensions.x; j++) {
				this.data[i + camera.position.y][j + camera.position.x].drawAt(
					this.uiOffset.x + j * this.blockWidth,
					this.uiOffset.y + i * this.blockHeight,
					tick
				);
			}
		}
	};

	Level.prototype.withinBounds = function(x, y) {
		return x >= 0 && x < this.width && y >= 0 && y < this.height;
	};

    Level.prototype.serialize = function () {
        return this.data.map(function (line) {
            return line.map(function (element) {
                return element.id;
            });
        });
    };

    Level.prototype.deserialize = function (config) {
        this.data = config.map(function (line) {
            return line.map(function (element) {
                return Items.collection[element];
            });
        });
    };

	return Level;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('generator/Generator',['generator/SpriteSheetGenerator', 'Util', 'World', 'Item', 'Items', 'Set', 'rule/NearRule', 'rule/LeaveRule', 'rule/EnterRule', 'rule/UseRule', 'rule/RuleSet', 'Vec2', 'Level'], function(SpriteSheetGenerator, Util, World, Item, Items, Set, NearRule, LeaveRule, EnterRule, UseRule, RuleSet, Vec2, Level) {
    var Generator, generateEnterRules, generateLeaveRules, generateLevels, generateNearRules, generateObjects, generateParams, generatePlayer, generateSets, generateUseRules;
    Generator = {};
    Generator.generate = function(spec) {
      var enterRuleSet, leaveRuleSet, levelsByName, nearRuleSet, params, playerSpritesByName, setsByName, tileDimensions, useRuleSet, world;
      params = generateParams(spec.params, spec.levels);
      playerSpritesByName = generatePlayer(spec.player, spec.colors, params.scale);
      Items.collection = generateObjects(spec.objects, spec.colors, params.scale);
      setsByName = generateSets(spec.sets);
      nearRuleSet = generateNearRules(spec.nearRules, setsByName);
      leaveRuleSet = generateLeaveRules(spec.leaveRules, setsByName);
      enterRuleSet = generateEnterRules(spec.enterRules, setsByName);
      useRuleSet = generateUseRules(spec.useRules, setsByName);
      tileDimensions = playerSpritesByName.left.end.sub(playerSpritesByName.left.start);
      levelsByName = generateLevels(spec.levels, spec.legend, tileDimensions);
      world = new World(playerSpritesByName, levelsByName, params.startLocation, nearRuleSet, leaveRuleSet, enterRuleSet, useRuleSet, tileDimensions, params.camera, params.inventorySizeMax, params.healthMax);
      return world;
    };
    generateParams = function(params, levelsSpec) {
      var paramSpec;
      paramSpec = Util.arrayToObject(params, 'name', 'parts');
      return {
        camera: {
          x: +paramSpec.camera[0] || 7,
          y: +paramSpec.camera[1] || 7
        },
        scale: +paramSpec.scale[0] || 8,
        startLocation: {
          x: +paramSpec.start_location[0] || 2,
          y: +paramSpec.start_location[1] || 2,
          levelName: paramSpec.start_location[2] || levelsSpec[0].name
        },
        inventorySizeMax: +paramSpec.inventory_size_max[0] || 5,
        healthMax: +paramSpec.health_max[0]
      };
    };
    Generator.generateParams = generateParams;
    generatePlayer = function(playerSpec, colorSpec, scale) {
      var namedPlayerSprites;
      namedPlayerSprites = SpriteSheetGenerator.generate(playerSpec, colorSpec, scale);
      return Util.arrayToObject(namedPlayerSprites, 'name', 'sprite');
    };
    Generator.generatePlayer = generatePlayer;
    generateObjects = function(objectsSpec, colorSpec, scale) {
      var blockingObjects, groupedSprites, itemsByName, namedSpriteGroups, namedSprites, processSpriteName;
      processSpriteName = function(nam) {
        var separator;
        separator = nam.lastIndexOf(':');
        if (separator === -1) {
          return {
            name: nam,
            frame: 0
          };
        } else {
          return {
            name: nam.substr(0, separator),
            frame: +nam.substr(separator + 1)
          };
        }
      };
      namedSprites = SpriteSheetGenerator.generate(objectsSpec, colorSpec, scale);
      blockingObjects = {};
      objectsSpec.forEach(function(objectSpec) {
        if (objectSpec.blocking) {
          blockingObjects[objectSpec.name] = true;
        }
      });
      groupedSprites = Util.groupBy(namedSprites, function(namedSprite) {
        var frameAndName;
        frameAndName = processSpriteName(namedSprite.name);
        return frameAndName.name;
      });
      namedSpriteGroups = Util.objectToArray(groupedSprites, 'groupName', 'namedSprites');
      itemsByName = {};
      namedSpriteGroups.forEach(function(namedSpriteGroup) {
        var sortedSprites, sprites;
        sortedSprites = namedSpriteGroup.namedSprites.map(function(namedSprite) {
          var nameAndFrame;
          nameAndFrame = processSpriteName(namedSprite.name);
          return {
            sprite: namedSprite.sprite,
            name: nameAndFrame.name,
            frame: nameAndFrame.frame
          };
        }).sort(function(a, b) {
          return a.frame - b.frame;
        });
        sprites = sortedSprites.map(function(namedSprite) {
          return namedSprite.sprite;
        });
        itemsByName[namedSpriteGroup.groupName] = new Item(namedSpriteGroup.groupName, Util.capitalize(namedSpriteGroup.groupName), sprites, !!blockingObjects[namedSpriteGroup.groupName]);
      });
      return itemsByName;
    };
    Generator.generateObjects = generateObjects;
    generateSets = function(spec) {
      var operators, setsByName;
      operators = {
        or: Set.prototype.union,
        and: Set.prototype.intersection,
        minus: Set.prototype.difference
      };
      setsByName = {};
      spec.forEach(function(setDefinition) {
        var operand1, operand2, operator, set;
        set = void 0;
        if (setDefinition.elements) {
          set = new Set();
          setDefinition.elements.forEach(function(element) {
            set.add(element);
          });
        } else {
          operand1 = setsByName[setDefinition.operand1];
          operand2 = setsByName[setDefinition.operand2];
          operator = operators[setDefinition.operator];
          set = operator.call(operand1, operand2);
        }
        setsByName[setDefinition.name] = set;
      });
      return setsByName;
    };
    Generator.generateSets = generateSets;
    generateNearRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var healthDelta, inTerrainItemName, outTerrainItemName;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        healthDelta = 0;
        if (ruleSpec.heal) {
          healthDelta += +ruleSpec.heal;
        }
        if (ruleSpec.hurt) {
          healthDelta -= +ruleSpec.hurt;
        }
        return new NearRule(inTerrainItemName, outTerrainItemName, healthDelta);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateNearRules = generateNearRules;
    generateLeaveRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var inTerrainItemName, outTerrainItemName;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        return new LeaveRule(inTerrainItemName, outTerrainItemName);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateLeaveRules = generateLeaveRules;
    generateEnterRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var healthDelta, inTerrainItemName, message, outInventoryItems, outTerrainItemName, teleport;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        outInventoryItems = void 0;
        if (ruleSpec.give) {
          outInventoryItems = ruleSpec.give.map(function(entry) {
            return {
              itemName: entry.itemName,
              quantity: +entry.quantity
            };
          });
        } else {
          outInventoryItems = [];
        }
        healthDelta = 0;
        if (ruleSpec.heal) {
          healthDelta += +ruleSpec.heal;
        }
        if (ruleSpec.hurt) {
          healthDelta -= +ruleSpec.hurt;
        }
        teleport = void 0;
        if (ruleSpec.teleport) {
          teleport = {
            x: +ruleSpec.teleport.x,
            y: +ruleSpec.teleport.y,
            levelName: ruleSpec.teleport.levelName
          };
        }
        message = void 0;
        if (ruleSpec.message) {
          message = ruleSpec.message;
        }
        return new EnterRule(inTerrainItemName, outTerrainItemName, outInventoryItems, healthDelta, teleport, message, ruleSpec.checkpoint);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateEnterRules = generateEnterRules;
    generateUseRules = function(rulesSpec, setsByName) {
      var rules;
      rules = rulesSpec.map(function(ruleSpec) {
        var consume, healthDelta, inInventoryItemName, inTerrainItemName, message, outInventoryItems, outTerrainItemName, teleport;
        inTerrainItemName = ruleSpec.inTerrainItemName;
        inInventoryItemName = ruleSpec.inInventoryItemName;
        outTerrainItemName = ruleSpec.outTerrainItemName;
        outInventoryItems = void 0;
        if (ruleSpec.give) {
          outInventoryItems = ruleSpec.give.map(function(entry) {
            return {
              itemName: entry.itemName,
              quantity: +entry.quantity
            };
          });
        } else {
          outInventoryItems = [];
        }
        consume = !!ruleSpec.consume;
        healthDelta = 0;
        if (ruleSpec.heal) {
          healthDelta += +ruleSpec.heal;
        }
        if (ruleSpec.hurt) {
          healthDelta -= +ruleSpec.hurt;
        }
        teleport = void 0;
        if (ruleSpec.teleport) {
          teleport = {
            x: +ruleSpec.teleport.x,
            y: +ruleSpec.teleport.y,
            levelName: ruleSpec.teleport.levelName
          };
        }
        message = void 0;
        if (ruleSpec.message) {
          message = ruleSpec.message;
        }
        return new UseRule(inTerrainItemName, inInventoryItemName, outTerrainItemName, outInventoryItems, consume, healthDelta, teleport, message);
      });
      return new RuleSet(rules, setsByName);
    };
    Generator.generateUseRules = generateUseRules;
    generateLevels = function(namedStringedLevels, legendSpec, tileDimensions) {
      var legend, levelsByName;
      levelsByName = {};
      legend = Util.arrayToObject(legendSpec, 'name', 'objectName');
      namedStringedLevels.forEach(function(namedStringedLevel) {
        var data, levelDimensions;
        data = namedStringedLevel.data.map(function(line) {
          return line.split('').map(function(char) {
            var itemName;
            itemName = legend[char];
            return Items.collection[itemName];
          });
        });
        levelDimensions = new Vec2(data[0].length, data.length);
        levelsByName[namedStringedLevel.name] = new Level(namedStringedLevel.name, data, levelDimensions, tileDimensions);
      });
      return levelsByName;
    };
    Generator.generateLevels = generateLevels;
    return Generator;
  });

}).call(this);

define('Game',[
	'SystemBus',
	'World',
	'generator/Generator'
	], function(
		SystemBus,
		World,
		Generator
	) {
	

	function Game() {
		this.world = null;
		this.requestId = null;
	}

	Game.prototype.init = function (tree) {
		this.world = Generator.generate(tree);
		this.world.init();
	};

	Game.prototype.start = function () {
		var loop = function () {
			this.world.update();
			this.world.draw();
			this.requestId = window.requestAnimationFrame(loop);
		}.bind(this);

		loop();
	};

	Game.prototype.cleanup = function () {
		window.cancelAnimationFrame(this.requestId);
		SystemBus.reset();
	};

	return Game;
});

define('tokenizer/TokenCoords',[], function () {
	

	function TokenCoords(line, col) {
		this.line = line;
		this.col = col;
	}

	TokenCoords.prototype.toString = function () {
		return '(line: ' + this.line + ', col: ' + this.col + ')';
	};

	return TokenCoords;
});

define('tokenizer/IterableString',[
	'tokenizer/TokenCoords'
	], function (
		TokenCoords
	) {
	

	function IterableString(str) {
		this.str = str;
		this.pointer = 0;
		this.marker = 0;

		this.line = 1;
		this.col = 1;
	}

	IterableString.prototype.advance = function () {
		if (this.str.charAt(this.pointer) === '\n') {
			this.line++;
			this.col = 1;
		} else {
			this.col++;
		}

		this.pointer++;
	};

	IterableString.prototype.setMarker = function (offset) {
		offset = offset || 0;
		this.marker = this.pointer + offset;
	};

	IterableString.prototype.current = function () {
		return this.str.charAt(this.pointer);
	};

	IterableString.prototype.next = function () {
		return this.str.charAt(this.pointer + 1);
	};

	IterableString.prototype.hasNext = function () {
		return this.pointer < this.str.length;
	};

	IterableString.prototype.getMarked = function (offset) {
		offset = offset || 0;
		return this.str.substring(this.marker, this.pointer + offset);
	};

	IterableString.prototype.getCoords = function () {
		return new TokenCoords(this.line, this.col);
	};

	return IterableString;
});

define('tokenizer/Token',[], function () {
	function Token() {

	}

	return Token;
});
define('tokenizer/TokEnd',['tokenizer/Token'], function (Token) {
	

	function TokEnd(coords) {
		this.coords = coords;
	}

	TokEnd.prototype.match = function (that) {
		return that instanceof TokEnd;
	};

	TokEnd.prototype.toString = function () {
		return 'END';
	};

	TokEnd.prototype.toHTML = function (c) {
		return '';
	};

	return TokEnd;
});

define('tokenizer/TokIdentifier',['tokenizer/Token'], function (Token) {
	

	function TokIdentifier(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokIdentifier.prototype = Object.create(Token.prototype);
	TokIdentifier.prototype.constructor = TokIdentifier;

	TokIdentifier.prototype.match = function (that) {
		return that instanceof TokIdentifier;
	};

	TokIdentifier.prototype.toString = function () {
		return 'Identifier(' + this.value + ' ' + this.coords + ')';
	};

	TokIdentifier.prototype.toHTML = function (c) {
		return '<span style="color:' + c.identifier + '">' + this.s + '</span>';
	};

	return TokIdentifier;
});

define('tokenizer/TokStr',['tokenizer/Token'], function (Token) {
	

	function TokStr(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokStr.prototype.match = function (that) {
		return that instanceof TokStr;
	};

	TokStr.prototype.toString = function () {
		return 'Str(' + this.value + ')';
	};

	TokStr.prototype.toHTML = function (c) {
		return '<span style="color:' + c.str + '">\'' + this.value + '\'</span>';
	};

	return TokStr;
});

define('tokenizer/TokKeyword',['tokenizer/Token'], function (Token) {
	

	function TokKeyword(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokKeyword.prototype.match = function (that) {
		return that === this.value;
	};

	TokKeyword.prototype.toString = function () {
		return 'Keyword(' + this.value + ' ' + this.coords + ')';
	};

	TokKeyword.prototype.toHTML = function (c) {
		return '<span style="font-weight: 900;color:' + c.keyword + '">' + this.value + '</span>';
	};

	return TokKeyword;
});

define('tokenizer/TokCommSL',['tokenizer/Token'], function (Token) {
	

	function TokCommSL(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokCommSL.prototype.toString = function() {
		return 'CommSL(' + this.value + ')';
	};

	TokCommSL.prototype.toHTML = function(c) {
		return '<span style="color:' + c.commSL + '">' + this.value + '</span><br />';
	};

	return TokCommSL;
});

define('tokenizer/TokCommML',['tokenizer/Token'], function (Token) {
	

	function TokCommML(value, coords) {
		this.value = value;
		this.coords = coords;
	}

	TokCommML.prototype.toString = function () {
		return 'CommML(' + this.value + ')';
	};

	TokCommML.prototype.toHTML = function(c) {
		return '<span style="color:' + c.commML + '">' + this.value + '</span>';
	};

	return TokCommML;
});

define('tokenizer/TokComma',['tokenizer/Token'], function (Token) {
	

	function TokComma(coords) {
		this.coords = coords;
	}

	TokComma.prototype.match = function (that) {
		return that instanceof TokComma;
	};

	TokComma.prototype.toString = function () {
		return 'Comma';
	};

	TokComma.prototype.toHTML = function (c) {
		return '<span style="color:' + c.comma + '">)</span>';
	};

	return TokComma;
});

define('tokenizer/TokSemicolon',['tokenizer/Token'], function (Token) {
	

	function TokSemicolon(coords) {
		this.coords = coords;
	}

	TokSemicolon.prototype.match = function (that) {
		return that instanceof TokSemicolon;
	};

	TokSemicolon.prototype.toString = function () {
		return 'Semicolon';
	};

	TokSemicolon.prototype.toHTML = function (c) {
		return '<span style="color:' + c.semicolon + '">)</span>';
	};

	return TokSemicolon;
});

define('tokenizer/TokArrow',['tokenizer/Token'], function (Token) {
	

	function TokArrow(coords) {
		this.coords = coords;
	}

	TokArrow.prototype = Object.create(Token.prototype);
	TokArrow.prototype.constructor = TokArrow;

	TokArrow.prototype.match = function (that) {
		return that instanceof TokArrow;
	};

	TokArrow.prototype.toString = function () {
		return 'Arrow';
	};

	TokArrow.prototype.toHTML = function (c) {
		return '<span style="color:' + c.arrow + '">)</span>';
	};

	return TokArrow;
});

define('tokenizer/TokAssignment',['tokenizer/Token'], function (Token) {
	

	function TokAssignment(coords) {
		this.coords = coords;
	}

	TokAssignment.prototype.match = function (that) {
		return that instanceof TokAssignment;
	};

	TokAssignment.prototype.toString = function () {
		return 'Assignment';
	};

	TokAssignment.prototype.toHTML = function (c) {
		return '<span style="color:' + c.assignment + '">)</span>';
	};

	return TokAssignment;
});

define('tokenizer/TokNewLine',['tokenizer/Token'], function (Token) {
	

	function TokNewLine(coords) {
		this.coords = coords;
	}

	TokNewLine.prototype.match = function (that) {
		return that instanceof TokNewLine;
	};

	TokNewLine.prototype.toString = function () {
		return 'TokNewLine';
	};

	TokNewLine.prototype.toHTML = function (c) {
		return '<span style="color:' + c.par + '">)</span>';
	};

	return TokNewLine;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('tokenizer/Tokenizer',['tokenizer/IterableString', 'tokenizer/TokEnd', 'tokenizer/TokIdentifier', 'tokenizer/TokStr', 'tokenizer/TokKeyword', 'tokenizer/TokCommSL', 'tokenizer/TokCommML', 'tokenizer/TokComma', 'tokenizer/TokSemicolon', 'tokenizer/TokArrow', 'tokenizer/TokAssignment', 'tokenizer/TokNewLine'], function(IterableString, TokEnd, TokIdentifier, TokStr, TokKeyword, TokCommSL, TokCommML, TokComma, TokSemicolon, TokArrow, TokAssignment, TokNewLine) {
    
    var Tokenizer, alphanum, commentMulti, commentSingle, escape, keywords, stringDouble, stringSingle, whitespace;
    Tokenizer = {};
    Tokenizer.chop = function(s) {
      var c, n, str, tok;
      str = new IterableString(s);
      tok = [];
      while (str.hasNext()) {
        c = str.current();
        if (c === "'") {
          tok.push(stringSingle(str));
        } else if (c === '"') {
          tok.push(stringDouble(str));
        } else if (c === '/') {
          n = str.next();
          if (n === '/') {
            commentSingle(str);
          } else if (n === '*') {
            commentMulti(str);
          } else {
            tok.push(alphanum(str));
          }
        } else if (c === '=') {
          tok.push(new TokAssignment(str.getCoords()));
          str.advance();
        } else if (c === ',') {
          tok.push(new TokComma(str.getCoords()));
          str.advance();
        } else if (c === ';') {
          tok.push(new TokSemicolon(str.getCoords()));
          str.advance();
        } else if (c === '-' && str.next() === '>') {
          tok.push(new TokArrow(str.getCoords()));
          str.advance();
          str.advance();
        } else if (c > ' ' && c <= '~') {
          tok.push(alphanum(str));
        } else if (c === '\n') {
          tok.push(new TokNewLine(str.getCoords()));
          str.advance();
        } else {
          whitespace(str);
        }
      }
      tok.push(new TokEnd(str.getCoords()));
      return tok;
    };
    stringSingle = function(str) {
      var accumulated, coords, ex;
      coords = str.getCoords();
      accumulated = [];
      str.advance();
      while (true) {
        if (str.current() === '\\') {
          str.advance();
          if (escape[str.current()]) {
            accumulated.push(escape[str.current()]);
          }
        } else if (str.current() === "'") {
          str.advance();
          return new TokStr(accumulated.join(''), coords);
        } else if (str.current() === '\n' || !str.hasNext()) {
          ex = new Error('String not properly ended');
          ex.coords = str.getCoords();
          throw ex;
        } else {
          accumulated.push(str.current());
        }
        str.advance();
      }
    };
    stringDouble = function(str) {
      var accumulated, coords, ex;
      coords = str.getCoords();
      accumulated = [];
      str.advance();
      while (true) {
        if (str.current() === '\\') {
          str.advance();
          if (escape[str.current()]) {
            accumulated.push(escape[str.current()]);
          }
        } else if (str.current() === '"') {
          str.advance();
          return new TokStr(accumulated.join(''), coords);
        } else if (str.current() === '\n' || !str.hasNext()) {
          ex = new Error('String not properly ended');
          ex.coords = str.getCoords();
          throw ex;
        } else {
          accumulated.push(str.current());
        }
        str.advance();
      }
    };
    commentSingle = function(str) {
      str.setMarker();
      str.advance();
      str.advance();
      while (true) {
        if (str.current() === '\n' || !str.hasNext()) {
          return;
        } else {
          str.advance();
        }
      }
    };
    commentMulti = function(str) {
      str.setMarker();
      str.advance();
      str.advance();
      while (true) {
        if (str.current() === '*' && str.next() === '/') {
          str.advance();
          str.advance();
          return;
        } else if (str.hasNext()) {
          str.advance();
        } else {
          throw 'Multiline comment not properly terminated ' + str.getCoords();
        }
      }
    };
    alphanum = function(str) {
      var coords, tmp;
      coords = str.getCoords();
      str.setMarker();
      tmp = str.current();
      while (tmp > ' ' && tmp <= '~' && (tmp !== '(' && tmp !== ')')) {
        str.advance();
        tmp = str.current();
      }
      tmp = str.getMarked();
      if (keywords.indexOf(tmp) !== -1) {
        return new TokKeyword(tmp, coords);
      } else {
        return new TokIdentifier(tmp, coords);
      }
    };
    whitespace = function(str) {
      str.advance();
    };
    escape = {
      '\\': '\\',
      n: '\n',
      t: '\t',
      '\'': '\'',
      '\"': '\"'
    };
    keywords = ['PARAM', 'COLORS', 'PLAYER', 'OBJECTS', 'SETS', 'NEARRULES', 'LEAVERULES', 'ENTERRULES', 'USERULES', 'LEGEND', 'LEVELS', 'rgb', 'rgba', 'blocking', 'or', 'and', 'minus', 'consume', 'give', 'heal', 'hurt', 'teleport', 'message', 'checkpoint'];
    return Tokenizer;
  });

}).call(this);

define('ParserError',[], function() {
	

	function ParserError(message, line, column) {
	  this.name = 'ParserError';
	  this.message = message || 'Default Message';
	  this.line = line;
	  this.column = column;
	}

	ParserError.prototype = Object.create(Error.prototype);
	ParserError.prototype.constructor = ParserError;

	return ParserError;
});
define('parser/TokenList',['ParserError'], function(ParserError) {
	

	function TokenList(token) {
		this.token = token;
		this.pointer = 0;
	}

	TokenList.prototype.match = function(token) {
		return this.token[this.pointer].match(token);
	};

	TokenList.prototype.matchSeq = function(token) {
		for(var i = 0; i < token.length; i++)
			if(!(this.token[this.pointer + i].match(token[i])))
				return false;

		return true;
	};

	TokenList.prototype.matchAnySeq = function(token) {
		for(var i = 0; i < token.length; i++)
			if(this.matchSeq(token[i]))
				return true;

		return false;
	};

	TokenList.prototype.expect = function(token, exMessage) {
		if(this.match(token)) {
			this.adv();
		} else {
			throw new ParserError(
				exMessage /*+ ' instead got ' + this.cur()*/,
				this.cur().coords.line,
				this.cur().coords.col
			);
		}
	};

	TokenList.prototype.adv = function() {
		if(this.pointer >= this.token.length)
			throw 'TokenList: You\'ve not enough tokens!';

		this.pointer++;
	};

	TokenList.prototype.next = function() {
		this.adv();
		return this.token[this.pointer - 1];
	};

	TokenList.prototype.cur = function() {
		return this.token[this.pointer];
	};

	TokenList.prototype.past = function() {
		return this.token[this.pointer - 1];
	};

	TokenList.prototype.toString = function() {
		var ret = 'TokenList(pointer: ' + this.pointer
						+ ', content: [' + this.token.join(', ') + ']';
		return ret;
	};

	return TokenList;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('parser/Parser',['tokenizer/TokEnd', 'tokenizer/TokIdentifier', 'tokenizer/TokStr', 'tokenizer/TokKeyword', 'tokenizer/TokCommSL', 'tokenizer/TokCommML', 'tokenizer/TokComma', 'tokenizer/TokSemicolon', 'tokenizer/TokArrow', 'tokenizer/TokNewLine', 'tokenizer/TokAssignment', 'tokenizer/TokenCoords', 'parser/TokenList'], function(TokEnd, TokIdentifier, TokStr, TokKeyword, TokCommSL, TokCommML, TokComma, TokSemicolon, TokArrow, TokNewLine, TokAssignment, TokenCoords, TokenList) {
    
    var ARROW, ASSIGNMENT, COMMA, END, ERRPREF, IDENTIFIER, NEWLINE, Parser, SEMICOLON, STR, chompNL, parse, parseColors, parseEnterRules, parseLeaveRules, parseLegend, parseLevels, parseNearRules, parseObjects, parseParams, parsePlayer, parseSets, parseUseRules;
    ERRPREF = 'Parsing exception: ';
    IDENTIFIER = new TokIdentifier();
    STR = new TokStr();
    COMMA = new TokComma();
    SEMICOLON = new TokSemicolon();
    ARROW = new TokArrow();
    NEWLINE = new TokNewLine();
    ASSIGNMENT = new TokAssignment();
    END = new TokEnd();
    Parser = {};
    parse = function(tokenArray) {
      var colors, enterRules, leaveRules, legend, levels, nearRules, objects, params, player, sets, tokens, useRules;
      tokens = new TokenList(tokenArray);
      params = parseParams(tokens);
      colors = parseColors(tokens);
      player = parsePlayer(tokens);
      objects = parseObjects(tokens);
      sets = parseSets(tokens);
      if (tokens.match('NEARRULES')) {
        nearRules = parseNearRules(tokens);
      }
      if (tokens.match('LEAVERULES')) {
        leaveRules = parseLeaveRules(tokens);
      }
      if (tokens.match('ENTERRULES')) {
        enterRules = parseEnterRules(tokens);
      }
      useRules = parseUseRules(tokens);
      legend = parseLegend(tokens);
      levels = parseLevels(tokens);
      return {
        params: params,
        colors: colors,
        player: player,
        objects: objects,
        sets: sets,
        nearRules: nearRules || [],
        leaveRules: leaveRules || [],
        enterRules: enterRules || [],
        useRules: useRules,
        legend: legend,
        levels: levels
      };
    };
    Parser.parse = parse;
    chompNL = function(tokens, exMessage) {
      tokens.expect(NEWLINE, exMessage);
      while (tokens.match(NEWLINE)) {
        tokens.adv();
      }
    };
    parseParams = function(tokens) {
      var paramName, params, parts;
      tokens.expect('PARAM', 'Specification must start with PARAM');
      chompNL(tokens, 'Expected new line after PARAM');
      params = [];
      while (!tokens.match('COLORS')) {
        tokens.expect(IDENTIFIER, '');
        paramName = tokens.past();
        parts = [];
        params.push({
          name: paramName,
          parts: parts
        });
        while (tokens.match(IDENTIFIER)) {
          tokens.adv();
          parts.push(tokens.past());
        }
        chompNL(tokens, 'Expect new line between param declarations');
      }
      return params;
    };
    Parser.parseParams = parseParams;
    parseColors = function(tokens) {
      var alpha, blue, colors, green, name, red, rgba;
      tokens.expect('COLORS', 'Expected COLORS section after PARAM');
      chompNL(tokens, 'Expected new line after COLORS');
      colors = [];
      while (!tokens.match('PLAYER')) {
        tokens.expect(IDENTIFIER, '');
        name = tokens.past();
        rgba = false;
        if (tokens.match('rgb')) {
          rgba = false;
        } else if (tokens.match('rgba')) {
          rgba = true;
        } else {
          throw 'Expected either rgb or rgba';
        }
        tokens.adv();
        tokens.expect(IDENTIFIER, 'Expected red value');
        red = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected green value');
        green = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected blue value');
        blue = tokens.past();
        if (rgba) {
          tokens.expect(IDENTIFIER, 'Expected alpha value');
          alpha = tokens.past();
          colors.push({
            name: name,
            red: red,
            green: green,
            blue: blue,
            alpha: alpha
          });
        } else {
          colors.push({
            name: name,
            red: red,
            green: green,
            blue: blue
          });
        }
        chompNL(tokens, 'Expect new line between color bindings');
      }
      return colors;
    };
    Parser.parseColors = parseColors;
    parsePlayer = function(tokens) {
      var data, playerFrameName, playerFrames;
      tokens.expect('PLAYER', 'Expected PLAYER section after COLORS');
      chompNL(tokens, 'Expected new line after PLAYER');
      playerFrames = [];
      while (!tokens.match('OBJECTS')) {
        tokens.expect(IDENTIFIER, 'Expected at least one player frame');
        playerFrameName = tokens.past();
        data = [];
        chompNL(tokens, 'Expected new line after player frame binding');
        while (!tokens.match(NEWLINE)) {
          tokens.expect(IDENTIFIER, 'Expected sprite data line');
          data.push(tokens.past());
          tokens.expect(NEWLINE, 'Expected new line after sprite data line');
        }
        playerFrames.push({
          name: playerFrameName,
          data: data
        });
        chompNL(tokens, 'Expected new line after player frame declaration');
      }
      return playerFrames;
    };
    Parser.parsePlayer = parsePlayer;
    parseObjects = function(tokens) {
      var object, objectName, objects;
      tokens.expect('OBJECTS', 'Expected OBJECTS section after PLAYER');
      chompNL(tokens, 'Expected new line after OBJECTS');
      objects = [];
      while (!tokens.match('SETS')) {
        tokens.expect(IDENTIFIER, 'Expected at least one object');
        objectName = tokens.past();
        object = {
          name: objectName,
          data: []
        };
        if (tokens.match('blocking')) {
          object.blocking = true;
          tokens.adv();
        }
        chompNL(tokens, 'Expected new line after object name binding');
        while (!tokens.match(NEWLINE)) {
          tokens.expect(IDENTIFIER, 'Expected sprite data line');
          object.data.push(tokens.past());
          tokens.expect(NEWLINE, 'Expected new line after sprite data line');
        }
        objects.push(object);
        chompNL(tokens, 'Expected new line after object declaration');
      }
      return objects;
    };
    Parser.parseObjects = parseObjects;
    parseSets = function(tokens) {
      var elements, firstOperandOrElement, operator, secondOperand, set, setName, sets;
      tokens.expect('SETS', 'Expected SETS after OBJECTS');
      chompNL(tokens, 'Expected new line after SETS');
      sets = [];
      while (!(tokens.match('NEARRULES') || tokens.match('LEAVERULES') || tokens.match('ENTERRULES') || tokens.match('USERULES'))) {
        tokens.expect(IDENTIFIER, '');
        setName = tokens.past().value;
        set = {
          name: setName
        };
        tokens.expect(ASSIGNMENT, 'Expecting assignment operator');
        tokens.expect(IDENTIFIER, 'Expecting identifier after assignment');
        firstOperandOrElement = tokens.past().value;
        if (tokens.match('or') || tokens.match('and') || tokens.match('minus')) {
          operator = tokens.next().value;
          tokens.expect(IDENTIFIER);
          secondOperand = tokens.past().value;
          set.operator = operator;
          set.operand1 = firstOperandOrElement;
          set.operand2 = secondOperand;
        } else {
          elements = [firstOperandOrElement];
          while (tokens.match(IDENTIFIER)) {
            elements.push(tokens.next().value);
          }
          set.elements = elements;
        }
        sets.push(set);
        chompNL(tokens, 'Expected new line after set declaration');
      }
      return sets;
    };
    Parser.parseSets = parseSets;
    parseNearRules = function(tokens) {
      var rule, rules;
      tokens.expect('NEARRULES', 'Expected NEARRULES section after SETS');
      chompNL(tokens, 'Expected new line after NEARRULES');
      rules = [];
      while (!tokens.match('LEAVERULES') && !tokens.match('ENTERRULES') && !tokens.match('USERULES')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        while (tokens.match(SEMICOLON)) {
          tokens.adv();
          if (tokens.match('heal')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected heal quantity');
            rule.heal = tokens.past();
          } else if (tokens.match('hurt')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected hurt quantity');
            rule.hurt = tokens.past();
          }
        }
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseNearRules = parseNearRules;
    parseLeaveRules = function(tokens) {
      var rule, rules;
      tokens.expect('LEAVERULES', 'Expected LEAVERULES section after SETS');
      chompNL(tokens, 'Expected new line after LEAVERULES');
      rules = [];
      while (!tokens.match('ENTERRULES') && !tokens.match('USERULES')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseLeaveRules = parseLeaveRules;
    parseEnterRules = function(tokens) {
      var item, rule, rules;
      tokens.expect('ENTERRULES', 'Expected ENTERRULES section after LEAVERULES');
      chompNL(tokens, 'Expected new line after ENTERRULES');
      rules = [];
      while (!tokens.match('USERULES')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        while (tokens.match(SEMICOLON)) {
          tokens.adv();
          if (tokens.match('give')) {
            tokens.adv();
            item = {};
            tokens.expect(IDENTIFIER, 'Expected give quantity');
            item.quantity = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected give item name');
            item.itemName = tokens.past();
            rule.give = [item];
            while (tokens.match(COMMA)) {
              tokens.adv();
              item = {};
              tokens.expect(IDENTIFIER, 'Expected give quantity');
              item.quantity = tokens.past();
              tokens.expect(IDENTIFIER, 'Expected give item name');
              item.itemName = tokens.past();
              rule.give.push(item);
            }
          } else if (tokens.match('heal')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected heal quantity');
            rule.heal = tokens.past();
          } else if (tokens.match('hurt')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected hurt quantity');
            rule.hurt = tokens.past();
          } else if (tokens.match('teleport')) {
            tokens.adv();
            rule.teleport = {};
            tokens.expect(IDENTIFIER, 'Expected teleport level name');
            rule.teleport.levelName = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position X');
            rule.teleport.x = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position Y');
            rule.teleport.y = tokens.past();
          } else if (tokens.match('message')) {
            tokens.adv();
            tokens.expect(STR, 'Expected message');
            rule.message = tokens.past();
          } else if (tokens.match('checkpoint')) {
            tokens.adv();
            rule.checkpoint = true;
          }
        }
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseEnterRules = parseEnterRules;
    parseUseRules = function(tokens) {
      var item, rule, rules;
      tokens.expect('USERULES', 'Expected USERULES section after SETS');
      chompNL(tokens, 'Expected new line after USERULES');
      rules = [];
      while (!tokens.match('LEGEND')) {
        rule = {};
        tokens.expect(IDENTIFIER, 'Expected terrain unit');
        rule.inTerrainItemName = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected inventory unit');
        rule.inInventoryItemName = tokens.past();
        tokens.expect(ARROW, 'Expected ->');
        tokens.expect(IDENTIFIER, 'Expected out terrain unit');
        rule.outTerrainItemName = tokens.past();
        while (tokens.match(SEMICOLON)) {
          tokens.adv();
          if (tokens.match('give')) {
            tokens.adv();
            item = {};
            tokens.expect(IDENTIFIER, 'Expected give quantity');
            item.quantity = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected give item name');
            item.itemName = tokens.past();
            rule.give = [item];
            while (tokens.match(COMMA)) {
              tokens.adv();
              item = {};
              tokens.expect(IDENTIFIER, 'Expected give quantity');
              item.quantity = tokens.past();
              tokens.expect(IDENTIFIER, 'Expected give item name');
              item.itemName = tokens.past();
              rule.give.push(item);
            }
          } else if (tokens.match('consume')) {
            tokens.adv();
            rule.consume = true;
          } else if (tokens.match('heal')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected heal quantity');
            rule.heal = tokens.past();
          } else if (tokens.match('hurt')) {
            tokens.adv();
            tokens.expect(IDENTIFIER, 'Expected hurt quantity');
            rule.hurt = tokens.past();
          } else if (tokens.match('teleport')) {
            tokens.adv();
            rule.teleport = {};
            tokens.expect(IDENTIFIER, 'Expected teleport level name');
            rule.teleport.levelName = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position X');
            rule.teleport.x = tokens.past();
            tokens.expect(IDENTIFIER, 'Expected teleport position Y');
            rule.teleport.y = tokens.past();
          } else if (tokens.match('message')) {
            tokens.adv();
            tokens.expect(STR, 'Expected message');
            rule.message = tokens.past();
          }
        }
        chompNL(tokens, 'Expected new line between rules');
        rules.push(rule);
      }
      return rules;
    };
    Parser.parseUseRules = parseUseRules;
    parseLegend = function(tokens) {
      var legend, objectName, terrainChar;
      tokens.expect('LEGEND', 'Expected LEGEND section after RULES');
      chompNL(tokens, 'Expected new line after LEGEND');
      legend = [];
      while (!tokens.match('LEVELS')) {
        tokens.expect(IDENTIFIER, '');
        terrainChar = tokens.past();
        tokens.expect(IDENTIFIER, 'Expected terrain binding');
        objectName = tokens.past();
        legend.push({
          name: terrainChar,
          objectName: objectName
        });
        chompNL(tokens, 'Expected new line between terrain bindings');
      }
      return legend;
    };
    Parser.parseLegend = parseLegend;
    parseLevels = function(tokens) {
      var levelName, levels, lines;
      tokens.expect('LEVELS', 'Expected LEVELS section after LEGEND');
      chompNL(tokens, 'Expected new line after LEVELS');
      levels = [];
      while (!tokens.match(END)) {
        tokens.expect(IDENTIFIER, 'Expected at least one level');
        levelName = tokens.past().value;
        lines = [];
        chompNL(tokens, 'Expected new line after level name binding');
        while (!(tokens.match(NEWLINE) || tokens.match(END))) {
          tokens.expect(IDENTIFIER, 'Expected level data line');
          lines.push(tokens.past());
          if (!tokens.match(END)) {
            tokens.expect(NEWLINE, 'Expected new line after level data line');
          }
        }
        levels.push({
          name: levelName,
          data: lines
        });
        if (!tokens.match(END)) {
          chompNL(tokens, 'Expected new line after level declaration');
        }
      }
      return levels;
    };
    Parser.parseLevels = parseLevels;
    return Parser;
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  define('validator/ValidatorError',[], function() {
    var ValidatorError;
    ValidatorError = function(token, message) {
      this.token = token;
      this.message = message;
    };
    ValidatorError.prototype = Object.create(Error.prototype);
    ValidatorError.prototype.constructor = ValidatorError;
    return ValidatorError;
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  define('validator/Validator',['validator/ValidatorError', 'Util'], function(ValidatorError, Util) {
    
    var Validator, checkCollisions, validateColorComponent, validateColors, validateEnterRules, validateLeaveRules, validateLegend, validateLevels, validateNearRules, validateObjects, validatePlayer, validateSets, validateSprites, validateUseRules;
    Validator = {};
    Validator.validate = function(spec) {
      validateColors(spec.colors);
      validatePlayer(spec.player, spec.colors);
      validateObjects(spec.objects, spec.colors);
      validateSets(spec.sets, spec.objects);
      validateNearRules(spec.nearRules, spec.sets, spec.objects);
      validateLeaveRules(spec.leaveRules, spec.sets, spec.objects);
      validateEnterRules(spec.enterRules, spec.sets, spec.objects);
      validateUseRules(spec.useRules, spec.sets, spec.objects);
      validateLegend(spec.legend, spec.objects);
      validateLevels(spec.levels, spec.legend);
      return true;
    };
    checkCollisions = function(array, valueExtractor, tokenExtractor, err) {
      var maybeDuplicate, plucked;
      plucked = array.map(valueExtractor);
      maybeDuplicate = Util.getDuplicate(plucked);
      if (maybeDuplicate.value != null) {
        throw new ValidatorError(tokenExtractor(array[maybeDuplicate.index]), err);
      }
    };
    validateColorComponent = function(component, name, min, max) {
      var value;
      if (isNaN(component.value)) {
        throw new ValidatorError(component, "" + name + " value must be a number");
      }
      value = +component.value;
      if (value < min || value > max) {
        throw new ValidatorError(component, "" + name + " value must be between " + min + " and " + max);
      }
      return true;
    };
    validateColors = function(colorsSpec) {
      checkCollisions(colorsSpec, function(colorSpec) {
        return colorSpec.name.value;
      }, function(colorSpec) {
        return colorSpec.name;
      }, 'Color binding already declared');
      colorsSpec.forEach(function(color) {
        if (color.name.value.length !== 1) {
          throw new ValidatorError(color.name, 'Color bindings must have one character in length');
        }
        validateColorComponent(color.red, 'Red', 0, 255);
        validateColorComponent(color.green, 'Green', 0, 255);
        validateColorComponent(color.blue, 'Blue', 0, 255);
        if (color.alpha) {
          return validateColorComponent(color.alpha, 'Alpha', 0, 1);
        }
      });
      return true;
    };
    Validator.validateColors = validateColors;
    validateSprites = function(spritesSpec, colorsSpec) {
      var colorChars, height, width;
      checkCollisions(spritesSpec, function(spriteSpec) {
        return spriteSpec.name.value;
      }, function(spriteSpec) {
        return spriteSpec.name;
      }, 'Sprite binding already declared');
      width = spritesSpec[0].data[0].value.length;
      height = spritesSpec[0].data.length;
      spritesSpec.forEach(function(spriteSpec) {
        if (spriteSpec.data.length !== height) {
          throw new ValidatorError(spriteSpec.data[0], 'Sprites must be of the same size');
        } else {
          return spriteSpec.data.forEach(function(line, i) {
            if (line.value.length !== width) {
              throw new ValidatorError(line, 'Sprites must be of the same size');
            }
          });
        }
      });
      colorChars = {};
      colorsSpec.forEach(function(colorSpec) {
        return colorChars[colorSpec.name.value] = true;
      });
      return spritesSpec.forEach(function(spriteSpec) {
        return spriteSpec.data.forEach(function(line) {
          return line.value.split('').forEach(function(char) {
            if (!colorChars[char]) {
              throw new ValidatorError(line, 'No color is bound to character ' + char);
            }
          });
        });
      });
    };
    validatePlayer = function(playerSpec, colorsSpec) {
      var spriteNames;
      validateSprites(playerSpec, colorsSpec);
      spriteNames = {};
      playerSpec.forEach(function(frameSpec) {
        return spriteNames[frameSpec.name.value] = true;
      });
      return ['up', 'left', 'down', 'right', 'health'].forEach(function(name) {
        if (!spriteNames[name]) {
          throw new ValidatorError(null, 'Missing player frame: ' + name);
        }
      });
    };
    Validator.validatePlayer = validatePlayer;
    validateObjects = function(objectsSpec, colorsSpec) {
      return validateSprites(objectsSpec, colorsSpec);
    };
    Validator.validateObjects = validateObjects;
    validateSets = function(setSpec, objectsSpec) {};
    Validator.validateSets = validateSets;
    validateNearRules = function(rulesSpec, setSpec, objectsSpec) {};
    Validator.validateNearRules = validateNearRules;
    validateLeaveRules = function(rulesSpec, setSpec, objectsSpec) {};
    Validator.validateLeaveRules = validateLeaveRules;
    validateEnterRules = function(rulesSpec, setSpec, objectsSpec) {};
    Validator.validateEnterRules = validateEnterRules;
    validateUseRules = function(rulesSpec, setSpec, objectsSpec) {};
    Validator.validateUseRules = validateUseRules;
    validateLegend = function(legendSpec, objectsSpec) {
      var inverseMapping;
      checkCollisions(legendSpec, function(binding) {
        return binding.name.value;
      }, function(binding) {
        return binding.name;
      }, 'Terrain unit binding already declared');
      inverseMapping = legendSpec.map(function(binding) {
        return binding.objectName;
      });
      checkCollisions(inverseMapping, function(binding) {
        return binding.value;
      }, function(binding) {
        return binding;
      }, 'Object already bound');
      return legendSpec.forEach(function(binding) {
        if (binding.name.value.length !== 1) {
          throw new ValidatorError(binding.name, 'Terrain bindings must have one character in length');
        }
      });
    };
    Validator.validateLegend = validateLegend;
    validateLevels = function(levelsSpec, legendSpec) {};
    Validator.validateLevels = validateLevels;
    return Validator;
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  define('extractor/ValueExtractor',['tokenizer/Token'], function(Token) {
    
    var ValueExtractor, extract;
    ValueExtractor = {};
    extract = function(tree) {
      var ret;
      if (tree instanceof Token) {
        return tree.value;
      } else if (Array.isArray(tree)) {
        return tree.map(extract);
      } else if (typeof tree === 'object') {
        ret = {};
        Object.keys(tree).forEach(function(key) {
          return ret[key] = extract(tree[key]);
        });
        return ret;
      } else {
        return tree;
      }
    };
    ValueExtractor.extract = extract;
    return ValueExtractor;
  });

}).call(this);

define('KeyListener',['SystemBus'], function (SystemBus) {
	

	var keyState = {};

	function onKeyDown(e) {
		e.preventDefault();
		e.stopPropagation();

		if (!keyState[e.which]) {
			SystemBus.emit('keydown', { key: e.which });
		}
		keyState[e.which] = true;
	}

	function onKeyUp(e) {
		e.preventDefault();
		e.stopPropagation();

		if (keyState[e.which]) {
			SystemBus.emit('keyup', { key: e.which });
		}
		keyState[e.which] = false;
	}



	var KeyListener = {};

	KeyListener.init = function (domElement) {
		domElement.addEventListener('keydown', onKeyDown);
		domElement.addEventListener('keyup', onKeyUp);
	};

	return KeyListener;
});

// Generated by CoffeeScript 1.7.1
(function() {
  define('import-export/FromPng',[], function() {
    var FromPng, imageToData;
    FromPng = {};
    imageToData = function(image) {
      var canvas, context;
      canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      context = canvas.getContext('2d');
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height).data;
    };
    FromPng.decode = function(path, callback) {
      var image;
      image = new Image;
      image.crossOrigin = '';
      image.src = path;
      return image.addEventListener('load', function() {
        var c, data, i, text, textSize;
        data = imageToData(image);
        textSize = data[0] * 256 + data[1];
        text = [];
        i = 4;
        c = 0;
        while (c < textSize - 3) {
          text.push(String.fromCharCode(data[i + 0]));
          text.push(String.fromCharCode(data[i + 1]));
          text.push(String.fromCharCode(data[i + 2]));
          i += 4;
          c += 3;
        }
        while (c < textSize) {
          text.push(String.fromCharCode(data[i]));
          i++;
          c++;
        }
        return callback(text.join(''));
      });
    };
    return FromPng;
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  define('import-export/ToPng',[], function() {
    var ToPng, dataToCanvas, maxAlpha;
    ToPng = {};
    dataToCanvas = function(data) {
      var canvas, context, i, imageData, p, sqrt;
      canvas = document.createElement('canvas');
      sqrt = Math.ceil(Math.sqrt((data.length + 3) / 3));
      canvas.width = sqrt;
      canvas.height = sqrt;
      context = canvas.getContext('2d');
      imageData = context.createImageData(sqrt, sqrt);
      imageData.data[0] = Math.floor(data.length / 256);
      imageData.data[1] = data.length % 256;
      imageData.data[3] = 255;
      i = 0;
      p = 4;
      while (i < data.length) {
        imageData.data[p + 0] = data[i + 0];
        imageData.data[p + 1] = data[i + 1];
        imageData.data[p + 2] = data[i + 2];
        imageData.data[p + 3] = 255;
        i += 3;
        p += 4;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    };
    maxAlpha = function(rawData) {
      var data, i;
      data = [];
      i = 0;
      while (i < rawData.length) {
        data.push(rawData[i + 0]);
        data.push(rawData[i + 1]);
        data.push(rawData[i + 2]);
        data.push(255);
        i += 3;
      }
      return data;
    };
    ToPng.encode = function(text) {
      var data, i;
      data = [];
      i = 0;
      while (i < text.length) {
        data.push(text.charCodeAt(i));
        i++;
      }
      return dataToCanvas(data);
    };
    return ToPng;
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  define('AjaxUtil',[], function() {
    var AjaxUtil;
    AjaxUtil = {};
    AjaxUtil.load = function(url, callback) {
      var httpRequest;
      httpRequest = new XMLHttpRequest();
      httpRequest.onreadystatechange = function() {
        if (httpRequest.readyState === 4) {
          if (httpRequest.status === 200) {
            return callback(httpRequest.responseText);
          } else {
            throw new Error('Could not retrieve ' + url);
          }
        }
      };
      httpRequest.open('GET', url);
      return httpRequest.send();
    };
    return AjaxUtil;
  });

}).call(this);

define('main',[
	'SystemBus',
	'Text',
	'Game',
	'tokenizer/Tokenizer',
	'parser/Parser',
	'validator/Validator',
	'extractor/ValueExtractor',
	'KeyListener',
	'import-export/FromPng',
	'import-export/ToPng',
	'AjaxUtil'
	], function (
		SystemBus,
		Text,
		Game,
		Tokenizer,
		Parser,
		Validator,
		ValueExtractor,
		KeyListener,
		FromPng,
		ToPng,
		AjaxUtil
	) {
	

	var tree;
	var errorLine = null;
	var inWorldEditor;
	var game;
	var baseUrl = 'http://madflame991.github.io/furnace-engine/src/index.html';

	function setupEditors() {
		inWorldEditor = CodeMirror.fromTextArea(document.getElementById('in'), {
            lineNumbers: true,
            styleActiveLine: true
        });
        inWorldEditor.setSize(400, 400);
        inWorldEditor.setOption('theme', 'cobalt');
        inWorldEditor.on('change', parse);
	}

	function parse() {
		var inText = inWorldEditor.getValue();

		try {
			var tokens = Tokenizer.chop(inText);
			tree = Parser.parse(tokens);
			Validator.validate(tree);

			if (errorLine !== null) {
				inWorldEditor.removeLineClass(errorLine - 1, 'background', 'line-error');
				errorLine = null;
			}

			document.getElementById('status').classList.add('ok');
			document.getElementById('status').classList.remove('err');
			document.getElementById('status').innerHTML = 'OK';

			document.getElementById('compile').disabled = false;
		} catch (ex) {
			tree = null;
			document.getElementById('compile').disabled = true;

			if (ex.line || ex.token) {
				var line = ex.line || ex.token.coords.line;
				if (line !== errorLine && errorLine !== null) {
					inWorldEditor.removeLineClass(errorLine - 1, 'background', 'line-error');
				}
				errorLine = line;
				inWorldEditor.addLineClass(errorLine - 1, 'background', 'line-error');
			}

			document.getElementById('status').classList.add('err');
			document.getElementById('status').classList.remove('ok');
			document.getElementById('status').innerHTML = ex.message || ex;
		}
	}

	function compile() {
		if (tree) {
			if (game) {
				game.cleanup();
			}

			var valueTree = ValueExtractor.extract(tree);
			game = new Game();
			game.init(valueTree);
			game.start();
		}
	}

	function hide() {
		var editorDiv = document.getElementById('editor');
		editorDiv.style.display = 'none';

		var editButton = document.getElementById('edit');
		editButton.style.display = 'block';

		var hideButton = document.getElementById('hide');
		hideButton.style.display = 'none';

		var gameContDiv = document.getElementById('gamecont');
		gameContDiv.classList.add('centeredcont');

		var canvas = document.getElementById('can');
		canvas.focus();
	}

	function edit() {
		var editorDiv = document.getElementById('editor');
		editorDiv.style.display = 'block';

		var editButton = document.getElementById('edit');
		editButton.style.display = 'none';

		var hideButton = document.getElementById('hide');
		hideButton.style.display = 'block';

		var gameContDiv = document.getElementById('gamecont');
		gameContDiv.classList.remove('centeredcont');

		inWorldEditor.refresh();
	}

	function setupGUI() {
		var compileButton = document.getElementById('compile');
		compileButton.addEventListener('click', compile);

		var getUrlButton = document.getElementById('geturl');
		getUrlButton.addEventListener('click', setUrl);

		var exportAsPngButton = document.getElementById('exportaspng');
		exportAsPngButton.addEventListener('click', exportAsPng);

		var editButton = document.getElementById('edit');
		editButton.addEventListener('click', edit);

		var hideButton = document.getElementById('hide');
		hideButton.addEventListener('click', hide);
	}

	function setUrl() {
		var spec = inWorldEditor.getValue();
		var encodedLevel = encodeURIComponent(spec);
		var url = baseUrl + '?spec=' + encodedLevel;

		var urlTextarea = document.getElementById('url');
		urlTextarea.value = url;
	}

	function exportAsPng() {
		var spec = inWorldEditor.getValue();
		var canvas = ToPng.encode(spec);

		var image = document.createElement('img');
		image.src = canvas.toDataURL();
		image.id = 'exported-spec';

		var existingImage = document.getElementById('exported-spec');
		if (existingImage) {
			existingImage.parentNode.removeChild(existingImage);
		}

		var urlTextarea = document.getElementById('url');
		urlTextarea.value = 'Exported spec as image\n' +
			'To decode the image access: ' + baseUrl + '?png=_image_url_';

		var container = document.getElementById('exported-container');
		container.appendChild(image);
	}

	function checkUrl(callback) {
		var urlParams = purl(true).param();
		if (urlParams.spec) {
			inWorldEditor.setValue(urlParams.spec);
			callback();
		} else if (urlParams.png) {
			FromPng.decode(urlParams.png, function (text) {
				inWorldEditor.setValue(text);
				callback();
			});
		} else if (urlParams.text) {
			AjaxUtil.load(urlParams.text, function (text) {
				inWorldEditor.setValue(text);
				callback();
			});
		} else {
			callback();
		}
	}

	function run() {
		setupEditors();
		setupGUI();

		checkUrl(function () {
			Text.init();

			document.getElementById('can').tabIndex = 0;
			KeyListener.init(document.getElementById('can'));

			parse();
			compile();

			document.getElementById('can').focus();
		});
	}

	return { run: run };
});
  })();
})();